"# Signal\n\nThis module contains classes and functions for [filtering](https://nvlabs.github.io/sionna/api/signal.html#filter) (pulse shaping), [windowing](https://nvlabs.github.io/sionna/api/signal.html#window), and [up-](https://nvlabs.github.io/sionna/api/signal.html#upsampling) and [downsampling](https://nvlabs.github.io/sionna/api/signal.html#downsampling).\nThe following figure shows the different components that can be implemented using this module.\n\n\nThis module also contains [utility functions](https://nvlabs.github.io/sionna/api/signal.html#utility) for computing the (inverse) discrete Fourier transform ([FFT](https://nvlabs.github.io/sionna/api/signal.html#fft)/[IFFT](https://nvlabs.github.io/sionna/api/signal.html#ifft)), and for empirically computing the [power spectral density (PSD)](https://nvlabs.github.io/sionna/api/signal.html#empirical-psd) and [adjacent channel leakage ratio (ACLR)](https://nvlabs.github.io/sionna/api/signal.html#empirical-aclr) of a signal.\n\nThe following code snippet shows how to filter a sequence of QAM baseband symbols using a root-raised-cosine filter with a Hann window:\n```python\n# Create batch of QAM-16 sequences\nbatch_size = 128\nnum_symbols = 1000\nnum_bits_per_symbol = 4\nx = QAMSource(num_bits_per_symbol)([batch_size, num_symbols])\n# Create a root-raised-cosine filter with Hann windowing\nbeta = 0.22 # Roll-off factor\nspan_in_symbols = 32 # Filter span in symbols\nsamples_per_symbol = 4 # Number of samples per symbol, i.e., the oversampling factor\nrrcf_hann = RootRaisedCosineFilter(span_in_symbols, samples_per_symbol, beta, window=\"hann\")\n# Create instance of the Upsampling layer\nus = Upsampling(samples_per_symbol)\n# Upsample the baseband x\nx_us = us(x)\n# Filter the upsampled sequence\nx_rrcf = rrcf_hann(x_us)\n```\n\n\nOn the receiver side, one would recover the baseband symbols as follows:\n```python\n# Instantiate a downsampling layer\nds = Downsampling(samples_per_symbol, rrcf_hann.length-1, num_symbols)\n# Apply the matched filter\nx_mf = rrcf_hann(x_rrcf)\n# Recover the transmitted symbol sequence\nx_hat = ds(x_mf)\n```"
"### SincFilter\n\n`class` `sionna.signal.``SincFilter`(*`span_in_symbols`*, *`samples_per_symbol`*, *`window``=``None`*, *`normalize``=``True`*, *`trainable``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/filter.html#SincFilter)\n\nLayer for applying a sinc filter of `length` K\nto an input `x` of length N.\n\nThe sinc filter is defined by\n\n$$\nh(t) = \\frac{1}{T}\\text{sinc}\\left(\\frac{t}{T}\\right)\n$$\n\nwhere $T$ the symbol duration.\n\nThe filter length K is equal to the filter span in symbols (`span_in_symbols`)\nmultiplied by the oversampling factor (`samples_per_symbol`).\nIf this product is even, a value of one will be added.\n\nThe filter is applied through discrete convolution.\n\nAn optional windowing function `window` can be applied to the filter.\n\nThe <cite>dtype</cite> of the output is <cite>tf.float</cite> if both `x` and the filter coefficients have dtype <cite>tf.float</cite>.\nOtherwise, the dtype of the output is <cite>tf.complex</cite>.\n\nThree padding modes are available for applying the filter:\n\n- full (default): Returns the convolution at each point of overlap between `x` and the filter.\nThe length of the output is N + K - 1. Zero-padding of the input `x` is performed to\ncompute the convolution at the borders.\n- same: Returns an output of the same length as the input `x`. The convolution is computed such\nthat the coefficients of the input `x` are centered on the coefficient of the filter with index\n(K-1)/2. Zero-padding of the input signal is performed to compute the convolution at the borders.\n- valid: Returns the convolution only at points where `x` and the filter completely overlap.\nThe length of the output is N - K + 1.\n\nParameters\n\n- **span_in_symbols** (*int*)  Filter span as measured by the number of symbols.\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **window** (* or **string** (**[**\"hann\"**, **\"hamming\"**, **\"blackman\"**]**)*)  Instance of [`Window`](https://nvlabs.github.io/sionna/api/signal.html#sionna.signal.Window) that is applied to the filter coefficients.\nAlternatively, a string indicating the window name can be provided. In this case,\nthe chosen window will be instantiated with the default parameters. Custom windows\nmust be provided as instance.\n- **normalize** (*bool*)  If <cite>True</cite>, the filter is normalized to have unit power.\nDefaults to <cite>True</cite>.\n- **trainable** (*bool*)  If <cite>True</cite>, the filter coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n- **x** (*[, N], tf.complex or tf.float*)  The input to which the filter is applied.\nThe filter is applied along the last dimension.\n- **padding** (*string ([full, valid, same])*)  Padding mode for convolving `x` and the filter.\nMust be one of full, valid, or same. Case insensitive.\nDefaults to full.\n- **conjugate** (*bool*)  If <cite>True</cite>, the complex conjugate of the filter is applied.\nDefaults to <cite>False</cite>.\n\n\nOutput\n\n**y** (*[,M], tf.complex or tf.float*)  Filtered input.\nIt is <cite>tf.float</cite> only if both `x` and the filter are <cite>tf.float</cite>.\nIt is <cite>tf.complex</cite> otherwise.\nThe length M depends on the `padding`.\n\n\n`property` `aclr`\n\nACLR of the filter\n\nThis ACLR corresponds to what one would obtain from using\nthis filter as pulse shaping filter on an i.i.d. sequence of symbols.\nThe in-band is assumed to range from [-0.5, 0.5] in normalized\nfrequency.\n\n\n`property` `coefficients`\n\nThe filter coefficients (after normalization)\n\n\n`property` `length`\n\nThe filter length in samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the filter is normalized to have unit power. <cite>False</cite> otherwise.\n\n\n`property` `sampling_times`\n\nSampling times in multiples of the symbol duration\n\n\n`show`(*`response``=``'impulse'`*, *`scale``=``'lin'`*)\n\nPlot the impulse or magnitude response\n\nPlots the impulse response (time domain) or magnitude response\n(frequency domain) of the filter.\n\nFor the computation of the magnitude response, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe filter coefficients in the time domain.\nInput\n\n- **response** (*str, one of [impulse, magnitude]*)  The desired response type.\nDefaults to impulse\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude response.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the filter coefficients are trainable. <cite>False</cite> otherwise.\n\n\n`property` `window`\n\nThe window function that is applied to the filter coefficients. <cite>None</cite> if no window is applied."
"### RaisedCosineFilter\n\n`class` `sionna.signal.``RaisedCosineFilter`(*`span_in_symbols`*, *`samples_per_symbol`*, *`beta`*, *`window``=``None`*, *`normalize``=``True`*, *`trainable``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/filter.html#RaisedCosineFilter)\n\nLayer for applying a raised-cosine filter of `length` K\nto an input `x` of length N.\n\nThe raised-cosine filter is defined by\n\n$$\n\\begin{split}h(t) =\n\\begin{cases}\n\\frac{\\pi}{4T} \\text{sinc}\\left(\\frac{1}{2\\beta}\\right), & \\text { if }t = \\pm \\frac{T}{2\\beta}\\\\\n\\frac{1}{T}\\text{sinc}\\left(\\frac{t}{T}\\right)\\frac{\\cos\\left(\\frac{\\pi\\beta t}{T}\\right)}{1-\\left(\\frac{2\\beta t}{T}\\right)^2}, & \\text{otherwise}\n\\end{cases}\\end{split}\n$$\n\nwhere $\\beta$ is the roll-off factor and $T$ the symbol duration.\n\nThe filter length K is equal to the filter span in symbols (`span_in_symbols`)\nmultiplied by the oversampling factor (`samples_per_symbol`).\nIf this product is even, a value of one will be added.\n\nThe filter is applied through discrete convolution.\n\nAn optional windowing function `window` can be applied to the filter.\n\nThe <cite>dtype</cite> of the output is <cite>tf.float</cite> if both `x` and the filter coefficients have dtype <cite>tf.float</cite>.\nOtherwise, the dtype of the output is <cite>tf.complex</cite>.\n\nThree padding modes are available for applying the filter:\n\n- full (default): Returns the convolution at each point of overlap between `x` and the filter.\nThe length of the output is N + K - 1. Zero-padding of the input `x` is performed to\ncompute the convolution at the borders.\n- same: Returns an output of the same length as the input `x`. The convolution is computed such\nthat the coefficients of the input `x` are centered on the coefficient of the filter with index\n(K-1)/2. Zero-padding of the input signal is performed to compute the convolution at the borders.\n- valid: Returns the convolution only at points where `x` and the filter completely overlap.\nThe length of the output is N - K + 1.\n\nParameters\n\n- **span_in_symbols** (*int*)  Filter span as measured by the number of symbols.\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **beta** (*float*)  Roll-off factor.\nMust be in the range $[0,1]$.\n- **window** (* or **string** (**[**\"hann\"**, **\"hamming\"**, **\"blackman\"**]**)*)  Instance of [`Window`](https://nvlabs.github.io/sionna/api/signal.html#sionna.signal.Window) that is applied to the filter coefficients.\nAlternatively, a string indicating the window name can be provided. In this case,\nthe chosen window will be instantiated with the default parameters. Custom windows\nmust be provided as instance.\n- **normalize** (*bool*)  If <cite>True</cite>, the filter is normalized to have unit power.\nDefaults to <cite>True</cite>.\n- **trainable** (*bool*)  If <cite>True</cite>, the filter coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n- **x** (*[, N], tf.complex or tf.float*)  The input to which the filter is applied.\nThe filter is applied along the last dimension.\n- **padding** (*string ([full, valid, same])*)  Padding mode for convolving `x` and the filter.\nMust be one of full, valid, or same.\nDefaults to full.\n- **conjugate** (*bool*)  If <cite>True</cite>, the complex conjugate of the filter is applied.\nDefaults to <cite>False</cite>.\n\n\nOutput\n\n**y** (*[,M], tf.complex or tf.float*)  Filtered input.\nIt is <cite>tf.float</cite> only if both `x` and the filter are <cite>tf.float</cite>.\nIt is <cite>tf.complex</cite> otherwise.\nThe length M depends on the `padding`.\n\n\n`property` `aclr`\n\nACLR of the filter\n\nThis ACLR corresponds to what one would obtain from using\nthis filter as pulse shaping filter on an i.i.d. sequence of symbols.\nThe in-band is assumed to range from [-0.5, 0.5] in normalized\nfrequency.\n\n\n`property` `beta`\n\nRoll-off factor\n\n\n`property` `coefficients`\n\nThe filter coefficients (after normalization)\n\n\n`property` `length`\n\nThe filter length in samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the filter is normalized to have unit power. <cite>False</cite> otherwise.\n\n\n`property` `sampling_times`\n\nSampling times in multiples of the symbol duration\n\n\n`show`(*`response``=``'impulse'`*, *`scale``=``'lin'`*)\n\nPlot the impulse or magnitude response\n\nPlots the impulse response (time domain) or magnitude response\n(frequency domain) of the filter.\n\nFor the computation of the magnitude response, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe filter coefficients in the time domain.\nInput\n\n- **response** (*str, one of [impulse, magnitude]*)  The desired response type.\nDefaults to impulse\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude response.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the filter coefficients are trainable. <cite>False</cite> otherwise.\n\n\n`property` `window`\n\nThe window function that is applied to the filter coefficients. <cite>None</cite> if no window is applied."
"### RootRaisedCosineFilter\n\n`class` `sionna.signal.``RootRaisedCosineFilter`(*`span_in_symbols`*, *`samples_per_symbol`*, *`beta`*, *`window``=``None`*, *`normalize``=``True`*, *`trainable``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/filter.html#RootRaisedCosineFilter)\n\nLayer for applying a root-raised-cosine filter of `length` K\nto an input `x` of length N.\n\nThe root-raised-cosine filter is defined by\n\n$$\n\\begin{split}h(t) =\n\\begin{cases}\n\\frac{1}{T} \\left(1 + \\beta\\left(\\frac{4}{\\pi}-1\\right) \\right), & \\text { if }t = 0\\\\\n\\frac{\\beta}{T\\sqrt{2}} \\left[ \\left(1+\\frac{2}{\\pi}\\right)\\sin\\left(\\frac{\\pi}{4\\beta}\\right) + \\left(1-\\frac{2}{\\pi}\\right)\\cos\\left(\\frac{\\pi}{4\\beta}\\right) \\right], & \\text { if }t = \\pm\\frac{T}{4\\beta} \\\\\n\\frac{1}{T} \\frac{\\sin\\left(\\pi\\frac{t}{T}(1-\\beta)\\right) + 4\\beta\\frac{t}{T}\\cos\\left(\\pi\\frac{t}{T}(1+\\beta)\\right)}{\\pi\\frac{t}{T}\\left(1-\\left(4\\beta\\frac{t}{T}\\right)^2\\right)}, & \\text { otherwise}\n\\end{cases}\\end{split}\n$$\n\nwhere $\\beta$ is the roll-off factor and $T$ the symbol duration.\n\nThe filter length K is equal to the filter span in symbols (`span_in_symbols`)\nmultiplied by the oversampling factor (`samples_per_symbol`).\nIf this product is even, a value of one will be added.\n\nThe filter is applied through discrete convolution.\n\nAn optional windowing function `window` can be applied to the filter.\n\nThe <cite>dtype</cite> of the output is <cite>tf.float</cite> if both `x` and the filter coefficients have dtype <cite>tf.float</cite>.\nOtherwise, the dtype of the output is <cite>tf.complex</cite>.\n\nThree padding modes are available for applying the filter:\n\n- full (default): Returns the convolution at each point of overlap between `x` and the filter.\nThe length of the output is N + K - 1. Zero-padding of the input `x` is performed to\ncompute the convolution at the borders.\n- same: Returns an output of the same length as the input `x`. The convolution is computed such\nthat the coefficients of the input `x` are centered on the coefficient of the filter with index\n(K-1)/2. Zero-padding of the input signal is performed to compute the convolution at the borders.\n- valid: Returns the convolution only at points where `x` and the filter completely overlap.\nThe length of the output is N - K + 1.\n\nParameters\n\n- **span_in_symbols** (*int*)  Filter span as measured by the number of symbols.\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **beta** (*float*)  Roll-off factor.\nMust be in the range $[0,1]$.\n- **window** (* or **string** (**[**\"hann\"**, **\"hamming\"**, **\"blackman\"**]**)*)  Instance of [`Window`](https://nvlabs.github.io/sionna/api/signal.html#sionna.signal.Window) that is applied to the filter coefficients.\nAlternatively, a string indicating the window name can be provided. In this case,\nthe chosen window will be instantiated with the default parameters. Custom windows\nmust be provided as instance.\n- **normalize** (*bool*)  If <cite>True</cite>, the filter is normalized to have unit power.\nDefaults to <cite>True</cite>.\n- **trainable** (*bool*)  If <cite>True</cite>, the filter coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n- **x** (*[, N], tf.complex or tf.float*)  The input to which the filter is applied.\nThe filter is applied along the last dimension.\n- **padding** (*string ([full, valid, same])*)  Padding mode for convolving `x` and the filter.\nMust be one of full, valid, or same. Case insensitive.\nDefaults to full.\n- **conjugate** (*bool*)  If <cite>True</cite>, the complex conjugate of the filter is applied.\nDefaults to <cite>False</cite>.\n\n\nOutput\n\n**y** (*[,M], tf.complex or tf.float*)  Filtered input.\nIt is <cite>tf.float</cite> only if both `x` and the filter are <cite>tf.float</cite>.\nIt is <cite>tf.complex</cite> otherwise.\nThe length M depends on the `padding`.\n\n\n`property` `aclr`\n\nACLR of the filter\n\nThis ACLR corresponds to what one would obtain from using\nthis filter as pulse shaping filter on an i.i.d. sequence of symbols.\nThe in-band is assumed to range from [-0.5, 0.5] in normalized\nfrequency.\n\n\n`property` `beta`\n\nRoll-off factor\n\n\n`property` `coefficients`\n\nThe filter coefficients (after normalization)\n\n\n`property` `length`\n\nThe filter length in samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the filter is normalized to have unit power. <cite>False</cite> otherwise.\n\n\n`property` `sampling_times`\n\nSampling times in multiples of the symbol duration\n\n\n`show`(*`response``=``'impulse'`*, *`scale``=``'lin'`*)\n\nPlot the impulse or magnitude response\n\nPlots the impulse response (time domain) or magnitude response\n(frequency domain) of the filter.\n\nFor the computation of the magnitude response, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe filter coefficients in the time domain.\nInput\n\n- **response** (*str, one of [impulse, magnitude]*)  The desired response type.\nDefaults to impulse\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude response.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the filter coefficients are trainable. <cite>False</cite> otherwise.\n\n\n`property` `window`\n\nThe window function that is applied to the filter coefficients. <cite>None</cite> if no window is applied."
"### CustomFilter\n\n`class` `sionna.signal.``CustomFilter`(*`span_in_symbols``=``None`*, *`samples_per_symbol``=``None`*, *`coefficients``=``None`*, *`window``=``None`*, *`normalize``=``True`*, *`trainable``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/filter.html#CustomFilter)\n\nLayer for applying a custom filter of `length` K\nto an input `x` of length N.\n\nThe filter length K is equal to the filter span in symbols (`span_in_symbols`)\nmultiplied by the oversampling factor (`samples_per_symbol`).\nIf this product is even, a value of one will be added.\n\nThe filter is applied through discrete convolution.\n\nAn optional windowing function `window` can be applied to the filter.\n\nThe <cite>dtype</cite> of the output is <cite>tf.float</cite> if both `x` and the filter coefficients have dtype <cite>tf.float</cite>.\nOtherwise, the dtype of the output is <cite>tf.complex</cite>.\n\nThree padding modes are available for applying the filter:\n\n- full (default): Returns the convolution at each point of overlap between `x` and the filter.\nThe length of the output is N + K - 1. Zero-padding of the input `x` is performed to\ncompute the convolution at the borders.\n- same: Returns an output of the same length as the input `x`. The convolution is computed such\nthat the coefficients of the input `x` are centered on the coefficient of the filter with index\n(K-1)/2. Zero-padding of the input signal is performed to compute the convolution at the borders.\n- valid: Returns the convolution only at points where `x` and the filter completely overlap.\nThe length of the output is N - K + 1.\n\nParameters\n\n- **span_in_symbols** (*int*)  Filter span as measured by the number of symbols.\nOnly needs to be provided if `coefficients` is None.\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\nMust always be provided.\n- **coefficients** (*[**K**]**, **tf.float** or **tf.complex*)  Optional filter coefficients.\nIf set to <cite>None</cite>, then a random filter of K is generated\nby sampling a Gaussian distribution. Defaults to <cite>None</cite>.\n- **window** (* or **string** (**[**\"hann\"**, **\"hamming\"**, **\"blackman\"**]**)*)  Instance of [`Window`](https://nvlabs.github.io/sionna/api/signal.html#sionna.signal.Window) that is applied to the filter coefficients.\nAlternatively, a string indicating the window name can be provided. In this case,\nthe chosen window will be instantiated with the default parameters. Custom windows\nmust be provided as instance.\n- **normalize** (*bool*)  If <cite>True</cite>, the filter is normalized to have unit power.\nDefaults to <cite>True</cite>.\n- **trainable** (*bool*)  If <cite>True</cite>, the filter coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n- **x** (*[, N], tf.complex or tf.float*)  The input to which the filter is applied.\nThe filter is applied along the last dimension.\n- **padding** (*string ([full, valid, same])*)  Padding mode for convolving `x` and the filter.\nMust be one of full, valid, or same. Case insensitive.\nDefaults to full.\n- **conjugate** (*bool*)  If <cite>True</cite>, the complex conjugate of the filter is applied.\nDefaults to <cite>False</cite>.\n\n\nOutput\n\n**y** (*[,M], tf.complex or tf.float*)  Filtered input.\nIt is <cite>tf.float</cite> only if both `x` and the filter are <cite>tf.float</cite>.\nIt is <cite>tf.complex</cite> otherwise.\nThe length M depends on the `padding`.\n\n\n`property` `aclr`\n\nACLR of the filter\n\nThis ACLR corresponds to what one would obtain from using\nthis filter as pulse shaping filter on an i.i.d. sequence of symbols.\nThe in-band is assumed to range from [-0.5, 0.5] in normalized\nfrequency.\n\n\n`property` `coefficients`\n\nThe filter coefficients (after normalization)\n\n\n`property` `length`\n\nThe filter length in samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the filter is normalized to have unit power. <cite>False</cite> otherwise.\n\n\n`property` `sampling_times`\n\nSampling times in multiples of the symbol duration\n\n\n`show`(*`response``=``'impulse'`*, *`scale``=``'lin'`*)\n\nPlot the impulse or magnitude response\n\nPlots the impulse response (time domain) or magnitude response\n(frequency domain) of the filter.\n\nFor the computation of the magnitude response, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe filter coefficients in the time domain.\nInput\n\n- **response** (*str, one of [impulse, magnitude]*)  The desired response type.\nDefaults to impulse\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude response.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the filter coefficients are trainable. <cite>False</cite> otherwise.\n\n\n`property` `window`\n\nThe window function that is applied to the filter coefficients. <cite>None</cite> if no window is applied."
"### Filter\n\n`class` `sionna.signal.``Filter`(*`span_in_symbols`*, *`samples_per_symbol`*, *`window``=``None`*, *`normalize``=``True`*, *`trainable``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/filter.html#Filter)\n\nThis is an abtract class for defining a filter of `length` K which can be\napplied to an input `x` of length N.\n\nThe filter length K is equal to the filter span in symbols (`span_in_symbols`)\nmultiplied by the oversampling factor (`samples_per_symbol`).\nIf this product is even, a value of one will be added.\n\nThe filter is applied through discrete convolution.\n\nAn optional windowing function `window` can be applied to the filter.\n\nThe <cite>dtype</cite> of the output is <cite>tf.float</cite> if both `x` and the filter coefficients have dtype <cite>tf.float</cite>.\nOtherwise, the dtype of the output is <cite>tf.complex</cite>.\n\nThree padding modes are available for applying the filter:\n\n- full (default): Returns the convolution at each point of overlap between `x` and the filter.\nThe length of the output is N + K - 1. Zero-padding of the input `x` is performed to\ncompute the convolution at the borders.\n- same: Returns an output of the same length as the input `x`. The convolution is computed such\nthat the coefficients of the input `x` are centered on the coefficient of the filter with index\n(K-1)/2. Zero-padding of the input signal is performed to compute the convolution at the borders.\n- valid: Returns the convolution only at points where `x` and the filter completely overlap.\nThe length of the output is N - K + 1.\n\nParameters\n\n- **span_in_symbols** (*int*)  Filter span as measured by the number of symbols.\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **window** (* or **string** (**[**\"hann\"**, **\"hamming\"**, **\"blackman\"**]**)*)  Instance of [`Window`](https://nvlabs.github.io/sionna/api/signal.html#sionna.signal.Window) that is applied to the filter coefficients.\nAlternatively, a string indicating the window name can be provided. In this case,\nthe chosen window will be instantiated with the default parameters. Custom windows\nmust be provided as instance.\n- **normalize** (*bool*)  If <cite>True</cite>, the filter is normalized to have unit power.\nDefaults to <cite>True</cite>.\n- **trainable** (*bool*)  If <cite>True</cite>, the filter coefficients are trainable.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n- **x** (*[, N], tf.complex or tf.float*)  The input to which the filter is applied.\nThe filter is applied along the last dimension.\n- **padding** (*string ([full, valid, same])*)  Padding mode for convolving `x` and the filter.\nMust be one of full, valid, or same. Case insensitive.\nDefaults to full.\n- **conjugate** (*bool*)  If <cite>True</cite>, the complex conjugate of the filter is applied.\nDefaults to <cite>False</cite>.\n\n\nOutput\n\n**y** (*[,M], tf.complex or tf.float*)  Filtered input.\nIt is <cite>tf.float</cite> only if both `x` and the filter are <cite>tf.float</cite>.\nIt is <cite>tf.complex</cite> otherwise.\nThe length M depends on the `padding`.\n\n\n`property` `aclr`\n\nACLR of the filter\n\nThis ACLR corresponds to what one would obtain from using\nthis filter as pulse shaping filter on an i.i.d. sequence of symbols.\nThe in-band is assumed to range from [-0.5, 0.5] in normalized\nfrequency.\n\n\n`property` `coefficients`\n\nThe filter coefficients (after normalization)\n\n\n`property` `length`\n\nThe filter length in samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the filter is normalized to have unit power. <cite>False</cite> otherwise.\n\n\n`property` `sampling_times`\n\nSampling times in multiples of the symbol duration\n\n\n`show`(*`response``=``'impulse'`*, *`scale``=``'lin'`*)[`[source]`](../_modules/sionna/signal/filter.html#Filter.show)\n\nPlot the impulse or magnitude response\n\nPlots the impulse response (time domain) or magnitude response\n(frequency domain) of the filter.\n\nFor the computation of the magnitude response, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe filter coefficients in the time domain.\nInput\n\n- **response** (*str, one of [impulse, magnitude]*)  The desired response type.\nDefaults to impulse\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude response.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the filter coefficients are trainable. <cite>False</cite> otherwise.\n\n\n`property` `window`\n\nThe window function that is applied to the filter coefficients. <cite>None</cite> if no window is applied."
"### HannWindow\n\n`class` `sionna.signal.``HannWindow`(*`length`*, *`trainable``=``False`*, *`normalize``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/window.html#HannWindow)\n\nLayer for applying a Hann window function of length `length` to an input `x` of the same length.\n\nThe window function is applied through element-wise multiplication.\n\nThe window function is real-valued, i.e., has <cite>tf.float</cite> as <cite>dtype</cite>.\nThe <cite>dtype</cite> of the output is the same as the <cite>dtype</cite> of the input `x` to which the window function is applied.\nThe window function and the input must have the same precision.\n\nThe Hann window is defined by\n\n$$\nw_n = \\sin^2 \\left( \\frac{\\pi n}{N} \\right), 0 \\leq n \\leq N-1\n$$\n\nwhere $N$ is the window length.\nParameters\n\n- **length** (*int*)  Window length (number of samples).\n- **trainable** (*bool*)  If <cite>True</cite>, the window coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **normalize** (*bool*)  If <cite>True</cite>, the window is normalized to have unit average power\nper coefficient.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nMust be either <cite>tf.float32</cite> or <cite>tf.float64</cite>.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n**x** (*[, N], tf.complex or tf.float*)  The input to which the window function is applied.\nThe window function is applied along the last dimension.\nThe length of the last dimension `N` must be the same as the `length` of the window function.\n\nOutput\n\n**y** (*[,N], tf.complex or tf.float*)  Output of the windowing operation.\nThe output has the same shape and <cite>dtype</cite> as the input `x`.\n\n\n`property` `coefficients`\n\nThe window coefficients (after normalization)\n\n\n`property` `length`\n\nWindow length in number of samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the window is normalized to have unit average power per coefficient. <cite>False</cite>\notherwise.\n\n\n`show`(*`samples_per_symbol`*, *`domain``=``'time'`*, *`scale``=``'lin'`*)\n\nPlot the window in time or frequency domain\n\nFor the computation of the Fourier transform, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe window coefficients in the time domain.\nInput\n\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **domain** (*str, one of [time, frequency]*)  The desired domain.\nDefaults to time\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude in the frequency domain.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the window coefficients are trainable. <cite>False</cite> otherwise."
"### HammingWindow\n\n`class` `sionna.signal.``HammingWindow`(*`length`*, *`trainable``=``False`*, *`normalize``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/window.html#HammingWindow)\n\nLayer for applying a Hamming window function of length `length` to an input `x` of the same length.\n\nThe window function is applied through element-wise multiplication.\n\nThe window function is real-valued, i.e., has <cite>tf.float</cite> as <cite>dtype</cite>.\nThe <cite>dtype</cite> of the output is the same as the <cite>dtype</cite> of the input `x` to which the window function is applied.\nThe window function and the input must have the same precision.\n\nThe Hamming window is defined by\n\n$$\nw_n = a_0 - (1-a_0) \\cos \\left( \\frac{2 \\pi n}{N} \\right), 0 \\leq n \\leq N-1\n$$\n\nwhere $N$ is the window length and $a_0 = \\frac{25}{46}$.\nParameters\n\n- **length** (*int*)  Window length (number of samples).\n- **trainable** (*bool*)  If <cite>True</cite>, the window coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **normalize** (*bool*)  If <cite>True</cite>, the window is normalized to have unit average power\nper coefficient.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nMust be either <cite>tf.float32</cite> or <cite>tf.float64</cite>.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n**x** (*[, N], tf.complex or tf.float*)  The input to which the window function is applied.\nThe window function is applied along the last dimension.\nThe length of the last dimension `N` must be the same as the `length` of the window function.\n\nOutput\n\n**y** (*[,N], tf.complex or tf.float*)  Output of the windowing operation.\nThe output has the same shape and <cite>dtype</cite> as the input `x`.\n\n\n`property` `coefficients`\n\nThe window coefficients (after normalization)\n\n\n`property` `length`\n\nWindow length in number of samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the window is normalized to have unit average power per coefficient. <cite>False</cite>\notherwise.\n\n\n`show`(*`samples_per_symbol`*, *`domain``=``'time'`*, *`scale``=``'lin'`*)\n\nPlot the window in time or frequency domain\n\nFor the computation of the Fourier transform, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe window coefficients in the time domain.\nInput\n\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **domain** (*str, one of [time, frequency]*)  The desired domain.\nDefaults to time\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude in the frequency domain.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the window coefficients are trainable. <cite>False</cite> otherwise."
"### BlackmanWindow\n\n`class` `sionna.signal.``BlackmanWindow`(*`length`*, *`trainable``=``False`*, *`normalize``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/window.html#BlackmanWindow)\n\nLayer for applying a Blackman window function of length `length` to an input `x` of the same length.\n\nThe window function is applied through element-wise multiplication.\n\nThe window function is real-valued, i.e., has <cite>tf.float</cite> as <cite>dtype</cite>.\nThe <cite>dtype</cite> of the output is the same as the <cite>dtype</cite> of the input `x` to which the window function is applied.\nThe window function and the input must have the same precision.\n\nThe Blackman window is defined by\n\n$$\nw_n = a_0 - a_1 \\cos \\left( \\frac{2 \\pi n}{N} \\right) + a_2 \\cos \\left( \\frac{4 \\pi n}{N} \\right), 0 \\leq n \\leq N-1\n$$\n\nwhere $N$ is the window length, $a_0 = \\frac{7938}{18608}$, $a_1 = \\frac{9240}{18608}$, and $a_2 = \\frac{1430}{18608}$.\nParameters\n\n- **length** (*int*)  Window length (number of samples).\n- **trainable** (*bool*)  If <cite>True</cite>, the window coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **normalize** (*bool*)  If <cite>True</cite>, the window is normalized to have unit average power\nper coefficient.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nMust be either <cite>tf.float32</cite> or <cite>tf.float64</cite>.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n**x** (*[, N], tf.complex or tf.float*)  The input to which the window function is applied.\nThe window function is applied along the last dimension.\nThe length of the last dimension `N` must be the same as the `length` of the window function.\n\nOutput\n\n**y** (*[,N], tf.complex or tf.float*)  Output of the windowing operation.\nThe output has the same shape and <cite>dtype</cite> as the input `x`.\n\n\n`property` `coefficients`\n\nThe window coefficients (after normalization)\n\n\n`property` `length`\n\nWindow length in number of samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the window is normalized to have unit average power per coefficient. <cite>False</cite>\notherwise.\n\n\n`show`(*`samples_per_symbol`*, *`domain``=``'time'`*, *`scale``=``'lin'`*)\n\nPlot the window in time or frequency domain\n\nFor the computation of the Fourier transform, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe window coefficients in the time domain.\nInput\n\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **domain** (*str, one of [time, frequency]*)  The desired domain.\nDefaults to time\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude in the frequency domain.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the window coefficients are trainable. <cite>False</cite> otherwise."
"### CustomWindow\n\n`class` `sionna.signal.``CustomWindow`(*`length`*, *`coefficients``=``None`*, *`trainable``=``False`*, *`normalize``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/window.html#CustomWindow)\n\nLayer for defining and applying a custom window function of length `length` to an input `x` of the same length.\n\nThe window function is applied through element-wise multiplication.\n\nThe window function is real-valued, i.e., has <cite>tf.float</cite> as <cite>dtype</cite>.\nThe <cite>dtype</cite> of the output is the same as the <cite>dtype</cite> of the input `x` to which the window function is applied.\nThe window function and the input must have the same precision.\n\nThe window coefficients can be set through the `coefficients` parameter.\nIf not provided, random window coefficients are generated by sampling a Gaussian distribution.\nParameters\n\n- **length** (*int*)  Window length (number of samples).\n- **coefficients** (*[**N**]**, **tf.float*)  Optional window coefficients.\nIf set to <cite>None</cite>, then a random window of length `length` is generated by sampling a Gaussian distribution.\nDefaults to <cite>None</cite>.\n- **trainable** (*bool*)  If <cite>True</cite>, the window coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **normalize** (*bool*)  If <cite>True</cite>, the window is normalized to have unit average power\nper coefficient.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nMust be either <cite>tf.float32</cite> or <cite>tf.float64</cite>.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n**x** (*[, N], tf.complex or tf.float*)  The input to which the window function is applied.\nThe window function is applied along the last dimension.\nThe length of the last dimension `N` must be the same as the `length` of the window function.\n\nOutput\n\n**y** (*[,N], tf.complex or tf.float*)  Output of the windowing operation.\nThe output has the same shape and <cite>dtype</cite> as the input `x`.\n\n\n`property` `coefficients`\n\nThe window coefficients (after normalization)\n\n\n`property` `length`\n\nWindow length in number of samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the window is normalized to have unit average power per coefficient. <cite>False</cite>\notherwise.\n\n\n`show`(*`samples_per_symbol`*, *`domain``=``'time'`*, *`scale``=``'lin'`*)\n\nPlot the window in time or frequency domain\n\nFor the computation of the Fourier transform, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe window coefficients in the time domain.\nInput\n\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **domain** (*str, one of [time, frequency]*)  The desired domain.\nDefaults to time\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude in the frequency domain.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the window coefficients are trainable. <cite>False</cite> otherwise."
"### Window\n\n`class` `sionna.signal.``Window`(*`length`*, *`trainable``=``False`*, *`normalize``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/window.html#Window)\n\nThis is an abtract class for defining and applying a window function of length `length` to an input `x` of the same length.\n\nThe window function is applied through element-wise multiplication.\n\nThe window function is real-valued, i.e., has <cite>tf.float</cite> as <cite>dtype</cite>.\nThe <cite>dtype</cite> of the output is the same as the <cite>dtype</cite> of the input `x` to which the window function is applied.\nThe window function and the input must have the same precision.\nParameters\n\n- **length** (*int*)  Window length (number of samples).\n- **trainable** (*bool*)  If <cite>True</cite>, the window coefficients are trainable variables.\nDefaults to <cite>False</cite>.\n- **normalize** (*bool*)  If <cite>True</cite>, the window is normalized to have unit average power\nper coefficient.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  The <cite>dtype</cite> of the filter coefficients.\nMust be either <cite>tf.float32</cite> or <cite>tf.float64</cite>.\nDefaults to <cite>tf.float32</cite>.\n\n\nInput\n\n**x** (*[, N], tf.complex or tf.float*)  The input to which the window function is applied.\nThe window function is applied along the last dimension.\nThe length of the last dimension `N` must be the same as the `length` of the window function.\n\nOutput\n\n**y** (*[,N], tf.complex or tf.float*)  Output of the windowing operation.\nThe output has the same shape and <cite>dtype</cite> as the input `x`.\n\n\n`property` `coefficients`\n\nThe window coefficients (after normalization)\n\n\n`property` `length`\n\nWindow length in number of samples\n\n\n`property` `normalize`\n\n<cite>True</cite> if the window is normalized to have unit average power per coefficient. <cite>False</cite>\notherwise.\n\n\n`show`(*`samples_per_symbol`*, *`domain``=``'time'`*, *`scale``=``'lin'`*)[`[source]`](../_modules/sionna/signal/window.html#Window.show)\n\nPlot the window in time or frequency domain\n\nFor the computation of the Fourier transform, a minimum DFT size\nof 1024 is assumed which is obtained through zero padding of\nthe window coefficients in the time domain.\nInput\n\n- **samples_per_symbol** (*int*)  Number of samples per symbol, i.e., the oversampling factor.\n- **domain** (*str, one of [time, frequency]*)  The desired domain.\nDefaults to time\n- **scale** (*str, one of [lin, db]*)  The y-scale of the magnitude in the frequency domain.\nCan be lin (i.e., linear) or db (, i.e., Decibel).\nDefaults to lin.\n\n\n`property` `trainable`\n\n<cite>True</cite> if the window coefficients are trainable. <cite>False</cite> otherwise."
"### convolve\n\n`sionna.signal.``convolve`(*`inp`*, *`ker`*, *`padding``=``'full'`*, *`axis``=``-` `1`*)[`[source]`](../_modules/sionna/signal/utils.html#convolve)\n\nFilters an input `inp` of length <cite>N</cite> by convolving it with a kernel `ker` of length <cite>K</cite>.\n\nThe length of the kernel `ker` must not be greater than the one of the input sequence `inp`.\n\nThe <cite>dtype</cite> of the output is <cite>tf.float</cite> only if both `inp` and `ker` are <cite>tf.float</cite>. It is <cite>tf.complex</cite> otherwise.\n`inp` and `ker` must have the same precision.\n\nThree padding modes are available:\n\n- full (default): Returns the convolution at each point of overlap between `ker` and `inp`.\nThe length of the output is <cite>N + K - 1</cite>. Zero-padding of the input `inp` is performed to\ncompute the convolution at the border points.\n- same: Returns an output of the same length as the input `inp`. The convolution is computed such\nthat the coefficients of the input `inp` are centered on the coefficient of the kernel `ker` with index\n`(K-1)/2` for kernels of odd length, and `K/2` `-` `1` for kernels of even length.\nZero-padding of the input signal is performed to compute the convolution at the border points.\n- valid: Returns the convolution only at points where `inp` and `ker` completely overlap.\nThe length of the output is <cite>N - K + 1</cite>.\n\nInput\n\n- **inp** (*[,N], tf.complex or tf.real*)  Input to filter.\n- **ker** (*[K], tf.complex or tf.real*)  Kernel of the convolution.\n- **padding** (*string*)  Padding mode. Must be one of full, valid, or same. Case insensitive.\nDefaults to full.\n- **axis** (*int*)  Axis along which to perform the convolution.\nDefaults to <cite>-1</cite>.\n\n\nOutput\n\n**out** (*[,M], tf.complex or tf.float*)  Convolution output.\nIt is <cite>tf.float</cite> only if both `inp` and `ker` are <cite>tf.float</cite>. It is <cite>tf.complex</cite> otherwise.\nThe length <cite>M</cite> of the output depends on the `padding`."
"### fft\n\n`sionna.signal.``fft`(*`tensor`*, *`axis``=``-` `1`*)[`[source]`](../_modules/sionna/signal/utils.html#fft)\n\nComputes the normalized DFT along a specified axis.\n\nThis operation computes the normalized one-dimensional discrete Fourier\ntransform (DFT) along the `axis` dimension of a `tensor`.\nFor a vector $\\mathbf{x}\\in\\mathbb{C}^N$, the DFT\n$\\mathbf{X}\\in\\mathbb{C}^N$ is computed as\n\n$$\nX_m = \\frac{1}{\\sqrt{N}}\\sum_{n=0}^{N-1} x_n \\exp \\left\\{\n    -j2\\pi\\frac{mn}{N}\\right\\},\\quad m=0,\\dots,N-1.\n$$\n\nInput\n\n- **tensor** (*tf.complex*)  Tensor of arbitrary shape.\n- **axis** (*int*)  Indicates the dimension along which the DFT is taken.\n\n\nOutput\n\n*tf.complex*  Tensor of the same dtype and shape as `tensor`."
"### ifft\n\n`sionna.signal.``ifft`(*`tensor`*, *`axis``=``-` `1`*)[`[source]`](../_modules/sionna/signal/utils.html#ifft)\n\nComputes the normalized IDFT along a specified axis.\n\nThis operation computes the normalized one-dimensional discrete inverse\nFourier transform (IDFT) along the `axis` dimension of a `tensor`.\nFor a vector $\\mathbf{X}\\in\\mathbb{C}^N$, the IDFT\n$\\mathbf{x}\\in\\mathbb{C}^N$ is computed as\n\n$$\nx_n = \\frac{1}{\\sqrt{N}}\\sum_{m=0}^{N-1} X_m \\exp \\left\\{\n    j2\\pi\\frac{mn}{N}\\right\\},\\quad n=0,\\dots,N-1.\n$$\n\nInput\n\n- **tensor** (*tf.complex*)  Tensor of arbitrary shape.\n- **axis** (*int*)  Indicates the dimension along which the IDFT is taken.\n\n\nOutput\n\n*tf.complex*  Tensor of the same dtype and shape as `tensor`."
"### Upsampling\n\n`class` `sionna.signal.``Upsampling`(*`samples_per_symbol`*, *`axis``=``-` `1`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/upsampling.html#Upsampling)\n\nUpsamples a tensor along a specified axis by inserting zeros\nbetween samples.\nParameters\n\n- **samples_per_symbol** (*int*)  The upsampling factor. If `samples_per_symbol` is equal to <cite>n</cite>,\nthen the upsampled axis will be <cite>n</cite>-times longer.\n- **axis** (*int*)  The dimension to be up-sampled. Must not be the first dimension.\n\n\nInput\n\n**x** (*[,n,], tf.DType*)  The tensor to be upsampled. <cite>n</cite> is the size of the <cite>axis</cite> dimension.\n\nOutput\n\n**y** ([,n*samples_per_symbol,], same dtype as `x`)  The upsampled tensor."
"### Downsampling\n\n`class` `sionna.signal.``Downsampling`(*`samples_per_symbol`*, *`offset``=``0`*, *`num_symbols``=``None`*, *`axis``=``-` `1`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/signal/downsampling.html#Downsampling)\n\nDownsamples a tensor along a specified axis by retaining one out of\n`samples_per_symbol` elements.\nParameters\n\n- **samples_per_symbol** (*int*)  The downsampling factor. If `samples_per_symbol` is equal to <cite>n</cite>, then the\ndownsampled axis will be <cite>n</cite>-times shorter.\n- **offset** (*int*)  Defines the index of the first element to be retained.\nDefaults to zero.\n- **num_symbols** (*int*)  Defines the total number of symbols to be retained after\ndownsampling.\nDefaults to None (i.e., the maximum possible number).\n- **axis** (*int*)  The dimension to be downsampled. Must not be the first dimension.\n\n\nInput\n\n**x** (*[,n,], tf.DType*)  The tensor to be downsampled. <cite>n</cite> is the size of the <cite>axis</cite> dimension.\n\nOutput\n\n**y** ([,k,], same dtype as `x`)  The downsampled tensor, where `k`\nis min((`n`-`offset`)//`samples_per_symbol`, `num_symbols`)."
"### empirical_psd\n\n`sionna.signal.``empirical_psd`(*`x`*, *`show``=``True`*, *`oversampling``=``1.0`*, *`ylim``=``(-` `30,` `3)`*)[`[source]`](../_modules/sionna/signal/utils.html#empirical_psd)\n\nComputes the empirical power spectral density.\n\nComputes the empirical power spectral density (PSD) of tensor `x`\nalong the last dimension by averaging over all other dimensions.\nNote that this function\nsimply returns the averaged absolute squared discrete Fourier\nspectrum of `x`.\nInput\n\n- **x** (*[,N], tf.complex*)  The signal of which to compute the PSD.\n- **show** (*bool*)  Indicates if a plot of the PSD should be generated.\nDefaults to True,\n- **oversampling** (*float*)  The oversampling factor. Defaults to 1.\n- **ylim** (*tuple of floats*)  The limits of the y axis. Defaults to [-30, 3].\nOnly relevant if `show` is True.\n\n\nOutput\n\n- **freqs** (*[N], float*)  The normalized frequencies at which the PSD was evaluated.\n- **psd** (*[N], float*)  The PSD."
"### empirical_aclr\n\n`sionna.signal.``empirical_aclr`(*`x`*, *`oversampling``=``1.0`*, *`f_min``=``-` `0.5`*, *`f_max``=``0.5`*)[`[source]`](../_modules/sionna/signal/utils.html#empirical_aclr)\n\nComputes the empirical ACLR.\n\nComputes the empirical adjacent channel leakgae ration (ACLR)\nof tensor `x` based on its empirical power spectral density (PSD)\nwhich is computed along the last dimension by averaging over\nall other dimensions.\n\nIt is assumed that the in-band ranges from [`f_min`, `f_max`] in\nnormalized frequency. The ACLR is then defined as\n\n$$\n\\text{ACLR} = \\frac{P_\\text{out}}{P_\\text{in}}\n$$\n\nwhere $P_\\text{in}$ and $P_\\text{out}$ are the in-band\nand out-of-band power, respectively.\nInput\n\n- **x** (*[,N],  complex*)  The signal for which to compute the ACLR.\n- **oversampling** (*float*)  The oversampling factor. Defaults to 1.\n- **f_min** (*float*)  The lower border of the in-band in normalized frequency.\nDefaults to -0.5.\n- **f_max** (*float*)  The upper border of the in-band in normalized frequency.\nDefaults to 0.5.\n\n\nOutput\n\n**aclr** (*float*)  The ACLR in linear scale."

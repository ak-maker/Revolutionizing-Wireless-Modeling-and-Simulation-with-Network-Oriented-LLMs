"# Using the DeepMIMO Dataset with Sionna\n\nIn this example, you will learn how to use the ray-tracing based DeepMIMO dataset.\n\n[DeepMIMO](https://deepmimo.net/) is a generic dataset that enables a wide range of machine/deep learning applications for MIMO systems. It takes as input a set of parameters (such as antenna array configurations and time-domain/OFDM parameters) and generates MIMO channel realizations, corresponding locations, angles of arrival/departure, etc., based on these parameters and on a ray-tracing scenario selected [from those available in DeepMIMO](https://deepmimo.net/scenarios/)."
"## GPU Configuration and Imports\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Import Sionna\ntry:\n    import sionna\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna\n```\n\n```python\n# Configure the notebook to use only a single GPU and allocate only as much memory as needed\n# For more details, see https://www.tensorflow.org/guide/gpu\nimport tensorflow as tf\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\n```\n\n```python\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pickle\nimport time\nimport os\n# Load the required Sionna components\nfrom sionna.mimo import StreamManagement\nfrom sionna.ofdm import ResourceGrid, ResourceGridMapper, LSChannelEstimator, LMMSEEqualizer\nfrom sionna.ofdm import OFDMModulator, OFDMDemodulator, ZFPrecoder, RemoveNulledSubcarriers\nfrom sionna.channel.tr38901 import AntennaArray, CDL, Antenna\nfrom sionna.channel import subcarrier_frequencies, cir_to_ofdm_channel, cir_to_time_channel, time_lag_discrete_time_channel\nfrom sionna.channel import ApplyOFDMChannel, ApplyTimeChannel, OFDMChannel, TimeChannel\nfrom sionna.fec.ldpc.encoding import LDPC5GEncoder\nfrom sionna.fec.ldpc.decoding import LDPC5GDecoder\nfrom sionna.mapping import Mapper, Demapper\nfrom sionna.utils import BinarySource, ebnodb2no, sim_ber\nfrom sionna.utils.metrics import compute_ber\n```"
"## Configuration of DeepMIMO\n\nDeepMIMO provides multiple [scenarios](https://deepmimo.net/scenarios/) that one can select from. In this example, we use the O1 scenario with the carrier frequency set to 60 GHz (O1_60). To run this example, please download the O1_60 data files [from this page](https://deepmimo.net/scenarios/o1-scenario/). The downloaded zip file should be extracted into a folder, and the parameter `DeepMIMO_params['dataset_folder']` should be set to point to this folder, as done below.\n\nTo use DeepMIMO with Sionna, the DeepMIMO dataset first needs to be generated. The generated DeepMIMO dataset contains channels for different locations of the users and basestations. The layout of the O1 scenario is shown in the figure below.\n\n\nIn this example, we generate a dataset that consists of channels for the links from the basestation 6 to the users located on the rows 400 to 450. Each of these rows consists of 181 user locations, resulting in $51 \\times 181 = 9231$ basestation-user channels.\n\nThe antenna arrays in the DeepMIMO dataset are defined through the x-y-z axes. In the following example, a single-user MISO downlink is considered. The basestation is equipped with a uniform linear array of 16 elements spread along the x-axis. The users are each equipped with a single antenna. These parameters can be configured using the code below (for more information about the DeepMIMO parameters, please check [the DeepMIMO configurations](https://deepmimo.net/versions/v2-python/)).\n\n\n```python\n# Import DeepMIMO\ntry:\n    import DeepMIMO\nexcept ImportError as e:\n    # Install DeepMIMO if package is not already installed\n    import os\n    os.system(\"pip install DeepMIMO\")\n    import DeepMIMO\n# Channel generation\nDeepMIMO_params = DeepMIMO.default_params() # Load the default parameters\nDeepMIMO_params['dataset_folder'] = r'./scenarios' # Path to the downloaded scenarios\nDeepMIMO_params['scenario'] = 'O1_60' # DeepMIMO scenario\nDeepMIMO_params['num_paths'] = 10 # Maximum number of paths\nDeepMIMO_params['active_BS'] = np.array([6]) # Basestation indices to be included in the dataset\n# Selected rows of users, whose channels are to be generated.\nDeepMIMO_params['user_row_first'] = 400 # First user row to be included in the dataset\nDeepMIMO_params['user_row_last'] = 450 # Last user row to be included in the dataset\n# Configuration of the antenna arrays\nDeepMIMO_params['bs_antenna']['shape'] = np.array([16, 1, 1]) # BS antenna shape through [x, y, z] axes\nDeepMIMO_params['ue_antenna']['shape'] = np.array([1, 1, 1]) # UE antenna shape through [x, y, z] axes\n# The OFDM_channels parameter allows choosing between the generation of channel impulse\n# responses (if set to 0) or frequency domain channels (if set to 1).\n# It is set to 0 for this simulation, as the channel responses in frequency domain\n# will be generated using Sionna.\nDeepMIMO_params['OFDM_channels'] = 0\n# Generates a DeepMIMO dataset\nDeepMIMO_dataset = DeepMIMO.generate_data(DeepMIMO_params)\n```"
"```python\n\nBasestation 6\nUE-BS Channels\n```\n\n```python\nReading ray-tracing: 100%|| 81450/81450 [00:00<00:00, 129737.29it/s]\nGenerating channels: 100%|| 9231/9231 [00:00<00:00, 17426.44it/s]\n```\n\n```python\n\nBS-BS Channels\n```\n\n```python\nReading ray-tracing: 100%|| 6/6 [00:00<00:00, 33509.75it/s]\nGenerating channels: 100%|| 1/1 [00:00<00:00, 2589.08it/s]\n```"
"### Visualization of the dataset\n\nTo provide a better understanding of the user and basestation locations, we next visualize the locations of the users, highlighting the first active row of users (row 400), and basestation 6.\n\n\n```python\nplt.figure(figsize=(12,8))\n## User locations\nactive_bs_idx = 0 # Select the first active basestation in the dataset\nplt.scatter(DeepMIMO_dataset[active_bs_idx]['user']['location'][:, 1], # y-axis location of the users\n         DeepMIMO_dataset[active_bs_idx]['user']['location'][:, 0], # x-axis location of the users\n         s=1, marker='x', c='C0', label='The users located on the rows %i to %i (R%i to R%i)'%\n           (DeepMIMO_params['user_row_first'], DeepMIMO_params['user_row_last'],\n           DeepMIMO_params['user_row_first'], DeepMIMO_params['user_row_last']))\n# First 181 users correspond to the first row\nplt.scatter(DeepMIMO_dataset[active_bs_idx]['user']['location'][0:181, 1],\n         DeepMIMO_dataset[active_bs_idx]['user']['location'][0:181, 0],\n         s=1, marker='x', c='C1', label='First row of users (R%i)'% (DeepMIMO_params['user_row_first']))\n## Basestation location\nplt.scatter(DeepMIMO_dataset[active_bs_idx]['location'][1],\n         DeepMIMO_dataset[active_bs_idx]['location'][0],\n         s=50.0, marker='o', c='C2', label='Basestation')\nplt.gca().invert_xaxis() # Invert the x-axis to align the figure with the figure above\nplt.ylabel('x-axis')\nplt.xlabel('y-axis')\nplt.grid()\nplt.legend();\n```"
"## Using DeepMIMO with Sionna\n\nThe DeepMIMO Python package provides [a Sionna-compliant channel impulse response generator](https://nvlabs.github.io/sionna/examples/CIR_Dataset.html#Generators) that adapts the structure of the DeepMIMO dataset to be consistent with Sionna.\n\nAn adapter is instantiated for a given DeepMIMO dataset. In addition to the dataset, the adapter takes the indices of the basestations and users, to generate the channels between these basestations and users:\n\n`DeepMIMOSionnaAdapter(DeepMIMO_dataset,` `bs_idx,` `ue_idx)`\n\n**Note:** `bs_idx` and `ue_idx` set the links from which the channels are drawn. For instance, if `bs_idx` `=` `[0,` `1]` and `ue_idx` `=` `[2,` `3]`, the adapter then outputs the 4 channels formed by the combination of the first and second basestations with the third and fourth users.\n\nThe default behavior for `bs_idx` and `ue_idx` are defined as follows: - If value for `bs_idx` is not given, it will be set to `[0]` (i.e., the first basestation in the `DeepMIMO_dataset`). - If value for `ue_idx` is not given, then channels are provided for the links between the `bs_idx` and all users (i.e., `ue_idx=range(len(DeepMIMO_dataset[0]['user']['channel']))`. - If the both `bs_idx` and `ue_idx` are not given, the channels between the first basestation and all the\nusers are provided by the adapter. For this example, `DeepMIMOSionnaAdapter(DeepMIMO_dataset)` returns the channels from the basestation 6 and the 9231 available user locations.\n\n**Note:** The adapter assumes basestations are transmitters and users are receivers. Uplink channels can be obtained using (transpose) reciprocity."
"### Random Sampling of Multi-User Channels\n\nWhen considering multiple basestations, `bs_idx` can be set to a 2D numpy matrix of shape $($ # of samples $\\times$ # of basestations per sample $)$. In this case, for each sample of basestations, the `DeepMIMOSionnaAdapter` returns a set of $($ # of basestations per sample $\\times$ # of users $)$ channels, which can be provided as a multi-transmitter sample for the Sionna model. For example, `bs_idx` `=` `np.array([[0,` `1],` `[2,` `3],` `[4,` `5]])` provides three\nsets of $($ 2 basestations $\\times$ # of users $)$ channels. These three channel sets are from the basestation sets `[0,` `1]`, `[2,` `3]`, and `[4,` `5]`, respectively, to the users.\n\nTo use the adapter for multi-user channels, `ue_idx` can be set to a 2D numpy matrix of shape $($ # of samples $\\times$ # of users per sample $)$. In this case, for each sample of users, the `DeepMIMOSionnaAdapter` returns a set of $($ # of basestations $\\times$ # of users per sample $)$ channels, which can be provided as a multi-receiver sample for the Sionna model. For example, `ue_idx` `=` `np.array([[0,` `1` `,2],` `[4,` `5,` `6]])` provides two sets of $($"

"# Introduction to Sionna RT\n\nIn this notebook, you will\n\n- Discover the basic functionalities of Sionnas [ray tracing (RT) module](https://nvlabs.github.io/sionna/api/rt.html)\n- Learn how to compute coverage maps\n- Use ray-traced channels for link-level simulations instead of stochastic channel models"
"## GPU Configuration and Imports\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Colab does currently not support the latest version of ipython.\n# Thus, the preview does not work in Colab. However, whenever possible we\n# strongly recommend to use the scene preview mode.\ntry: # detect if the notebook runs in Colab\n    import google.colab\n    colab_compat = True # deactivate preview\nexcept:\n    colab_compat = False\nresolution = [480,320] # increase for higher quality of renderings\n# Allows to exit cell execution in Jupyter\nclass ExitCell(Exception):\n    def _render_traceback_(self):\n        pass\n# Import Sionna\ntry:\n    import sionna\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna\n# Configure the notebook to use only a single GPU and allocate only as much memory as needed\n# For more details, see https://www.tensorflow.org/guide/gpu\nimport tensorflow as tf\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\ntf.random.set_seed(1) # Set global random seed for reproducibility\n\n```\n\n```python\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport time\n# Import Sionna RT components\nfrom sionna.rt import load_scene, Transmitter, Receiver, PlanarArray, Camera\n# For link-level simulations\nfrom sionna.channel import cir_to_ofdm_channel, subcarrier_frequencies, OFDMChannel, ApplyOFDMChannel, CIRDataset\nfrom sionna.nr import PUSCHConfig, PUSCHTransmitter, PUSCHReceiver\nfrom sionna.utils import compute_ber, ebnodb2no, PlotBER\nfrom sionna.ofdm import KBestDetector, LinearDetector\nfrom sionna.mimo import StreamManagement\n\n```"
"## Background Information\n\nRay tracing is a technique to simulate environment-specific and physically accurate channel realizations for a given scene and user position. Please see the [EM Primer](https://nvlabs.github.io/sionna/em_primer.html) for further details on the theoretical background of ray tracing of wireless channels.\n\nSionna RT is a ray tracing extension for radio propagation modeling which is built on top of [Mitsuba 3](https://www.mitsuba-renderer.org/) and [TensorFlow](https://www.tensorflow.org/). Like all of Sionnas components, it is differentiable.\n\nMitsuba 3 is a rendering system for forward and inverse light-transport simulation that makes use of the differentiable just-in-time compiler [Dr.Jit](https://drjit.readthedocs.io/en/latest/). Sionna RT relies on Mitsuba 3 for the rendering and handling of scenes, e.g., its XML-file format, as well as the computation of ray intersections with scene primitives, i.e., triangles forming a mesh. The transformations of the polarized field components at each point of interaction between a ray and a\nscene object, e.g., reflection, are computed in TensorFlow, which is also used to combine the retained paths into (optionally) time-varying channel impulse responses. Thanks to TensorFlows automatic gradient computation, channel impulse responses and functions thereof are differentiable with respect to most parameters of the ray tracing process, including material properties (conductivity, permittivity), antenna patterns, orientations, and positions.\n\nScene files for Mitsuba 3 can be created, edited, and exported with the popular open-source 3D creation suite [Blender](https://www.blender.org/) and the [Mitsuba-Blender add-on](https://github.com/mitsuba-renderer/mitsuba-blender). One can rapdily create scenes from almost any place in the world using [OpenStreetMap](https://www.openstreetmap.org/) and the [Blender-OSM add-on](https://prochitecture.gumroad.com/l/blender-osm). In Sionna, scenes and radio propagation paths can be\neither rendered through the lens of configurable cameras via ray tracing or displayed with an integrated 3D viewer. For more detail on scene creation and rendering, we refer to [Sionnas API documentation](https://nvlabs.github.io/sionna/api/rt.html) and the available [video tutorial](https://youtu.be/7xHLDxUaQ7c)."
"## Loading Scenes\n\nThe Sionna RT module can either load external scene files (in Mitsubas XML file format) or it can load one of the [integrated scenes](https://nvlabs.github.io/sionna/api/rt.html#example-scenes).\n\nIn this example, we load an example scene containing the area around the Frauenkirche in Munich, Germany.\n\n\n```python\n# Load integrated scene\nscene = load_scene(sionna.rt.scene.munich) # Try also sionna.rt.scene.etoile\n\n```\n\n\nTo visualize the scene, we can use the `preview` function which opens an interactive preview of the scene. This only works in Jupyter notebooks.\n\nYou can use the following controls:\n\n- Mouse left: Rotate\n- Scroll wheel: Zoom\n- Mouse right: Move\n\n\nPlease note that the preview does not work in Colab and is therefore deactivated when `colab_compat` is set to True. Further, only one preview instance can be open at the same time.\n\n\n```python\n # Open 3D preview (only works in Jupyter notebook)\nif colab_compat:\n    scene.render(camera=\"scene-cam-0\", num_samples=512);\n    raise ExitCell\nscene.preview()\n\n```\n\n\nIt is often convenient to choose a viewpoint in the 3D preview prior to rendering it as a high-quality image. The next cell uses the preview camera which corresponds to the viewpoint of the current preview image.\n\n\n```python\n# The preview camera can be directly rendered as high-quality image\nif not colab_compat:\n    scene.render(camera=\"preview\", num_samples=512);\nelse:\n    print(\"Function not available in Colab mode.\")\n\n```\n\n\n```python\nFunction not available in Colab mode.\n```\n\n\nOne can also render the image to a file as shown below:\n\n\n```python\nrender_to_file = False # Set to True to render image to file\n# Render scene to file from preview viewpoint\nif render_to_file:\n    scene.render_to_file(camera=\"scene-cam-0\", # Also try camera=\"preview\"\n                         filename=\"scene.png\",\n                         resolution=[650,500])\n\n```\n\n\nInstead of the preview camera, one can also specify dedicated cameras with different positions and `look_at` directions.\n\n\n```python\n# Create new camera with different configuration\nmy_cam = Camera(\"my_cam\", position=[-250,250,150], look_at=[-15,30,28])\nscene.add(my_cam)\n# Render scene with new camera*\nscene.render(\"my_cam\", resolution=resolution, num_samples=512); # Increase num_samples to increase image quality\n\n```"
"Note that each [SceneObject](https://nvlabs.github.io/sionna/api/rt.html#scene-objects) (camera, transmitter,) needs a unique name. Thus, running the cells above multiple times will lead to an error if the object name is not changed or the object is not removed from the scene."
"## Ray Tracing for Radio Propagation\n\nWe need to configure transmitters and receivers prior to computing propagation paths between them. All transmitters and all receivers are equipped with the same antenna arrays which are defined by the `scene` properties `scene.tx_array` and `scene.rx_array`, respectively. Antenna arrays are composed of multiple identical antennas. Antennas can have custom or pre-defined patterns and are either single- or dual-polarized. One can add multiple transmitters and receivers to a scene which need\nto have unique names, a position, and orientation which is defined by yaw, pitch, and roll angles.\n\n\n```python\n# Configure antenna array for all transmitters\nscene.tx_array = PlanarArray(num_rows=1,\n                             num_cols=1,\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"tr38901\",\n                             polarization=\"V\")\n# Configure antenna array for all receivers\nscene.rx_array = PlanarArray(num_rows=1,\n                             num_cols=1,\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"dipole\",\n                             polarization=\"cross\")\n# Create transmitter\ntx = Transmitter(name=\"tx\",\n                 position=[8.5,21,27])\n# Add transmitter instance to scene\nscene.add(tx)\n# Create a receiver\nrx = Receiver(name=\"rx\",\n              position=[45,90,1.5],\n              orientation=[0,0,0])\n# Add receiver instance to scene\nscene.add(rx)\ntx.look_at(rx) # Transmitter points towards receiver\n\n```\n\n\nEach [SceneObject](https://nvlabs.github.io/sionna/api/rt.html#scene-objects) has an assigned [RadioMaterial](https://nvlabs.github.io/sionna/api/rt.html#radio-materials) that describes the electromagnetic properties of the object whenever it interacts with a ray. This behavior can be frequency-dependent and the ray tracing is done for a specific frequency.\n\nWe now set the carrier frequency of the scene and implicitly update all RadioMaterials.\n\n\n```python\nscene.frequency = 2.14e9 # in Hz; implicitly updates RadioMaterials\nscene.synthetic_array = True # If set to False, ray tracing will be done per antenna element (slower for large arrays)\n\n```\n\n\nThe default scenes have RadioMaterials assigned to each scene object. However, the RadioMaterial of a specific object can be modified and customized by the user."
"```python\n# Select an example object from the scene\nso = scene.get(\"Altes_Rathaus-itu_marble\")\n# Print name of assigned radio material for different frequenies\nfor f in [3.5e9, 2.14e9]: # Print for differrent frequencies\n    scene.frequency = f\n    print(f\"\\nRadioMaterial: {so.radio_material.name} @ {scene.frequency/1e9:.2f}GHz\")\n    print(\"Conductivity:\", so.radio_material.conductivity.numpy())\n    print(\"Relative permittivity:\", so.radio_material.relative_permittivity.numpy())\n    print(\"Complex relative permittivity:\", so.radio_material.complex_relative_permittivity.numpy())\n    print(\"Relative permeability:\", so.radio_material.relative_permeability.numpy())\n    print(\"Scattering coefficient:\", so.radio_material.scattering_coefficient.numpy())\n    print(\"XPD coefficient:\", so.radio_material.xpd_coefficient.numpy())\n\n```\n\n\n```python\n\nRadioMaterial: itu_marble @ 3.50GHz\nConductivity: 0.017550057\nRelative permittivity: 7.074\nComplex relative permittivity: (7.074-0.090132594j)\nRelative permeability: 1.0\nScattering coefficient: 0.0\nXPD coefficient: 0.0\nRadioMaterial: itu_marble @ 2.14GHz\nConductivity: 0.0111273555\nRelative permittivity: 7.074\nComplex relative permittivity: (7.074-0.09346512j)\nRelative permeability: 1.0\nScattering coefficient: 0.0\nXPD coefficient: 0.0\n```\n\n\nLet us run the ray tracing process and compute propagation paths between all transmitters and receivers. The parameter `max_depth` determines the maximum number of interactions between a ray and a scene objects. For example, with a `max_depth` of one, only LoS paths are considered. When the property `scene.synthetic_array` is set to `True`, antenna arrays are explicitly modeled by finding paths between any pair of transmitting and receiving antennas in the scene. Otherwise, arrays are\nrepresented by a single antenna located in the center of the array. Phase shifts related to the relative antenna positions will then be applied based on a plane-wave assumption when the channel impulse responses are computed.\n\n\n```python\n# Compute propagation paths\npaths = scene.compute_paths(max_depth=5,\n                            num_samples=1e6)  # Number of rays shot into directions defined\n                                              # by a Fibonacci sphere , too few rays can\n                                              # lead to missing paths\n# Visualize paths in the 3D preview\nif colab_compat:\n    scene.render(\"my_cam\", paths=paths, show_devices=True, show_paths=True, resolution=resolution);\n    raise ExitCell\nscene.preview(paths, show_devices=True, show_paths=True) # Use the mouse to focus on the visualized paths\n\n```"
"*Remark*: only one preview instance can be opened at the same time. Please check the previous preview if no output appears.\n\nThe [Paths](https://nvlabs.github.io/sionna/api/rt.html#paths) object contains all paths that have been found between transmitters and receivers. In principle, the existence of each path is determininistic for a given position and environment. Please note that due to the stochastic nature of the *shoot-and-bounce* algorithm, different runs of the `compute_paths` function can lead to different paths that are found. Most importantly, diffusely reflected or scattered paths are obtained through\nrandom sampling of directions after each interaction with a scene object. You can seet TensorFlows random seed to a specific value before executing `compute_paths` to ensure reproducibility.\n\nThe Paths object contains detailed information about every found path and allows us to generated channel impulse responses and apply Doppler shifts for the simulation of time evolution.\n\nLet us now inspect some of the available properties:\n\n\n```python\n# Show the coordinates of the starting points of all rays.\n# These coincide with the location of the transmitters.\nprint(\"Source coordinates: \", paths.sources.numpy())\nprint(\"Transmitter coordinates: \", list(scene.transmitters.values())[0].position.numpy())\n# Show the coordinates of the endpoints of all rays.\n# These coincide with the location of the receivers.\nprint(\"Target coordinates: \",paths.targets.numpy())\nprint(\"Receiver coordinates: \",list(scene.receivers.values())[0].position.numpy())\n# Show the types of all paths:\n# 0 - LoS, 1 - Reflected, 2 - Diffracted, 3 - Scattered\n# Note that Diffraction and scattering are turned off by default.\nprint(\"Path types: \", paths.types.numpy())\n\n```\n\n\n```python\nSource coordinates:  [[ 8.5 21.  27. ]]\nTransmitter coordinates:  [ 8.5 21.  27. ]\nTarget coordinates:  [[45.  90.   1.5]]\nReceiver coordinates:  [45.  90.   1.5]\nPath types:  [[0 1 1 1 1 1 1 1 1 1 1 1 1]]\n```\n\n\nWe can see from the list of path types, that there are 14 paths in total. One LoS and 13 reflected paths."
"```python\n# We can now access for every path the channel coefficient, the propagation delay,\n# as well as the angles of departure and arrival, respectively (zenith and azimuth).\n# Let us inspect a specific path in detail\npath_idx = 4 # Try out other values in the range [0, 13]\n# For a detailed overview of the dimensions of all properties, have a look at the API documentation\nprint(f\"\\n--- Detailed results for path {path_idx} ---\")\nprint(f\"Channel coefficient: {paths.a[0,0,0,0,0,path_idx, 0].numpy()}\")\nprint(f\"Propagation delay: {paths.tau[0,0,0,path_idx].numpy()*1e6:.5f} us\")\nprint(f\"Zenith angle of departure: {paths.theta_t[0,0,0,path_idx]:.4f} rad\")\nprint(f\"Azimuth angle of departure: {paths.phi_t[0,0,0,path_idx]:.4f} rad\")\nprint(f\"Zenith angle of arrival: {paths.theta_r[0,0,0,path_idx]:.4f} rad\")\nprint(f\"Azimuth angle of arrival: {paths.phi_r[0,0,0,path_idx]:.4f} rad\")\n\n```\n\n\n```python\n\n--- Detailed results for path 4 ---\nChannel coefficient: (4.429778527992312e-06+1.574603736287372e-08j)\nPropagation delay: 0.95107 us\nZenith angle of departure: 1.6485 rad\nAzimuth angle of departure: 0.9691 rad\nZenith angle of arrival: 1.6485 rad\nAzimuth angle of arrival: 0.1625 rad\n```"
"## From Paths to Channel Impulse Responses\n\nOnce paths are computed, they can be transformed into channel impulse responses (CIRs). The class method [apply_doppler](https://nvlabs.github.io/sionna/api/rt.html#Paths.apply_doppler) can simulate time evolution of the CIR based on arbitrary velocity vectors of all transmitters and receivers for a desired sampling frequency and number of time steps. The class method [cir](https://nvlabs.github.io/sionna/api/rt.html#Paths.cir) generates the channel impulse responses which can be used by\nother components for link-level simulations in either time or frequency domains. The method also allows you to only consider certain types of paths, e.g., line-of-sight, reflections, etc.\n\n\n```python\n# Default parameters in the PUSCHConfig\nsubcarrier_spacing = 15e3\nfft_size = 48\n\n```\n\n```python\n# Print shape of channel coefficients before the application of Doppler shifts\n# The last dimension corresponds to the number of time steps which defaults to one\n# as there is no mobility\nprint(\"Shape of `a` before applying Doppler shifts: \", paths.a.shape)\n# Apply Doppler shifts\npaths.apply_doppler(sampling_frequency=subcarrier_spacing, # Set to 15e3 Hz\n                    num_time_steps=14, # Number of OFDM symbols\n                    tx_velocities=[3.,0,0], # We can set additional tx speeds\n                    rx_velocities=[0,7.,0]) # Or rx speeds\nprint(\"Shape of `a` after applying Doppler shifts: \", paths.a.shape)\na, tau = paths.cir()\nprint(\"Shape of tau: \", tau.shape)\n\n```\n\n\n```python\nShape of `a` before applying Doppler shifts:  (1, 1, 2, 1, 1, 13, 1)\nShape of `a` after applying Doppler shifts:  (1, 1, 2, 1, 1, 13, 14)\nShape of tau:  (1, 1, 1, 13)\n```\n\n\nLet us have a look at the channel impulse response for the 14 incoming paths from the simulation above.\n\n\n```python\nt = tau[0,0,0,:]/1e-9 # Scale to ns\na_abs = np.abs(a)[0,0,0,0,0,:,0]\na_max = np.max(a_abs)\n# Add dummy entry at start/end for nicer figure\nt = np.concatenate([(0.,), t, (np.max(t)*1.1,)])\na_abs = np.concatenate([(np.nan,), a_abs, (np.nan,)])\n# And plot the CIR\nplt.figure()\nplt.title(\"Channel impulse response realization\")\nplt.stem(t, a_abs)\nplt.xlim([0, np.max(t)])\nplt.ylim([-2e-6, a_max*1.1])\nplt.xlabel(r\"$\\tau$ [ns]\")\nplt.ylabel(r\"$|a|$\");\n\n```"
"Note that the delay of the first arriving path is normalized to zero. This behavior can be changed using the Paths call property `normalize_delays`. For link-level simulations, it is recommended to work with normalized delays, unless perfect synchronization is explicitly desired.\n\n\n```python\n# Disable normalization of delays\npaths.normalize_delays = False\n# Get only the LoS path\n_, tau = paths.cir(los=True, reflection=False)\nprint(\"Delay of first path without normalization: \", np.squeeze(tau))\npaths.normalize_delays = True\n_, tau = paths.cir(los=True, reflection=False)\nprint(\"Delay of first path with normalization: \", np.squeeze(tau))\n\n```\n\n\n```python\nDelay of first path without normalization:  2.739189e-07\nDelay of first path with normalization:  0.0\n```\n\n\nThe CIRs can now be loaded either in the time-domain or frequency-domain channel models, respectively. Please see [cir_to_ofdm_channel](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.cir_to_ofdm_channel) and [cir_to_time_channel](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.cir_to_time_channel) for further details.\n\n\n```python\n# Compute frequencies of subcarriers and center around carrier frequency\nfrequencies = subcarrier_frequencies(fft_size, subcarrier_spacing)\n# Compute the frequency response of the channel at frequencies.\nh_freq = cir_to_ofdm_channel(frequencies,\n                             a,\n                             tau,\n                             normalize=True) # Non-normalized includes path-loss\n# Verify that the channel power is normalized\nh_avg_power = tf.reduce_mean(tf.abs(h_freq)**2).numpy()\nprint(\"Shape of h_freq: \", h_freq.shape)\nprint(\"Average power h_freq: \", h_avg_power) # Channel is normalized\n\n```\n\n\n```python\nShape of h_freq:  (1, 1, 2, 1, 1, 14, 48)\nAverage power h_freq:  1.0000001\n```\n\n\nThe frequency responses `h_freq` are now ready to be processed by the [ApplyOFDMChannel](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyOFDMChannel) Layer.\n\n\n```python\n# Placeholder for tx signal of shape\n# [batch size, num_tx, num_tx_ant, num_ofdm_symbols, fft_size]\nx = tf.zeros([h_freq.shape.as_list()[i] for i in [0,3,4,5,6]], tf.complex64)\nno = 0.1 # noise variance\n# Init channel layer\nchannel = ApplyOFDMChannel(add_awgn=True)\n# Apply channel\ny = channel([x, h_freq, no])\n# [batch size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size]\nprint(y.shape)\n\n```"
"## BER Evaluation\n\nWe now initialize a transmitter and receiver from the [5G NR PUSCH Tutorial](https://nvlabs.github.io/sionna/examples/5G_NR_PUSCH.html) notebook. These components could be replaced by your own transceiver implementations. Then we simulate PUSCH transmissions over the ray-traced CIRs that we generated in the previous cells.\n\n\n```python\n# Init pusch_transmitter\npusch_config = PUSCHConfig()\n# Instantiate a PUSCHTransmitter from the PUSCHConfig\npusch_transmitter = PUSCHTransmitter(pusch_config)\n# Create a PUSCHReceiver using the PUSCHTransmitter\npusch_receiver = PUSCHReceiver(pusch_transmitter)\n\n```\n\n```python\n# Simulate transmissions over the\nbatch_size = 100 # h_freq is broadcast, i.e., same CIR for all samples but different AWGN realizations\nebno_db = 2. # SNR in dB\nno = ebnodb2no(ebno_db,\n               pusch_transmitter._num_bits_per_symbol,\n               pusch_transmitter._target_coderate,\n               pusch_transmitter.resource_grid)\nx, b = pusch_transmitter(batch_size) # Generate transmit signal and info bits\ny = channel([x, h_freq, no]) # Simulate channel output\nb_hat = pusch_receiver([y, no]) # Recover the info bits\n# Compute BER\nprint(f\"BER: {compute_ber(b, b_hat).numpy():.5f}\")\n\n```\n\n\n```python\nBER: 0.07575\n```\n\n\n**Remark** Contrary to other Sionna components, ray tracing does not have a dedicated batch dimension. However, multiple transmitter and receivers can be simulated in parallel, which effectively equals a batch-dimension.\n\nNote that simulating multiple receivers in the ray tracer comes at little additional overhead. However, the complexity increases significantly for multiple transmitters as an individual ray tracing step is required for each transmitter. As the total number of rays is fixed, an increased number of transmitter requires also an increased number of rays in the `compute_paths` step for the same overall precision."
"## Runtime vs Depth\n\nWe will now investigate the complexity of the ray tracing algorithm for different values of `max_depth`, i.e., for a different number of bounces of the rays.\n\n\n```python\nmax_depths = 10 # evaluate performance up to 10 reflections\ndepths = range(1,max_depths+1)\nts = []\npl_avg = []\nfor d in depths:\n    # save start time\n    t = time.time()\n    # run the ray tracer\n    paths = scene.compute_paths(max_depth=d)\n    # and measure the required time interval\n    ts.append(time.time()-t)\n\n```\n\n```python\n# and plot results\nplt.figure()\nplt.plot(depths, ts, color=\"b\");\nplt.xlabel(\"Max. depth\")\nplt.ylabel(\"Runtime (s)\", color=\"b\")\nplt.grid(which=\"both\")\nplt.xlim([1, max_depths]);\n\n```\n\n\nAs can be seen, the computational complexity increases significantly with the number of ray interactions. Note that the code above does not account for scattering or diffraction. Adding these phenomea adds additional complexity as can be seen below:\n\n\n```python\nt = time.time()\npaths = scene.compute_paths(max_depth=3, diffraction=False)\nprint(\"Time without diffraction and scattering:\" , time.time()-t)\nt = time.time()\npaths = scene.compute_paths(max_depth=3, diffraction=True)\nprint(\"Time with diffraction:\" , time.time()-t)\nt = time.time()\npaths = scene.compute_paths(max_depth=3, scattering=True)\nprint(\"Time with scattering:\" , time.time()-t)\n\n```\n\n\n```python\nTime without diffraction and scattering: 2.456580400466919\nTime with diffraction: 2.614542245864868\nTime with scattering: 3.055100917816162\n```\n\n\nAlthough we have simulated scattering in the last example above, the scattered paths do not carry any energy as none of the materials in the scene has a positive scattering coefficient. You can learn more about scattering and diffraction in the dedicated [tutorial notebooks](https://nvlabs.github.io/sionna/tutorials.html#ray-tracing)."
"## Coverage Map\n\nSionna RT can be also used to simulate coverage maps for a given environment. We now put a new transmitter on top of the Frauenkirche and simulate a large-scale coverage map.\n\n\n```python\n# Remove old transmitter and add new one\nscene.remove(\"tx\")\ntx = Transmitter(name=\"tx\",\n                 position=[-210,73,105], # top of Frauenkirche\n                 orientation=[0,0,0])\nscene.add(tx)\n# We could have alternatively modified the properties position and orientation of the existing transmitter\n#scene.get(\"tx\").position = [-210,73,105]\n#scene.get(\"tx\").orientation = [0,0,0]\n\n```\n\n\nLets have a look at the new setup. The receiver can be ignored for the coverage map simulation.\n\n\n```python\n # Open 3D preview (only works in Jupyter notebook)\nif colab_compat:\n    scene.render(camera=\"scene-cam-0\", num_samples=512, resolution=resolution);\n    raise ExitCell\nscene.preview()\n\n```\n\n\n```python\ncm = scene.coverage_map(max_depth=5,\n                        diffraction=True, # Disable to see the effects of diffraction\n                        cm_cell_size=(5., 5.), # Grid size of coverage map cells in m\n                        combining_vec=None,\n                        precoding_vec=None,\n                        num_samples=int(20e6)) # Reduce if your hardware does not have enough memory\n\n```\n\n\nOnce simulated, the coverage map object can be directly visualized with the `preview` or `render` function.\n\n\n```python\n# Create new camera\ntx_pos = scene.transmitters[\"tx\"].position.numpy()\nbird_pos = tx_pos.copy()\nbird_pos[-1] = 1000 # Set height of coverage map to 1000m above tx\nbird_pos[-2]-= 0.01 # Slightly move the camera for correct orientation\n# Create new camera\nbird_cam = Camera(\"birds_view\", position=bird_pos, look_at=tx_pos)\nscene.add(bird_cam)\nif colab_compat:\n    scene.render(camera=\"birds_view\", coverage_map=cm, num_samples=512, resolution=resolution);\n    raise ExitCell\n# Open 3D preview (only works in Jupyter notebook)\nscene.preview(coverage_map=cm)\n\n```\n\n\nAlternatively, a 2D visualization of the coverage map can be shown.\n\n\n```python\ncm.show(tx=0); # If multiple transmitters exist, tx selects for which transmitter the cm is shown\n\n```"
"Note that it can happen in rare cases that diffracted rays arrive inside or behind buildings through paths which should not exists. This is not a bug in Sionnas ray tracing algorithm but rather an artefact of the way how scenes are created which can lead to the false detection of diffraction edges."
"## Site-specifc Link-Level Simulations\n\nWe will now use Sionna RT for site-specific link-level simulations. For this, we evaluate the BER performance for a MU-MIMO 5G NR system in the uplink direction based on ray traced CIRs for random user positions.\n\nWe use the 5G NR PUSCH transmitter and receiver from the [5G NR PUSCH Tutorial](https://nvlabs.github.io/sionna/examples/5G_NR_PUSCH.html) notebook. Note that also the systems from the [MIMO OFDM Transmissions over the CDL Channel Model](https://nvlabs.github.io/sionna/examples/MIMO_OFDM_Transmissions_over_CDL.html) or the [Neural Receiver for OFDM SIMO Systems](https://nvlabs.github.io/sionna/examples/Neural_Receiver.html) tutorials could be used instead.\n\nThere are different ways to implement uplink scenarios in Sionna RT. In this example, we configure the basestation as transmitter and the user equipments (UEs) as receivers which simplifies the ray tracing. Due to channel reciprocity, one can *reverse* the direction of the ray traced channels afterwards. For the ray tracer itself, the direction (uplink/downlink) does not change the simulated paths.\n\n*Note*: Running the cells below can take several hours of compute time.\n\n\n```python\n# System parameters\nsubcarrier_spacing = 30e3\nnum_time_steps = 14 # Total number of ofdm symbols per slot\nnum_tx = 4 # Number of users\nnum_rx = 1 # Only one receiver considered\nnum_tx_ant = 4 # Each user has 4 antennas\nnum_rx_ant = 16 # The receiver is equipped with 16 antennas\n# batch_size for CIR generation\nbatch_size_cir = 1000\n\n```\n\n\nLet us add a new transmitter that acts as basestation. We will later use channel reciprocity to simulate the uplink direction.\n\n\n```python\n# Remove old tx from scene\nscene.remove(\"tx\")\nscene.synthetic_array = True # Emulate multiple antennas to reduce ray tracing complexity\n# Transmitter (=basestation) has an antenna pattern from 3GPP 38.901\nscene.tx_array = PlanarArray(num_rows=1,\n                             num_cols=int(num_rx_ant/2), # We want to transmitter to be equiped with the 16 rx antennas\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"tr38901\",\n                             polarization=\"cross\")\n# Create transmitter\ntx = Transmitter(name=\"tx\",\n                 position=[8.5,21,27],\n                 look_at=[45,90,1.5]) # optional, defines view direction\nscene.add(tx)\n\n```"
"We now need to update the coverage map for the new transmitter.\n\n\n```python\nmax_depth = 5 # Defines max number of ray interactions\n# Update coverage_map\ncm = scene.coverage_map(max_depth=max_depth,\n                        diffraction=True,\n                        cm_cell_size=(1., 1.),\n                        combining_vec=None,\n                        precoding_vec=None,\n                        num_samples=int(10e6))\n\n```\n\n\nThe function `sample_positions` allows sampling of random user positions from a coverage map. It ensures that only positions are sampled that have a path gain of at least `min_gain_dB` dB and at most `max_gain_dB` dB, i.e., ignores positions without connection to the transmitter. Further, one can set the distance `min_dist` and `max_dist` to sample only points with a certain distance away from the transmitter.\n\n\n```python\nmin_gain_db = -130 # in dB; ignore any position with less than -130 dB path gain\nmax_gain_db = 0 # in dB; ignore strong paths\n# sample points in a 5-400m radius around the receiver\nmin_dist = 5 # in m\nmax_dist = 400 # in m\n#sample batch_size random user positions from coverage map\nue_pos = cm.sample_positions(batch_size=batch_size_cir,\n                             min_gain_db=min_gain_db,\n                             max_gain_db=max_gain_db,\n                             min_dist=min_dist,\n                             max_dist=max_dist)\n\n```\n\n\nWe now add new receivers (=UEs) at random position.\n\n*Remark*: This is an example for 5G NR PUSCH (uplink direction), we will reverse the direction of the channel for later BER simulations.\n\n\n```python\n# Remove old receivers from scene\nscene.remove(\"rx\")\nfor i in range(batch_size_cir):\n    scene.remove(f\"rx-{i}\")\n# Configure antenna array for all receivers (=UEs)\nscene.rx_array = PlanarArray(num_rows=1,\n                             num_cols=int(num_tx_ant/2), # Each receiver is equipped with 4 tx antennas (uplink)\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"iso\", # UE orientation is random\n                             polarization=\"cross\")\n# Create batch_size receivers\nfor i in range(batch_size_cir):\n    rx = Receiver(name=f\"rx-{i}\",\n                  position=ue_pos[i], # Random position sampled from coverage map\n                  )\n    scene.add(rx)\n# And visualize the scene\nif colab_compat:\n    scene.render(\"birds_view\", show_devices=True, resolution=resolution);\n    raise ExitCell\nscene.preview(show_devices=True, coverage_map=cm)\n\n```"
"Each dot represents a random receiver position drawn from the random sampling function of the coverage map. This allows to efficiently sample batches of random channel realizations even in complex scenarios.\n\nWe can now simulate the CIRs for many different random positions.\n\n*Remark*: Running the cells below can take some time depending on the requested number of CIRs.\n\n\n```python\ntarget_num_cirs = 5000 # Defines how many different CIRS are generated.\n# Remark: some path are removed if no path was found for this position\nmax_depth = 5\nmin_gain_db = -130 # in dB / ignore any position with less than -130 dB path gain\nmax_gain_db = 0 # in dB / ignore any position with more than 0 dB path gain\n# Sample points within a 10-400m radius around the transmitter\nmin_dist = 10 # in m\nmax_dist = 400 # in m\n# Placeholder to gather channel impulse reponses\na = None\ntau = None\n# Each simulation returns batch_size_cir results\nnum_runs = int(np.ceil(target_num_cirs/batch_size_cir))\nfor idx in range(num_runs):\n    print(f\"Progress: {idx+1}/{num_runs}\", end=\"\\r\")\n    # Sample random user positions\n    ue_pos = cm.sample_positions(\n                        batch_size=batch_size_cir,\n                        min_gain_db=min_gain_db,\n                        max_gain_db=max_gain_db,\n                        min_dist=min_dist,\n                        max_dist=max_dist)\n    # Update all receiver positions\n    for idx in range(batch_size_cir):\n        scene.receivers[f\"rx-{idx}\"].position = ue_pos[idx]\n    # Simulate CIR\n    paths = scene.compute_paths(\n                    max_depth=max_depth,\n                    diffraction=True,\n                    num_samples=1e6) # shared between all tx in a scene\n    # Transform paths into channel impulse responses\n    paths.reverse_direction = True # Convert to uplink direction\n    paths.apply_doppler(sampling_frequency=subcarrier_spacing,\n                        num_time_steps=14,\n                        tx_velocities=[0.,0.,0],\n                        rx_velocities=[3.,3.,0])\n    # We fix here the maximum number of paths to 75 which ensures\n    # that we can simply concatenate different channel impulse reponses\n    a_, tau_ = paths.cir(num_paths=75)\n    del paths # Free memory\n    if a is None:\n        a = a_.numpy()\n        tau = tau_.numpy()\n    else:\n        # Concatenate along the num_tx dimension\n        a = np.concatenate([a, a_], axis=3)\n        tau = np.concatenate([tau, tau_], axis=2)\ndel cm # Free memory\n# Exchange the num_tx and batchsize dimensions\na = np.transpose(a, [3, 1, 2, 0, 4, 5, 6])\ntau = np.transpose(tau, [2, 1, 0, 3])\n# Remove CIRs that have no active link (i.e., a is all-zero)\np_link = np.sum(np.abs(a)**2, axis=(1,2,3,4,5,6))\na = a[p_link>0.,...]\ntau = tau[p_link>0.,...]\nprint(\"Shape of a:\", a.shape)\nprint(\"Shape of tau: \", tau.shape)\n\n```"
"```python\nShape of a: (4858, 1, 16, 1, 4, 75, 14)\nShape of tau:  (4858, 1, 1, 75)\n```\n\n\nNote that transmitter and receiver have been reversed, i.e., the transmitter now denotes the UE (with 4 antennas each) and the receiver is the basestation (with 16 antennas).\n\n*Remark*: We have removed all positions where the resulting CIR was zero, i.e., no path between transmitter and receiver was found. This comes from the fact that the `sample_position` function samples from the quantized coverage map and randomizes the position within the cell. It can happen that for this random position no connection between transmitter and receiver can be found.\n\nLet us now initialize a `data_generator` that samples random UEs from the dataset and *yields* the previously simulated CIRs.\n\n\n```python\nclass CIRGenerator:\n    \"\"\"Creates a generator from a given dataset of channel impulse responses.\n    The generator samples ``num_tx`` different transmitters from the given path\n    coefficients `a` and path delays `tau` and stacks the CIRs into a single tensor.\n    Note that the generator internally samples ``num_tx`` random transmitters\n    from the dataset. For this, the inputs ``a`` and ``tau`` must be given for\n    a single transmitter (i.e., ``num_tx`` =1) which will then be stacked\n    internally.\n    Parameters\n    ----------\n    a : [batch size, num_rx, num_rx_ant, 1, num_tx_ant, num_paths, num_time_steps], complex\n        Path coefficients per transmitter.\n    tau : [batch size, num_rx, 1, num_paths], float\n        Path delays [s] per transmitter.\n    num_tx : int\n        Number of transmitters\n    Output\n    -------\n    a : [batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex\n        Path coefficients\n    tau : [batch size, num_rx, num_tx, num_paths], tf.float\n        Path delays [s]\n    \"\"\"\n    def __init__(self,\n                 a,\n                 tau,\n                 num_tx):\n        # Copy to tensorflow\n        self._a = tf.constant(a, tf.complex64)\n        self._tau = tf.constant(tau, tf.float32)\n        self._dataset_size = self._a.shape[0]\n        self._num_tx = num_tx\n    def __call__(self):\n        # Generator implements an infinite loop that yields new random samples\n        while True:\n            # Sample 4 random users and stack them together\n            idx,_,_ = tf.random.uniform_candidate_sampler(\n                            tf.expand_dims(tf.range(self._dataset_size, dtype=tf.int64), axis=0),\n                            num_true=self._dataset_size,\n                            num_sampled=self._num_tx,\n                            unique=True,\n                            range_max=self._dataset_size)\n            a = tf.gather(self._a, idx)\n            tau = tf.gather(self._tau, idx)\n            # Transpose to remove batch dimension\n            a = tf.transpose(a, (3,1,2,0,4,5,6))\n            tau = tf.transpose(tau, (2,1,0,3))\n            # And remove batch-dimension\n            a = tf.squeeze(a, axis=0)\n            tau = tf.squeeze(tau, axis=0)\n            yield a, tau\n\n```"
"We use Sionnas built-in [CIRDataset](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.CIRDataset) to initialize a channel model that can be directly used in Sionnas [OFDMChannel](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.OFDMChannel) layer.\n\n\n```python\nbatch_size = 20 # Must be the same for the BER simulations as CIRDataset returns fixed batch_size\n# Init CIR generator\ncir_generator = CIRGenerator(a,\n                             tau,\n                             num_tx)\n# Initialises a channel model that can be directly used by OFDMChannel layer\nchannel_model = CIRDataset(cir_generator,\n                           batch_size,\n                           num_rx,\n                           num_rx_ant,\n                           num_tx,\n                           num_tx_ant,\n                           75,\n                           num_time_steps)\n# Delete to free memory\ndel a, tau\n\n```\n\n```python\n# We need to enable sionna.config.xla_compat before we can use\n# tf.function with jit_compile=True.\n# See https://nvlabs.github.io/sionna/api/config.html#sionna.Config.xla_compat\nsionna.config.xla_compat=False # not supported in CIRDataset\nclass Model(tf.keras.Model):\n    \"\"\"Simulate PUSCH transmissions over a 3GPP 38.901 model.\n    This model runs BER simulations for a multi-user MIMO uplink channel\n    compliant with the 5G NR PUSCH specifications.\n    You can pick different scenarios, i.e., channel models, perfect or\n    estimated CSI, as well as different MIMO detectors (LMMSE or KBest).\n    Parameters\n    ----------\n    channel_model : :class:`~sionna.channel.ChannelModel` object\n        An instance of a :class:`~sionna.channel.ChannelModel` object, such as\n        :class:`~sionna.channel.RayleighBlockFading` or\n        :class:`~sionna.channel.tr38901.UMi` or\n        :class:`~sionna.channel.CIRDataset`.\n    perfect_csi : bool\n        Determines if perfect CSI is assumed or if the CSI is estimated\n    detector : str, one of [\"lmmse\", \"kbest\"]\n        MIMO detector to be used. Note that each detector has additional\n        parameters that can be configured in the source code of the _init_ call.\n    Input\n    -----\n    batch_size : int\n        Number of simultaneously simulated slots\n    ebno_db : float\n        Signal-to-noise-ratio\n    Output\n    ------\n    b : [batch_size, num_tx, tb_size], tf.float\n        Transmitted information bits\n    b_hat : [batch_size, num_tx, tb_size], tf.float\n        Decoded information bits\n    \"\"\"\n    def __init__(self,\n                 channel_model,\n                 perfect_csi, # bool\n                 detector,    # \"lmmse\", \"kbest\"\n                ):\n        super().__init__()\n        self._channel_model = channel_model\n        self._perfect_csi = perfect_csi\n        # System configuration\n        self._num_prb = 16\n        self._mcs_index = 14\n        self._num_layers = 1\n        self._mcs_table = 1\n        self._domain = \"freq\"\n        # Below parameters must equal the Path2CIR parameters\n        self._num_tx_ant = 4\n        self._num_tx = 4\n        self._subcarrier_spacing = 30e3 # must be the same as used for Path2CIR\n        # PUSCHConfig for the first transmitter\n        pusch_config = PUSCHConfig()\n        pusch_config.carrier.subcarrier_spacing = self._subcarrier_spacing/1000\n        pusch_config.carrier.n_size_grid = self._num_prb\n        pusch_config.num_antenna_ports = self._num_tx_ant\n        pusch_config.num_layers = self._num_layers\n        pusch_config.precoding = \"codebook\"\n        pusch_config.tpmi = 1\n        pusch_config.dmrs.dmrs_port_set = list(range(self._num_layers))\n        pusch_config.dmrs.config_type = 1\n        pusch_config.dmrs.length = 1\n        pusch_config.dmrs.additional_position = 1\n        pusch_config.dmrs.num_cdm_groups_without_data = 2\n        pusch_config.tb.mcs_index = self._mcs_index\n        pusch_config.tb.mcs_table = self._mcs_table\n        # Create PUSCHConfigs for the other transmitters by cloning of the first PUSCHConfig\n        # and modifying the used DMRS ports.\n        pusch_configs = [pusch_config]\n        for i in range(1, self._num_tx):\n            pc = pusch_config.clone()\n            pc.dmrs.dmrs_port_set = list(range(i*self._num_layers, (i+1)*self._num_layers))\n            pusch_configs.append(pc)\n        # Create PUSCHTransmitter\n        self._pusch_transmitter = PUSCHTransmitter(pusch_configs, output_domain=self._domain)\n        # Create PUSCHReceiver\n        rx_tx_association = np.ones([1, self._num_tx], bool)\n        stream_management = StreamManagement(rx_tx_association,\n                                             self._num_layers)\n        assert detector in[\"lmmse\", \"kbest\"], \"Unsupported MIMO detector\"\n        if detector==\"lmmse\":\n            detector = LinearDetector(equalizer=\"lmmse\",\n                                      output=\"bit\",\n                                      demapping_method=\"maxlog\",\n                                      resource_grid=self._pusch_transmitter.resource_grid,\n                                      stream_management=stream_management,\n                                      constellation_type=\"qam\",\n                                      num_bits_per_symbol=pusch_config.tb.num_bits_per_symbol)\n        elif detector==\"kbest\":\n            detector = KBestDetector(output=\"bit\",\n                                     num_streams=self._num_tx*self._num_layers,\n                                     k=64,\n                                     resource_grid=self._pusch_transmitter.resource_grid,\n                                     stream_management=stream_management,\n                                     constellation_type=\"qam\",\n                                     num_bits_per_symbol=pusch_config.tb.num_bits_per_symbol)\n        if self._perfect_csi:\n            self._pusch_receiver = PUSCHReceiver(self._pusch_transmitter,\n                                                 mimo_detector=detector,\n                                                 input_domain=self._domain,\n                                                 channel_estimator=\"perfect\")\n        else:\n            self._pusch_receiver = PUSCHReceiver(self._pusch_transmitter,\n                                                 mimo_detector=detector,\n                                                 input_domain=self._domain)\n\n        # Configure the actual channel\n        self._channel = OFDMChannel(\n                            self._channel_model,\n                            self._pusch_transmitter.resource_grid,\n                            normalize_channel=True,\n                            return_channel=True)\n    # XLA currently not supported by the CIRDataset function\n    @tf.function(jit_compile=False)\n    def call(self, batch_size, ebno_db):\n        x, b = self._pusch_transmitter(batch_size)\n        no = ebnodb2no(ebno_db,\n                       self._pusch_transmitter._num_bits_per_symbol,\n                       pusch_transmitter._target_coderate,\n                       pusch_transmitter.resource_grid)\n        y, h = self._channel([x, no])\n        if self._perfect_csi:\n            b_hat = self._pusch_receiver([y, h, no])\n        else:\n            b_hat = self._pusch_receiver([y, no])\n        return b, b_hat\n\n```"
"We now initialize the end-to-end model with the `CIRDataset`.\n\n\n```python\nebno_db = 10.\ne2e_model = Model(channel_model,\n                  perfect_csi=False, # bool\n                  detector=\"lmmse\")  # \"lmmse\", \"kbest\"\n# We can draw samples from the end-2-end link-level simulations\nb, b_hat = e2e_model(batch_size, ebno_db)\n\n```\n\n\nAnd lets run the final evaluation for different system configurations.\n\n\n```python\nebno_db = np.arange(-3, 18, 2) # sim SNR range\nber_plot = PlotBER(f\"Site-Specific MU-MIMO 5G NR PUSCH\")\nfor detector in [\"lmmse\", \"kbest\"]:\n    for perf_csi in [True, False]:\n        e2e_model = Model(channel_model,\n                          perfect_csi=perf_csi,\n                          detector=detector)\n        # define legend\n        csi = \"Perf. CSI\" if perf_csi else \"Imperf. CSI\"\n        det = \"K-Best\" if detector==\"kbest\" else \"LMMSE\"\n        l = det + \" \" + csi\n        ber_plot.simulate(\n                    e2e_model,\n                    ebno_dbs=ebno_db, # SNR to simulate\n                    legend=l, # legend string for plotting\n                    max_mc_iter=500,\n                    num_target_block_errors=2000,\n                    batch_size=batch_size, # batch-size per Monte Carlo run\n                    soft_estimates=False, # the model returns hard-estimates\n                    early_stop=True,\n                    show_fig=False,\n                    add_bler=True,\n                    forward_keyboard_interrupt=True);\n\n```\n\n\n```python\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -3.0 | 1.3426e-01 | 9.7500e-01 |     1394056 |    10383360 |         2028 |        2080 |        14.4 |reached target block errors\n     -1.0 | 6.0569e-02 | 5.4375e-01 |     1112682 |    18370560 |         2001 |        3680 |         8.0 |reached target block errors\n      1.0 | 3.0802e-02 | 2.6605e-01 |     1168609 |    37939200 |         2022 |        7600 |        16.3 |reached target block errors\n      3.0 | 1.8333e-02 | 1.4970e-01 |     1222718 |    66693120 |         2000 |       13360 |        28.5 |reached target block errors\n      5.0 | 9.8484e-03 | 8.5119e-02 |     1156321 |   117411840 |         2002 |       23520 |        50.2 |reached target block errors\n      7.0 | 5.7053e-03 | 4.9250e-02 |     1139238 |   199680000 |         1970 |       40000 |        85.2 |reached max iter\n      9.0 | 3.3868e-03 | 2.9075e-02 |      676280 |   199680000 |         1163 |       40000 |        85.3 |reached max iter\n     11.0 | 1.6629e-03 | 1.4825e-02 |      332046 |   199680000 |          593 |       40000 |        85.4 |reached max iter\n     13.0 | 1.0874e-03 | 9.6750e-03 |      217127 |   199680000 |          387 |       40000 |        85.2 |reached max iter\n     15.0 | 5.7423e-04 | 4.8000e-03 |      114662 |   199680000 |          192 |       40000 |        85.1 |reached max iter\n     17.0 | 4.3051e-04 | 3.1000e-03 |       85964 |   199680000 |          124 |       40000 |        85.2 |reached max iter\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -3.0 | 2.2992e-01 | 1.0000e+00 |     2295491 |     9984000 |         2000 |        2000 |        14.7 |reached target block errors\n     -1.0 | 1.8111e-01 | 9.9904e-01 |     1880529 |    10383360 |         2078 |        2080 |         4.5 |reached target block errors\n      1.0 | 1.2673e-01 | 9.6346e-01 |     1315935 |    10383360 |         2004 |        2080 |         4.5 |reached target block errors\n      3.0 | 6.2428e-02 | 5.0075e-01 |     1246554 |    19968000 |         2003 |        4000 |         8.7 |reached target block errors\n      5.0 | 3.8155e-02 | 2.9390e-01 |     1310429 |    34344960 |         2022 |        6880 |        14.9 |reached target block errors\n      7.0 | 2.3349e-02 | 1.7764e-01 |     1324110 |    56709120 |         2018 |       11360 |        24.6 |reached target block errors\n      9.0 | 1.4020e-02 | 1.0570e-01 |     1326994 |    94648320 |         2004 |       18960 |        40.9 |reached target block errors\n     11.0 | 8.1793e-03 | 6.2562e-02 |     1306587 |   159744000 |         2002 |       32000 |        69.1 |reached target block errors\n     13.0 | 5.3070e-03 | 4.2200e-02 |     1059697 |   199680000 |         1688 |       40000 |        86.3 |reached max iter\n     15.0 | 3.7709e-03 | 2.9325e-02 |      752975 |   199680000 |         1173 |       40000 |        86.5 |reached max iter\n     17.0 | 2.5822e-03 | 2.0975e-02 |      515618 |   199680000 |          839 |       40000 |        86.4 |reached max iter\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -3.0 | 1.4514e-01 | 9.9856e-01 |     1507056 |    10383360 |         2077 |        2080 |        32.2 |reached target block errors\n     -1.0 | 7.4307e-02 | 8.8664e-01 |      860583 |    11581440 |         2057 |        2320 |        23.0 |reached target block errors\n      1.0 | 3.3615e-02 | 3.0241e-01 |     1114221 |    33146880 |         2008 |        6640 |        65.7 |reached target block errors\n      3.0 | 1.5859e-02 | 1.3012e-01 |     1222379 |    77076480 |         2009 |       15440 |       153.0 |reached target block errors\n      5.0 | 6.7793e-03 | 6.0628e-02 |     1120861 |   165335040 |         2008 |       33120 |       328.7 |reached target block errors\n      7.0 | 2.2633e-03 | 2.0250e-02 |      451928 |   199680000 |          810 |       40000 |       398.1 |reached max iter\n      9.0 | 6.0958e-04 | 5.2750e-03 |      121721 |   199680000 |          211 |       40000 |       397.8 |reached max iter\n     11.0 | 2.9266e-04 | 2.0500e-03 |       58438 |   199680000 |           82 |       40000 |       397.2 |reached max iter\n     13.0 | 1.8539e-04 | 1.2000e-03 |       37019 |   199680000 |           48 |       40000 |       396.9 |reached max iter\n     15.0 | 9.1491e-05 | 5.5000e-04 |       18269 |   199680000 |           22 |       40000 |       397.1 |reached max iter\n     17.0 | 5.7602e-05 | 3.7500e-04 |       11502 |   199680000 |           15 |       40000 |       398.1 |reached max iter\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -3.0 | 2.4055e-01 | 1.0000e+00 |     2401681 |     9984000 |         2000 |        2000 |        31.1 |reached target block errors\n     -1.0 | 1.9379e-01 | 1.0000e+00 |     1934840 |     9984000 |         2000 |        2000 |        20.3 |reached target block errors\n      1.0 | 1.3773e-01 | 9.8846e-01 |     1430079 |    10383360 |         2056 |        2080 |        21.1 |reached target block errors\n      3.0 | 7.0248e-02 | 6.6875e-01 |     1066068 |    15175680 |         2033 |        3040 |        30.9 |reached target block errors\n      5.0 | 3.8589e-02 | 3.0196e-01 |     1279094 |    33146880 |         2005 |        6640 |        67.4 |reached target block errors\n      7.0 | 1.9754e-02 | 1.5022e-01 |     1325339 |    67092480 |         2019 |       13440 |       136.5 |reached target block errors\n      9.0 | 1.0694e-02 | 8.3696e-02 |     1276994 |   119408640 |         2002 |       23920 |       242.5 |reached target block errors\n     11.0 | 5.5038e-03 | 4.2000e-02 |     1099001 |   199680000 |         1680 |       40000 |       405.3 |reached max iter\n     13.0 | 3.0494e-03 | 2.3975e-02 |      608913 |   199680000 |          959 |       40000 |       405.1 |reached max iter\n     15.0 | 2.3187e-03 | 1.8325e-02 |      462991 |   199680000 |          733 |       40000 |       405.3 |reached max iter\n     17.0 | 1.8833e-03 | 1.4850e-02 |      376057 |   199680000 |          594 |       40000 |       404.9 |reached max iter\n```"
"## Conclusion and Outlook\n\nIn this notebook, you have learned how to use the Sionna RT module. We have seen how paths can be found in complex environments such as in the Munich scene. In a second step, we have calculated the effective CIRs from the paths and used them for link-level simulations.\n\nThere is one key feature of Sionna RT that was not discussed in this notebook: Automatic gradient computation. Like most components of Sionna, the ray tracer is differentiable with respect to most system parameters, such as radio materials, transmitter and receiver orientations, array geometries, positions, etc. This enables a whole new line of research which is discussed in the <a class=\"reference external\" href=\"https://nvlabs.github.io/sionna/made_with_sionna.html#sionna-rt-differentiable-ray-tracing-for-radio-propagation-modeling\">Sionna RT paper and the related\nnotebooks</a>.\n\nHopefully you have enjoyed this tutorial on Sionnas RT module!\n\nPlease have a look at the [API documentation](https://nvlabs.github.io/sionna/api/sionna.html) of the various components or the other available [tutorials](https://nvlabs.github.io/sionna/tutorials.html) to learn more.\nPlease have a look at the [API documentation](https://nvlabs.github.io/sionna/api/sionna.html) of the various components or the other available [tutorials](https://nvlabs.github.io/sionna/tutorials.html) to learn more.\nPlease have a look at the [API documentation](https://nvlabs.github.io/sionna/api/sionna.html) of the various components or the other available [tutorials](https://nvlabs.github.io/sionna/tutorials.html) to learn more."

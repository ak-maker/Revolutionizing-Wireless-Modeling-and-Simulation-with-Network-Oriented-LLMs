"## (Binary) Linear Codes\n\nSeveral functions are provided to convert parity-check matrices into generator matrices and vice versa. Please note that currently only binary codes are supported.\n```python\n# load example parity-check matrix\npcm, k, n, coderate = load_parity_check_examples(pcm_id=3)\n```\n\n\nNote that many research projects provide their parity-check matrices in the  <cite>alist</cite> format [[MacKay]](https://nvlabs.github.io/sionna/api/fec.utils.html#mackay) (e.g., see [[UniKL]](https://nvlabs.github.io/sionna/api/fec.utils.html#unikl)). The follwing code snippet provides an example of how to import an external LDPC parity-check matrix from an <cite>alist</cite> file and how to set-up an encoder/decoder.\n```python\n# load external example parity-check matrix in alist format\nal = load_alist(path=filename)\npcm, k, n, coderate = alist2mat(al)\n# the linear encoder can be directly initialized with a parity-check matrix\nencoder = LinearEncoder(pcm, is_pcm=True)\n# initalize BP decoder for the given parity-check matrix\ndecoder = LDPCBPDecoder(pcm, num_iter=20)\n# and run simulation with random information bits\nno = 1.\nbatch_size = 10\nnum_bits_per_symbol = 2\nsource = BinarySource()\nmapper = Mapper(\"qam\", num_bits_per_symbol)\nchannel = AWGN()\ndemapper = Demapper(\"app\", \"qam\", num_bits_per_symbol)\nu = source([batch_size, k])\nc = encoder(u)\nx = mapper(c)\ny = channel([x, no])\nllr = demapper([y, no])\nc_hat = decoder(llr)\n```"
"### load_parity_check_examples\n\n`sionna.fec.utils.``load_parity_check_examples`(*`pcm_id`*, *`verbose``=``False`*)[`[source]`](../_modules/sionna/fec/utils.html#load_parity_check_examples)\n\nUtility function to load example codes stored in sub-folder LDPC/codes.\n\nThe following codes are available\n\n- 0 : <cite>(7,4)</cite>-Hamming code of length <cite>k=4</cite> information bits and codeword    length <cite>n=7</cite>.\n- 1 : <cite>(63,45)</cite>-BCH code of length <cite>k=45</cite> information bits and codeword    length <cite>n=63</cite>.\n- 2 : (127,106)-BCH code of length <cite>k=106</cite> information bits and codeword    length <cite>n=127</cite>.\n- 3 : Random LDPC code with regular variable node degree 3 and check node degree 6 of length <cite>k=50</cite> information bits and codeword length         <cite>n=100</cite>.\n- 4 : 802.11n LDPC code of length of length <cite>k=324</cite> information bits and    codeword length <cite>n=648</cite>.\n\nInput\n\n- **pcm_id** (*int*)  An integer defining which matrix id to load.\n- **verbose** (*bool*)  Defaults to False. If True, the code parameters are\nprinted.\n\n\nOutput\n\n- **pcm** (ndarray of <cite>zeros</cite> and <cite>ones</cite>)  An ndarray containing the parity check matrix.\n- **k** (*int*)  An integer defining the number of information bits.\n- **n** (*int*)  An integer defining the number of codeword bits.\n- **coderate** (*float*)  A float defining the coderate (assuming full rank of\nparity-check matrix)."
"### alist2mat\n\n`sionna.fec.utils.``alist2mat`(*`alist`*, *`verbose``=``True`*)[`[source]`](../_modules/sionna/fec/utils.html#alist2mat)\n\nConvert <cite>alist</cite> [[MacKay]](https://nvlabs.github.io/sionna/api/fec.utils.html#mackay) code definition to <cite>full</cite> parity-check matrix.\n\nMany code examples can be found in [[UniKL]](https://nvlabs.github.io/sionna/api/fec.utils.html#unikl).\n\nAbout <cite>alist</cite> (see [[MacKay]](https://nvlabs.github.io/sionna/api/fec.utils.html#mackay) for details):\n<blockquote>\n<div>\n- <cite>1.</cite> Row defines parity-check matrix dimension <cite>m x n</cite>\n- <cite>2.</cite> Row defines int with <cite>max_CN_degree</cite>, <cite>max_VN_degree</cite>\n- <cite>3.</cite> Row defines VN degree of all <cite>n</cite> column\n- <cite>4.</cite> Row defines CN degree of all <cite>m</cite> rows\n- Next <cite>n</cite> rows contain non-zero entries of each column (can be zero padded at the end)\n- Next <cite>m</cite> rows contain non-zero entries of each row.\n\n</blockquote>\nInput\n\n- **alist** (*list*)  Nested list in <cite>alist</cite>-format [[MacKay]](https://nvlabs.github.io/sionna/api/fec.utils.html#mackay).\n- **verbose** (*bool*)  Defaults to True. If True, the code parameters are printed.\n\n\nOutput\n\n- **(pcm, k, n, coderate)**  Tuple:\n- **pcm** (*ndarray*)  NumPy array of shape <cite>[n-k, n]</cite> containing the parity-check matrix.\n- **k** (*int*)  Number of information bits.\n- **n** (*int*)  Number of codewords bits.\n- **coderate** (*float*)  Coderate of the code.\n\n\n**Note**\n\nUse [`load_alist`](https://nvlabs.github.io/sionna/api/fec.utils.html#sionna.fec.utils.load_alist) to import alist from a\ntextfile.\n\nFor example, the following code snippet will import an alist from a file called `filename`:"
"### load_alist\n\n`sionna.fec.utils.``load_alist`(*`path`*)[`[source]`](../_modules/sionna/fec/utils.html#load_alist)\n\nRead <cite>alist</cite>-file [[MacKay]](https://nvlabs.github.io/sionna/api/fec.utils.html#mackay) and return nested list describing the\nparity-check matrix of a code.\n\nMany code examples can be found in [[UniKL]](https://nvlabs.github.io/sionna/api/fec.utils.html#unikl).\nInput\n\n**path** (*str*)  Path to file to be loaded.\n\nOutput\n\n**alist** (*list*)  A nested list containing the imported alist data."
"### generate_reg_ldpc\n\n`sionna.fec.utils.``generate_reg_ldpc`(*`v`*, *`c`*, *`n`*, *`allow_flex_len``=``True`*, *`verbose``=``True`*)[`[source]`](../_modules/sionna/fec/utils.html#generate_reg_ldpc)\n\nGenerate random regular (v,c) LDPC codes.\n\nThis functions generates a random LDPC parity-check matrix of length `n`\nwhere each variable node (VN) has degree `v` and each check node (CN) has\ndegree `c`. Please note that the LDPC code is not optimized to avoid\nshort cycles and the resulting codes may show a non-negligible error-floor.\nFor encoding, the `LinearEncoder` layer can be\nused, however, the construction does not guarantee that the pcm has full\nrank.\nInput\n\n- **v** (*int*)  Desired variable node (VN) degree.\n- **c** (*int*)  Desired check node (CN) degree.\n- **n** (*int*)  Desired codeword length.\n- **allow_flex_len** (*bool*)  Defaults to True. If True, the resulting codeword length can be\n(slightly) increased.\n- **verbose** (*bool*)  Defaults to True. If True, code parameters are printed.\n\n\nOutput\n\n- **(pcm, k, n, coderate)**  Tuple:\n- **pcm** (*ndarray*)  NumPy array of shape <cite>[n-k, n]</cite> containing the parity-check matrix.\n- **k** (*int*)  Number of information bits per codeword.\n- **n** (*int*)  Number of codewords bits.\n- **coderate** (*float*)  Coderate of the code.\n\n\n**Note**\n\nThis algorithm works only for regular node degrees. For state-of-the-art\nbit-error-rate performance, usually one needs to optimize irregular degree\nprofiles (see [[tenBrink]](https://nvlabs.github.io/sionna/api/fec.utils.html#tenbrink))."
"### make_systematic\n\n`sionna.fec.utils.``make_systematic`(*`mat`*, *`is_pcm``=``False`*)[`[source]`](../_modules/sionna/fec/utils.html#make_systematic)\n\nBring binary matrix in its systematic form.\nInput\n\n- **mat** (*ndarray*)  Binary matrix to be transformed to systematic form of shape <cite>[k, n]</cite>.\n- **is_pcm** (*bool*)  Defaults to False. If true, `mat` is interpreted as parity-check\nmatrix and, thus, the last k columns will be the identity part.\n\n\nOutput\n\n- **mat_sys** (*ndarray*)  Binary matrix in systematic form, i.e., the first <cite>k</cite> columns equal the\nidentity matrix (or last <cite>k</cite> if `is_pcm` is True).\n- **column_swaps** (*list of int tuples*)  A list of integer tuples that describes the swapped columns (in the\norder of execution).\n\n\n**Note**\n\nThis algorithm (potentially) swaps columns of the input matrix. Thus, the\nresulting systematic matrix (potentially) relates to a permuted version of\nthe code, this is defined by the returned list `column_swap`.\nNote that, the inverse permutation must be applied in the inverse list\norder (in case specific columns are swapped multiple times).\n\nIf a parity-check matrix is passed as input (i.e., `is_pcm` is True), the\nidentity part will be re-arranged to the last columns."
"### gm2pcm\n\n`sionna.fec.utils.``gm2pcm`(*`gm`*, *`verify_results``=``True`*)[`[source]`](../_modules/sionna/fec/utils.html#gm2pcm)\n\nGenerate the parity-check matrix for a given generator matrix.\n\nThis function brings `gm` $\\mathbf{G}$ in its systematic form and\nuses the following relation to find the parity-check matrix\n$\\mathbf{H}$ in GF(2)\n\n$$\n\\mathbf{G} = [\\mathbf{I} |  \\mathbf{M}]\n\\Leftrightarrow \\mathbf{H} = [\\mathbf{M} ^t | \\mathbf{I}]. \\tag{1}\n$$\n\nThis follows from the fact that for an all-zero syndrome, it must hold that\n\n$$\n\\mathbf{H} \\mathbf{c}^t = \\mathbf{H} * (\\mathbf{u} * \\mathbf{G})^t =\n\\mathbf{H} * \\mathbf{G} ^t * \\mathbf{u}^t =: \\mathbf{0}\n$$\n\nwhere $\\mathbf{c}$ denotes an arbitrary codeword and\n$\\mathbf{u}$ the corresponding information bits.\n\nThis leads to\n\n$$\n\\mathbf{G} * \\mathbf{H} ^t =: \\mathbf{0}. \\tag{2}\n$$\n\nIt can be seen that (1) fulfills (2), as it holds in GF(2) that\n\n$$\n[\\mathbf{I} |  \\mathbf{M}] * [\\mathbf{M} ^t | \\mathbf{I}]^t\n = \\mathbf{M} + \\mathbf{M} = \\mathbf{0}.\n$$\n\nInput\n\n- **gm** (*ndarray*)  Binary generator matrix of shape <cite>[k, n]</cite>.\n- **verify_results** (*bool*)  Defaults to True. If True, it is verified that the generated\nparity-check matrix is orthogonal to the generator matrix in GF(2).\n\n\nOutput\n\n*ndarray*  Binary parity-check matrix of shape <cite>[n-k, n]</cite>.\n\n\n**Note**\n\nThis algorithm only works if `gm` has full rank. Otherwise an error is\nraised."
"### pcm2gm\n\n`sionna.fec.utils.``pcm2gm`(*`pcm`*, *`verify_results``=``True`*)[`[source]`](../_modules/sionna/fec/utils.html#pcm2gm)\n\nGenerate the generator matrix for a given parity-check matrix.\n\nThis function brings `pcm` $\\mathbf{H}$ in its systematic form and\nuses the following relation to find the generator matrix\n$\\mathbf{G}$ in GF(2)\n\n$$\n\\mathbf{G} = [\\mathbf{I} |  \\mathbf{M}]\n\\Leftrightarrow \\mathbf{H} = [\\mathbf{M} ^t | \\mathbf{I}]. \\tag{1}\n$$\n\nThis follows from the fact that for an all-zero syndrome, it must hold that\n\n$$\n\\mathbf{H} \\mathbf{c}^t = \\mathbf{H} * (\\mathbf{u} * \\mathbf{G})^t =\n\\mathbf{H} * \\mathbf{G} ^t * \\mathbf{u}^t =: \\mathbf{0}\n$$\n\nwhere $\\mathbf{c}$ denotes an arbitrary codeword and\n$\\mathbf{u}$ the corresponding information bits.\n\nThis leads to\n\n$$\n\\mathbf{G} * \\mathbf{H} ^t =: \\mathbf{0}. \\tag{2}\n$$\n\nIt can be seen that (1) fulfills (2) as in GF(2) it holds that\n\n$$\n[\\mathbf{I} |  \\mathbf{M}] * [\\mathbf{M} ^t | \\mathbf{I}]^t\n = \\mathbf{M} + \\mathbf{M} = \\mathbf{0}.\n$$\n\nInput\n\n- **pcm** (*ndarray*)  Binary parity-check matrix of shape <cite>[n-k, n]</cite>.\n- **verify_results** (*bool*)  Defaults to True. If True, it is verified that the generated\ngenerator matrix is orthogonal to the parity-check matrix in GF(2).\n\n\nOutput\n\n*ndarray*  Binary generator matrix of shape <cite>[k, n]</cite>.\n\n\n**Note**\n\nThis algorithm only works if `pcm` has full rank. Otherwise an error is\nraised."
"### verify_gm_pcm\n\n`sionna.fec.utils.``verify_gm_pcm`(*`gm`*, *`pcm`*)[`[source]`](../_modules/sionna/fec/utils.html#verify_gm_pcm)\n\nVerify that generator matrix $\\mathbf{G}$ `gm` and parity-check\nmatrix $\\mathbf{H}$ `pcm` are orthogonal in GF(2).\n\nFor an all-zero syndrome, it must hold that\n\n$$\n\\mathbf{H} \\mathbf{c}^t = \\mathbf{H} * (\\mathbf{u} * \\mathbf{G})^t =\n\\mathbf{H} * \\mathbf{G} ^t * \\mathbf{u}^t =: \\mathbf{0}\n$$\n\nwhere $\\mathbf{c}$ denotes an arbitrary codeword and\n$\\mathbf{u}$ the corresponding information bits.\n\nAs $\\mathbf{u}$ can be arbitrary it follows that\n\n$$\n\\mathbf{H} * \\mathbf{G} ^t =: \\mathbf{0}.\n$$\n\nInput\n\n- **gm** (*ndarray*)  Binary generator matrix of shape <cite>[k, n]</cite>.\n- **pcm** (*ndarray*)  Binary parity-check matrix of shape <cite>[n-k, n]</cite>.\n\n\nOutput\n\n*bool*  True if `gm` and `pcm` define a valid pair of parity-check and\ngenerator matrices in GF(2)."
"## EXIT Analysis\n\nThe LDPC BP decoder allows to track the internal information flow (<cite>extrinsic information</cite>) during decoding. This can be plotted in so-called EXIT Charts [[tenBrinkEXIT]](https://nvlabs.github.io/sionna/api/fec.utils.html#tenbrinkexit) to visualize the decoding convergence.\n\nThis short code snippet shows how to generate and plot EXIT charts:\n```python\n# parameters\nebno_db = 2.5 # simulation SNR\nbatch_size = 10000\nnum_bits_per_symbol = 2 # QPSK\npcm_id = 4 # decide which parity check matrix should be used (0-2: BCH; 3: (3,6)-instruction_answer 4: instruction_answer 802.11n\npcm, k, n , coderate = load_parity_check_examples(pcm_id, verbose=True)\nnoise_var = ebnodb2no(ebno_db=ebno_db,\n                      num_bits_per_symbol=num_bits_per_symbol,\n                      coderate=coderate)\n# init components\ndecoder = LDPCBPDecoder(pcm,\n                        hard_out=False,\n                        cn_type=\"boxplus\",\n                        trainable=False,\n                        track_exit=True, # if activated, the decoder stores the outgoing extrinsic mutual information per iteration\n                        num_iter=20)\n# generates fake llrs as if the all-zero codeword was transmitted over an AWNG channel with BPSK modulation\nllr_source = GaussianPriorSource()\n\n# generate fake LLRs (Gaussian approximation)\nllr = llr_source([[batch_size, n], noise_var])\n# simulate free running decoder (for EXIT trajectory)\ndecoder(llr)\n# calculate analytical EXIT characteristics\n# Hint: these curves assume asymptotic code length, i.e., may become inaccurate in the short length regime\nIa, Iev, Iec = get_exit_analytic(pcm, ebno_db)\n# and plot the analytical exit curves\nplt = plot_exit_chart(Ia, Iev, Iec)\n# and add simulated trajectory (requires \"track_exit=True\")\nplot_trajectory(plt, decoder.ie_v, decoder.ie_c, ebno_db)\n```\n\n\nRemark: for rate-matched 5G LDPC codes, the EXIT approximation becomes\ninaccurate due to the rate-matching and the very specific structure of the\ncode."
"### plot_exit_chart\n\n`sionna.fec.utils.``plot_exit_chart`(*`mi_a``=``None`*, *`mi_ev``=``None`*, *`mi_ec``=``None`*, *`title``=``'EXIT-Chart'`*)[`[source]`](../_modules/sionna/fec/utils.html#plot_exit_chart)\n\nUtility function to plot EXIT-Charts [[tenBrinkEXIT]](https://nvlabs.github.io/sionna/api/fec.utils.html#tenbrinkexit).\n\nIf all inputs are <cite>None</cite> an empty EXIT chart is generated. Otherwise,\nthe mutual information curves are plotted.\nInput\n\n- **mi_a** (*float*)  An ndarray of floats containing the a priori mutual\ninformation.\n- **mi_v** (*float*)  An ndarray of floats containing the variable node mutual\ninformation.\n- **mi_c** (*float*)  An ndarray of floats containing the check node mutual\ninformation.\n- **title** (*str*)  A string defining the title of the EXIT chart.\n\n\nOutput\n\n**plt** (*matplotlib.figure*)  A matplotlib figure handle\n\nRaises\n\n**AssertionError**  If `title` is not <cite>str</cite>."
"### get_exit_analytic\n\n`sionna.fec.utils.``get_exit_analytic`(*`pcm`*, *`ebno_db`*)[`[source]`](../_modules/sionna/fec/utils.html#get_exit_analytic)\n\nCalculate the analytic EXIT-curves for a given parity-check matrix.\n\nThis function extracts the degree profile from `pcm` and calculates the\nvariable (VN) and check node (CN) decoder EXIT curves. Please note that\nthis is an asymptotic tool which needs a certain codeword length for\naccurate predictions.\n\nTransmission over an AWGN channel with BPSK modulation and SNR `ebno_db`\nis assumed. The detailed equations can be found in [[tenBrink]](https://nvlabs.github.io/sionna/api/fec.utils.html#tenbrink) and\n[[tenBrinkEXIT]](https://nvlabs.github.io/sionna/api/fec.utils.html#tenbrinkexit).\nInput\n\n- **pcm** (*ndarray*)  The parity-check matrix.\n- **ebno_db** (*float*)  The channel SNR in dB.\n\n\nOutput\n\n- **mi_a** (*ndarray of floats*)  NumPy array containing the <cite>a priori</cite> mutual information.\n- **mi_ev** (*ndarray of floats*)  NumPy array containing the extrinsic mutual information of the\nvariable node decoder for the corresponding `mi_a`.\n- **mi_ec** (*ndarray of floats*)  NumPy array containing the extrinsic mutual information of the check\nnode decoder for the corresponding `mi_a`.\n\n\n**Note**\n\nThis function assumes random parity-check matrices without any imposed\nstructure. Thus, explicit code construction algorithms may lead\nto inaccurate EXIT predictions. Further, this function is based\non asymptotic properties of the code, i.e., only works well for large\nparity-check matrices. For details see [[tenBrink]](https://nvlabs.github.io/sionna/api/fec.utils.html#tenbrink)."
"### plot_trajectory\n\n`sionna.fec.utils.``plot_trajectory`(*`plot`*, *`mi_v`*, *`mi_c`*, *`ebno``=``None`*)[`[source]`](../_modules/sionna/fec/utils.html#plot_trajectory)\n\nUtility function to plot the trajectory of an EXIT-chart.\nInput\n\n- **plot** (*matplotlib.figure*)  A handle to a matplotlib figure.\n- **mi_v** (*float*)  An ndarray of floats containing the variable node mutual\ninformation.\n- **mi_c** (*float*)  An ndarray of floats containing the check node mutual\ninformation.\n- **ebno** (*float*)  A float denoting the EbNo in dB for the legend entry."
"### GaussianPriorSource\n\n`class` `sionna.fec.utils.``GaussianPriorSource`(*`specified_by_mi``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/utils.html#GaussianPriorSource)\n\nGenerates <cite>fake</cite> LLRs as if the all-zero codeword was transmitted\nover an Bi-AWGN channel with noise variance `no` or mutual information\n(if `specified_by_mi` is True). If selected, the mutual information\ndenotes the mutual information associated with a binary random variable\nobserved at the output of a corresponding AWGN channel (cf. Gaussian\napproximation).\n\nThe generated LLRs are drawn from a Gaussian distribution with\n\n$$\n\\sigma_{\\text{llr}}^2 = \\frac{4}{\\sigma_\\text{ch}^2}\n$$\n\nand\n\n$$\n\\mu_{\\text{llr}} = \\frac{\\sigma_\\text{llr}^2}{2}\n$$\n\nwhere $\\sigma_\\text{ch}^2$ is the channel noise variance as defined by\n`no`.\n\nIf `specified_by_mi` is True, this class uses the of the so-called\n<cite>J-function</cite> (relates mutual information to Gaussian distributed LLRs) as\nproposed in [[Brannstrom]](https://nvlabs.github.io/sionna/api/fec.utils.html#brannstrom).\nParameters\n\n- **specified_by_mi** (*bool*)  Defaults to False. If True, the second input parameter `no` is\ninterpreted as mutual information instead of noise variance.\n- **dtype** (*tf.DType*)  Defaults to <cite>tf.float32</cite>. Defines the datatype for internal\ncalculations and the output. Must be one of the following\n<cite>(tf.float16, tf.bfloat16, tf.float32, tf.float64)</cite>.\n\n\nInput\n\n- **(output_shape, no)**  Tuple:\n- **output_shape** (*tf.int*)  Integer tensor or Python array defining the shape of the desired\noutput tensor.\n- **no** (*tf.float32*)  Scalar defining the noise variance or mutual information (if\n`specified_by_mi` is True) of the corresponding (fake) AWGN\nchannel.\n\n\nOutput\n\n`dtype`, defaults to <cite>tf.float32</cite>  1+D Tensor with shape as defined by `output_shape`.\n\nRaises\n\n- **InvalidArgumentError**  If mutual information is not in (0,1).\n- **AssertionError**  If `inputs` is not a list with 2 elements."
"### bin2int\n\n`sionna.fec.utils.``bin2int`(*`arr`*)[`[source]`](../_modules/sionna/fec/utils.html#bin2int)\n\nConvert binary array to integer.\n\nFor example `arr` = <cite>[1, 0, 1]</cite> is converted to <cite>5</cite>.\nInput\n\n**arr** (*int or float*)  An iterable that yields 0s and 1s.\n\nOutput\n\n*int*  Integer representation of `arr`."
"### int2bin\n\n`sionna.fec.utils.``int2bin`(*`num`*, *`len_`*)[`[source]`](../_modules/sionna/fec/utils.html#int2bin)\n\nConvert `num` of int type to list of length `len_` with 0s and 1s.\n`num` and `len_` have to non-negative.\n\nFor e.g., `num` = <cite>5</cite>; <cite>int2bin(num</cite>, `len_` =4) = <cite>[0, 1, 0, 1]</cite>.\n\nFor e.g., `num` = <cite>12</cite>; <cite>int2bin(num</cite>, `len_` =3) = <cite>[1, 0, 0]</cite>.\nInput\n\n- **num** (*int*)  An integer to be converted into binary representation.\n- **len_** (*int*)  An integer defining the length of the desired output.\n\n\nOutput\n\n*list of int*  Binary representation of `num` of length `len_`."
"### bin2int_tf\n\n`sionna.fec.utils.``bin2int_tf`(*`arr`*)[`[source]`](../_modules/sionna/fec/utils.html#bin2int_tf)\n\nConverts binary tensor to int tensor. Binary representation in `arr`\nis across the last dimension from most significant to least significant.\n\nFor example `arr` = <cite>[0, 1, 1]</cite> is converted to <cite>3</cite>.\nInput\n\n**arr** (*int or float*)  Tensor of  0s and 1s.\n\nOutput\n\n*int*  Tensor containing the integer representation of `arr`."
"### int2bin_tf\n\n`sionna.fec.utils.``int2bin_tf`(*`ints`*, *`len_`*)[`[source]`](../_modules/sionna/fec/utils.html#int2bin_tf)\n\nConverts (int) tensor to (int) tensor with 0s and 1s. <cite>len_</cite> should be\nto non-negative. Additional dimension of size <cite>len_</cite> is inserted at end.\nInput\n\n- **ints** (*int*)  Tensor of arbitrary shape <cite>[,k]</cite> containing integer to be\nconverted into binary representation.\n- **len_** (*int*)  An integer defining the length of the desired output.\n\n\nOutput\n\n*int*  Tensor of same shape as `ints` except dimension of length\n`len_` is added at the end <cite>[,k, len_]</cite>. Contains the binary\nrepresentation of `ints` of length `len_`."
"### int_mod_2\n\n`sionna.fec.utils.``int_mod_2`(*`x`*)[`[source]`](../_modules/sionna/fec/utils.html#int_mod_2)\n\nEfficient implementation of modulo 2 operation for integer inputs.\n\nThis function assumes integer inputs or implicitly casts to int.\n\nRemark: the function <cite>tf.math.mod(x, 2)</cite> is placed on the CPU and, thus,\ncauses unnecessary memory copies.\nParameters\n\n**x** (*tf.Tensor*)  Tensor to which the modulo 2 operation is applied."
"### llr2mi\n\n`sionna.fec.utils.``llr2mi`(*`llr`*, *`s``=``None`*, *`reduce_dims``=``True`*)[`[source]`](../_modules/sionna/fec/utils.html#llr2mi)\n\nImplements an approximation of the mutual information based on LLRs.\n\nThe function approximates the mutual information for given `llr` as\nderived in [[Hagenauer]](https://nvlabs.github.io/sionna/api/fec.utils.html#hagenauer) assuming an <cite>all-zero codeword</cite> transmission\n\n$$\nI \\approx 1 - \\sum \\operatorname{log_2} \\left( 1 + \\operatorname{e}^{-\\text{llr}} \\right).\n$$\n\nThis approximation assumes that the following <cite>symmetry condition</cite> is fulfilled\n\n$$\np(\\text{llr}|x=0) = p(\\text{llr}|x=1) \\cdot \\operatorname{exp}(\\text{llr}).\n$$\n\nFor <cite>non-all-zero</cite> codeword transmissions, this methods requires knowledge\nabout the signs of the original bit sequence `s` and flips the signs\ncorrespondingly (as if the all-zero codeword was transmitted).\n\nPlease note that we define LLRs as $\\frac{p(x=1)}{p(x=0)}$, i.e.,\nthe sign of the LLRs differ to the solution in [[Hagenauer]](https://nvlabs.github.io/sionna/api/fec.utils.html#hagenauer).\nInput\n\n- **llr** (*tf.float32*)  Tensor of arbitrary shape containing LLR-values.\n- **s** (*None or tf.float32*)  Tensor of same shape as llr containing the signs of the\ntransmitted sequence (assuming BPSK), i.e., +/-1 values.\n- **reduce_dims** (*bool*)  Defaults to True. If True, all dimensions are\nreduced and the return is a scalar. Otherwise, <cite>reduce_mean</cite> is\nonly taken over the last dimension.\n\n\nOutput\n\n**mi** (*tf.float32*)  A scalar tensor (if `reduce_dims` is True) or a tensor of same\nshape as `llr` apart from the last dimensions that is removed.\nIt contains the approximated value of the mutual information.\n\nRaises\n\n**TypeError**  If dtype of `llr` is not a real-valued float."
"### j_fun\n\n`sionna.fec.utils.``j_fun`(*`mu`*)[`[source]`](../_modules/sionna/fec/utils.html#j_fun)\n\nCalculates the <cite>J-function</cite> in NumPy.\n\nThe so-called <cite>J-function</cite> relates mutual information to the mean of\nGaussian distributed LLRs (cf. Gaussian approximation). We use the\napproximation as proposed in [[Brannstrom]](https://nvlabs.github.io/sionna/api/fec.utils.html#brannstrom) which can be written as\n\n$$\nJ(\\mu) \\approx \\left( 1- 2^{H_\\text{1}(2\\mu)^{H_\\text{2}}}\\right)^{H_\\text{2}}\n$$\n\nwith $\\mu$ denoting the mean value of the LLR distribution and\n$H_\\text{1}=0.3073$, $H_\\text{2}=0.8935$ and\n$H_\\text{3}=1.1064$.\nInput\n\n**mu** (*float*)  float or <cite>ndarray</cite> of float.\n\nOutput\n\n*float*  <cite>ndarray</cite> of same shape as the input."
"### j_fun_inv\n\n`sionna.fec.utils.``j_fun_inv`(*`mi`*)[`[source]`](../_modules/sionna/fec/utils.html#j_fun_inv)\n\nCalculates the inverse <cite>J-function</cite> in NumPy.\n\nThe so-called <cite>J-function</cite> relates mutual information to the mean of\nGaussian distributed LLRs (cf. Gaussian approximation). We use the\napproximation as proposed in [[Brannstrom]](https://nvlabs.github.io/sionna/api/fec.utils.html#brannstrom) which can be written as\n\n$$\nJ(\\mu) \\approx \\left( 1- 2^{H_\\text{1}(2\\mu)^{H_\\text{2}}}\\right)^{H_\\text{2}}\n$$\n\nwith $\\mu$ denoting the mean value of the LLR distribution and\n$H_\\text{1}=0.3073$, $H_\\text{2}=0.8935$ and\n$H_\\text{3}=1.1064$.\nInput\n\n**mi** (*float*)  float or <cite>ndarray</cite> of float.\n\nOutput\n\n*float*  <cite>ndarray</cite> of same shape as the input.\n\nRaises\n\n**AssertionError**  If `mi` < 0.001 or `mi` > 0.999."
"### j_fun_tf\n\n`sionna.fec.utils.``j_fun_tf`(*`mu`*, *`verify_inputs``=``True`*)[`[source]`](../_modules/sionna/fec/utils.html#j_fun_tf)\n\nCalculates the <cite>J-function</cite> in Tensorflow.\n\nThe so-called <cite>J-function</cite> relates mutual information to the mean of\nGaussian distributed LLRs (cf. Gaussian approximation). We use the\napproximation as proposed in [[Brannstrom]](https://nvlabs.github.io/sionna/api/fec.utils.html#brannstrom) which can be written as\n\n$$\nJ(\\mu) \\approx \\left( 1- 2^{H_\\text{1}(2\\mu)^{H_\\text{2}}}\\right)^{H_\\text{2}}\n$$\n\nwith $\\mu$ denoting the mean value of the LLR distribution and\n$H_\\text{1}=0.3073$, $H_\\text{2}=0.8935$ and\n$H_\\text{3}=1.1064$.\nInput\n\n- **mu** (*tf.float32*)  Tensor of arbitrary shape.\n- **verify_inputs** (*bool*)  A boolean defaults to True. If True, `mu` is clipped internally\nto be numerical stable.\n\n\nOutput\n\n*tf.float32*  Tensor of same shape and dtype as `mu`.\n\nRaises\n\n**InvalidArgumentError**  If `mu` is negative."
"### j_fun_inv_tf\n\n`sionna.fec.utils.``j_fun_inv_tf`(*`mi`*, *`verify_inputs``=``True`*)[`[source]`](../_modules/sionna/fec/utils.html#j_fun_inv_tf)\n\nCalculates the inverse <cite>J-function</cite> in Tensorflow.\n\nThe so-called <cite>J-function</cite> relates mutual information to the mean of\nGaussian distributed LLRs (cf. Gaussian approximation). We use the\napproximation as proposed in [[Brannstrom]](https://nvlabs.github.io/sionna/api/fec.utils.html#brannstrom) which can be written as\n\n$$\nJ(\\mu) \\approx \\left( 1- 2^{H_\\text{1}(2\\mu)^{H_\\text{2}}}\\right)^{H_\\text{2}}\n$$\n\nwith $\\mu$ denoting the mean value of the LLR distribution and\n$H_\\text{1}=0.3073$, $H_\\text{2}=0.8935$ and\n$H_\\text{3}=1.1064$.\nInput\n\n- **mi** (*tf.float32*)  Tensor of arbitrary shape.\n- **verify_inputs** (*bool*)  A boolean defaults to True. If True, `mi` is clipped internally\nto be numerical stable.\n\n\nOutput\n\n*tf.float32*  Tensor of same shape and dtype as the `mi`.\n\nRaises\n\n**InvalidArgumentError**  If `mi` is not in <cite>(0,1)</cite>.\n\n\nReferences:\ntenBrinkEXIT([1](https://nvlabs.github.io/sionna/api/fec.utils.html#id10),[2](https://nvlabs.github.io/sionna/api/fec.utils.html#id11),[3](https://nvlabs.github.io/sionna/api/fec.utils.html#id13))\n\nS. ten Brink, Convergence Behavior of Iteratively\nDecoded Parallel Concatenated Codes, IEEE Transactions on\nCommunications, vol. 49, no. 10, pp. 1727-1737, 2001.\n\nBrannstrom([1](https://nvlabs.github.io/sionna/api/fec.utils.html#id15),[2](https://nvlabs.github.io/sionna/api/fec.utils.html#id18),[3](https://nvlabs.github.io/sionna/api/fec.utils.html#id19),[4](https://nvlabs.github.io/sionna/api/fec.utils.html#id20),[5](https://nvlabs.github.io/sionna/api/fec.utils.html#id21))\n\nF. Brannstrom, L. K. Rasmussen, and A. J. Grant,\nConvergence analysis and optimal scheduling for multiple\nconcatenated codes, IEEE Trans. Inform. Theory, vol. 51, no. 9,\npp. 33543364, 2005.\n\nHagenauer([1](https://nvlabs.github.io/sionna/api/fec.utils.html#id16),[2](https://nvlabs.github.io/sionna/api/fec.utils.html#id17))\n\nJ. Hagenauer, The Turbo Principle in Mobile\nCommunications, in Proc. IEEE Int. Symp. Inf. Theory and its Appl.\n(ISITA), 2002.\n\ntenBrink([1](https://nvlabs.github.io/sionna/api/fec.utils.html#id9),[2](https://nvlabs.github.io/sionna/api/fec.utils.html#id12),[3](https://nvlabs.github.io/sionna/api/fec.utils.html#id14))\n\nS. ten Brink, G. Kramer, and A. Ashikhmin, Design of\nlow-density parity-check codes for modulation and detection, IEEE\nTrans. Commun., vol. 52, no. 4, pp. 670678, Apr. 2004.\n\nMacKay([1](https://nvlabs.github.io/sionna/api/fec.utils.html#id1),[2](https://nvlabs.github.io/sionna/api/fec.utils.html#id3),[3](https://nvlabs.github.io/sionna/api/fec.utils.html#id5),[4](https://nvlabs.github.io/sionna/api/fec.utils.html#id6),[5](https://nvlabs.github.io/sionna/api/fec.utils.html#id7))\n\n[http://www.inference.org.uk/mackay/codes/alist.html](http://www.inference.org.uk/mackay/codes/alist.html)\n\nUniKL([1](https://nvlabs.github.io/sionna/api/fec.utils.html#id2),[2](https://nvlabs.github.io/sionna/api/fec.utils.html#id4),[3](https://nvlabs.github.io/sionna/api/fec.utils.html#id8))\n\n[https://www.uni-kl.de/en/channel-codes/](https://www.uni-kl.de/en/channel-codes/)"

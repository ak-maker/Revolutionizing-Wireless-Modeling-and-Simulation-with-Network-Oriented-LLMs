"# Part 3: Advanced Link-level Simulations\n\nThis tutorial will guide you through Sionna, from its basic principles to the implementation of a point-to-point link with a 5G NR compliant code and a 3GPP channel model. You will also learn how to write custom trainable layers by implementing a state of the art neural receiver, and how to train and evaluate end-to-end communication systems.\n\nThe tutorial is structured in four notebooks:\n\n- Part I: Getting started with Sionna\n- Part II: Differentiable Communication Systems\n- **Part III: Advanced Link-level Simulations**\n- Part IV: Toward Learned Receivers\n\n\nThe [official documentation](https://nvlabs.github.io/sionna) provides key material on how to use Sionna and how its components are implemented."
"## Imports\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Import Sionna\ntry:\n    import sionna as sn\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna as sn\n# Import TensorFlow and NumPy\nimport tensorflow as tf\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\nimport numpy as np\n# For plotting\n%matplotlib inline\nimport matplotlib.pyplot as plt\n# For the implementation of the Keras models\nfrom tensorflow.keras import Model\n```"
"## OFDM Resource Grid and Stream Management\n\nWe will setup a realistic SIMO point-to-point link between a mobile user terminal (UT) and a base station (BS). The system we will setup is shown in the figure below."
"### Stream Management\n\nFor any type of MIMO simulations, it is required to setup a `StreamManagement` object. It determines which transmitters and receivers communicate data streams with each other. In our scenario, we will configure a single UT equipped with a single antenna and a single BS equipped with multiple antennas. Whether the UT or BS is considered as a transmitter depends on the link direction, which can be either uplink or downlink. The `StreamManagement` has many properties that are used by other\ncomponents, such as precoding and equalization.\n\nWe will configure the system here such that the number of streams per transmitter is equal to the number of UT antennas.\n\n\n```python\n# Define the number of UT and BS antennas\nNUM_UT = 1\nNUM_BS = 1\nNUM_UT_ANT = 1\nNUM_BS_ANT = 4\n# The number of transmitted streams is equal to the number of UT antennas\n# in both uplink and downlink\nNUM_STREAMS_PER_TX = NUM_UT_ANT\n# Create an RX-TX association matrix.\n# RX_TX_ASSOCIATION[i,j]=1 means that receiver i gets at least one stream\n# from transmitter j. Depending on the transmission direction (uplink or downlink),\n# the role of UT and BS can change.\n# For example, considering a system with 2 RX and 4 TX, the RX-TX\n# association matrix could be\n# [ [1 , 1, 0, 0],\n#   [0 , 0, 1, 1] ]\n# which indicates that the RX 0 receives from TX 0 and 1, and RX 1 receives from\n# TX 2 and 3.\n#\n# In this notebook, as we have only a single transmitter and receiver,\n# the RX-TX association matrix is simply:\nRX_TX_ASSOCIATION = np.array([[1]])\n# Instantiate a StreamManagement object\n# This determines which data streams are determined for which receiver.\n# In this simple setup, this is fairly easy. However, it can get more involved\n# for simulations with many transmitters and receivers.\nSTREAM_MANAGEMENT = sn.mimo.StreamManagement(RX_TX_ASSOCIATION, NUM_STREAMS_PER_TX)\n```"
"### OFDM Resource Grid\n\nNext, we configure an OFDM `ResourceGrid` spanning multiple OFDM symbols. The resource grid contains data symbols and pilots and is equivalent to a *slot* in 4G/5G terminology. Although it is not relevant for our simulation, we null the DC subcarrier and a few guard carriers to the left and right of the spectrum. Also a cyclic prefix is added.\n\nDuring the creation of the `ResourceGrid`, a `PilotPattern` is automatically generated. We could have alternatively created a `PilotPattern` first and then provided it as initialization parameter. When multiple streams are considered, the corresponding pilot patterns must be orthogonal. By default, orthogonal pilots are setup when considering such systems.\n\n\n```python\nRESOURCE_GRID = sn.ofdm.ResourceGrid( num_ofdm_symbols=14,\n                                      fft_size=76,\n                                      subcarrier_spacing=30e3,\n                                      num_tx=NUM_UT,\n                                      num_streams_per_tx=NUM_STREAMS_PER_TX,\n                                      cyclic_prefix_length=6,\n                                      pilot_pattern=\"kronecker\",\n                                      pilot_ofdm_symbol_indices=[2,11])\nRESOURCE_GRID.show();\n```\n\n\n```python\nRESOURCE_GRID.pilot_pattern.show();\n```\n\n\n**Task:** You can try different pilot patterns, FFT size, number of OFDM symbols, and visualize how it affects the resource grid.\n\nSee the notebook [MIMO_OFDM_Transmissions_over_CDL](https://nvlabs.github.io/sionna/examples/MIMO_OFDM_Transmissions_over_CDL.html) for more advanced examples."
"## Antenna Arrays\n\nWe need to configure the antenna arrays used by the UT and BS. This can be ignored for simple channel models, such as `AWGN`, `RayleighBlockFading`, or `TDL` which do not account for antenna array geometries and antenna radiation patterns. However, other models, such as `CDL`, `UMi`, `UMa`, and `RMa` from the 3GPP 38.901 specification, require it.\n\nWe will assume here that UT is equipped with one vertically single-polarized antenna and the BS antenna array is composed of dual cross-polarized antenna elements with an antenna pattern defined in the [3GPP 38.901 specification](https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3173). By default, the antenna elements are spaced half of a wavelength apart in both vertical and horizontal directions. You can define your own antenna geometries an\nradiation patterns if needed.\n\nAn `AntennaArray` is always defined in the y-z plane. Its final orientation will be determined by the orientation of the UT or BS. This parameter can be configured in the `ChannelModel` that we will create later.\n\n\n```python\nCARRIER_FREQUENCY = 2.6e9 # Carrier frequency in Hz.\n                          # This is needed here to define the antenna element spacing.\nUT_ARRAY = sn.channel.tr38901.Antenna(  polarization=\"single\",\n                                        polarization_type=\"V\",\n                                        antenna_pattern=\"38.901\",\n                                        carrier_frequency=CARRIER_FREQUENCY)\nUT_ARRAY.show();\nBS_ARRAY = sn.channel.tr38901.AntennaArray( num_rows=1,\n                                            num_cols=int(NUM_BS_ANT/2),\n                                            polarization=\"dual\",\n                                            polarization_type=\"cross\",\n                                            antenna_pattern=\"38.901\", # Try 'omni'\n                                            carrier_frequency=CARRIER_FREQUENCY)\nBS_ARRAY.show();\n```\n\n\n```python\nBS_ARRAY.show_element_radiation_pattern();\n```\n\n\n**Task:** You can try different antenna pattern (omni), polarization, and array geometries."
"## Channel Model\n\nSionna implements the CDL, TDL, UMi, UMa, and RMa models from [3GPP TR 38.901](https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3173), as well as Rayleigh block fading.\n\nNote that: * TDL only supports SISO * CDL only supports single-user, possibly with multiple antenna * UMi, UMa, and RMa support single- and multi-user\n\n*Remark:* The TDL and CDL models correspond to fixed power delay profiles and fixed angles.\n\n\nWe consider the 3GPP CDL model family in this notebook.\n\n\n```python\nDELAY_SPREAD = 100e-9 # Nominal delay spread in [s]. Please see the CDL documentation\n                      # about how to choose this value.\nDIRECTION = \"uplink\"  # The `direction` determines if the UT or BS is transmitting.\n                      # In the `uplink`, the UT is transmitting.\nCDL_MODEL = \"C\"       # Suitable values are [\"A\", \"B\", \"C\", \"D\", \"E\"]\nSPEED = 10.0          # UT speed [m/s]. BSs are always assumed to be fixed.\n                     # The direction of travel will chosen randomly within the x-y plane.\n# Configure a channel impulse reponse (CIR) generator for the CDL model.\nCDL = sn.channel.tr38901.CDL(CDL_MODEL,\n                             DELAY_SPREAD,\n                             CARRIER_FREQUENCY,\n                             UT_ARRAY,\n                             BS_ARRAY,\n                             DIRECTION,\n                             min_speed=SPEED)\n```\n\n\nThe instance `CDL` of the CDL model can be used to generate batches of random realizations of continuous-time channel impulse responses, consisting of complex gains `a` and delays `tau` for each path. To account for time-varying channels, a channel impulse responses is sampled at the `sampling_frequency` for `num_time_samples` samples. For more details on this, please have a look at the API documentation of the channel models.\n\nIn order to model the channel in the frequency domain, we need `num_ofdm_symbols` samples that are taken once per `ofdm_symbol_duration`, which corresponds to the length of an OFDM symbol plus the cyclic prefix.\n\n\n```python\nBATCH_SIZE = 128 # How many examples are processed by Sionna in parallel\na, tau = CDL(batch_size=BATCH_SIZE,\n             num_time_steps=RESOURCE_GRID.num_ofdm_symbols,\n             sampling_frequency=1/RESOURCE_GRID.ofdm_symbol_duration)\n```"
"The path gains `a` have shape\n`[batch` `size,` `num_rx,` `num_rx_ant,` `num_tx,` `num_tx_ant,` `num_paths,` `num_time_steps]`\nand the delays `tau` have shape\n`[batch_size,` `num_rx,` `num_tx,` `num_paths]`.\n\n\n```python\nprint(\"Shape of the path gains: \", a.shape)\nprint(\"Shape of the delays:\", tau.shape)\n```\n\n\n```python\nShape of the path gains:  (128, 1, 4, 1, 1, 24, 14)\nShape of the delays: (128, 1, 1, 24)\n```\n\n\nThe delays are assumed to be static within the time-window of interest. Only the complex path gains change over time. The following two figures depict the channel impulse response at a particular time instant and the time-evolution of the gain of one path, respectively.\n\n\n```python\nplt.figure()\nplt.title(\"Channel impulse response realization\")\nplt.stem(tau[0,0,0,:]/1e-9, np.abs(a)[0,0,0,0,0,:,0])\nplt.xlabel(r\"$\\tau$ [ns]\")\nplt.ylabel(r\"$|a|$\")\n\nplt.figure()\nplt.title(\"Time evolution of path gain\")\nplt.plot(np.arange(RESOURCE_GRID.num_ofdm_symbols)*RESOURCE_GRID.ofdm_symbol_duration/1e-6, np.real(a)[0,0,0,0,0,0,:])\nplt.plot(np.arange(RESOURCE_GRID.num_ofdm_symbols)*RESOURCE_GRID.ofdm_symbol_duration/1e-6, np.imag(a)[0,0,0,0,0,0,:])\nplt.legend([\"Real part\", \"Imaginary part\"])\nplt.xlabel(r\"$t$ [us]\")\nplt.ylabel(r\"$a$\");\n```\n\n\nSee the notebook [Realistic_Multiuser_MIMO_Simulations](https://nvlabs.github.io/sionna/examples/Realistic_Multiuser_MIMO_Simulations.html) for more advanced examples."
"## Uplink Transmission in the Frequency Domain\n\nWe are now ready to simulate a transmission.\n\nIn the following, the channel is simulated in the frequency domain. Therefore, the channel is assumed to be constant over the duration of an OFDM symbol, which leads to not simulating the intercarrier interference (ICI) that could occur due to channel aging over the duration of OFDM symbols.\n\nThe `OFDMChannel` layer is used to simulate the channel in the frequency domain and takes care of sampling channel impulse responses, computing the frequency responses, and applying the channel transfer function to the channel inputs (including AWGN).\n\nNote that it is also possible to simulate the channel in time domain using the `TimeChannel` layer, which enables simulation of ICI. For more information, please have a look at the API documentation.\n\n\n```python\nNUM_BITS_PER_SYMBOL = 2 # QPSK\nCODERATE = 0.5\n# Number of coded bits in a resource grid\nn = int(RESOURCE_GRID.num_data_symbols*NUM_BITS_PER_SYMBOL)\n# Number of information bits in a resource groud\nk = int(n*CODERATE)\n# The binary source will create batches of information bits\nbinary_source = sn.utils.BinarySource()\n# The encoder maps information bits to coded bits\nencoder = sn.fec.ldpc.LDPC5GEncoder(k, n)\n# The mapper maps blocks of information bits to constellation symbols\nmapper = sn.mapping.Mapper(\"qam\", NUM_BITS_PER_SYMBOL)\n# The resource grid mapper maps symbols onto an OFDM resource grid\nrg_mapper = sn.ofdm.ResourceGridMapper(RESOURCE_GRID)\n# Frequency domain channel\nchannel = sn.channel.OFDMChannel(CDL, RESOURCE_GRID, add_awgn=True, normalize_channel=True, return_channel=True)\n# The LS channel estimator will provide channel estimates and error variances\nls_est = sn.ofdm.LSChannelEstimator(RESOURCE_GRID, interpolation_type=\"nn\")\n# The LMMSE equalizer will provide soft symbols together with noise variance estimates\nlmmse_equ = sn.ofdm.LMMSEEqualizer(RESOURCE_GRID, STREAM_MANAGEMENT)\n# The demapper produces LLR for all coded bits\ndemapper = sn.mapping.Demapper(\"app\", \"qam\", NUM_BITS_PER_SYMBOL)\n# The decoder provides hard-decisions on the information bits\ndecoder = sn.fec.ldpc.LDPC5GDecoder(encoder, hard_out=True)\n```"
"Lets now simulate the transmission, and look at the shape of the layers outputs at each stage.\n\nThe utility function `ebnodb2no` takes as additional input the resource grid to account for the pilots when computing the noise power spectral density ratio $N_0$ from the energy per bit to noise power spectral density ratio $E_b/N_0$ (in dB).\n\n\n```python\nno = sn.utils.ebnodb2no(ebno_db=10.0,\n                        num_bits_per_symbol=NUM_BITS_PER_SYMBOL,\n                        coderate=CODERATE,\n                        resource_grid=RESOURCE_GRID)\n# Transmitter\nbits = binary_source([BATCH_SIZE, NUM_UT, RESOURCE_GRID.num_streams_per_tx, k])\nprint(\"Shape of bits: \", bits.shape)\ncodewords = encoder(bits)\nprint(\"Shape of codewords: \", codewords.shape)\nx = mapper(codewords)\nprint(\"Shape of x: \", x.shape)\nx_rg = rg_mapper(x)\nprint(\"Shape of x_rg: \", x_rg.shape)\n# Channel\ny, h_freq = channel([x_rg, no])\nprint(\"Shape of y_rg: \", y.shape)\nprint(\"Shape of h_freq: \", h_freq.shape)\n# Receiver\nh_hat, err_var = ls_est ([y, no])\nprint(\"Shape of h_hat: \", h_hat.shape)\nprint(\"Shape of err_var: \", err_var.shape)\nx_hat, no_eff = lmmse_equ([y, h_hat, err_var, no])\nprint(\"Shape of x_hat: \", x_hat.shape)\nprint(\"Shape of no_eff: \", no_eff.shape)\nllr = demapper([x_hat, no_eff])\nprint(\"Shape of llr: \", llr.shape)\nbits_hat = decoder(llr)\nprint(\"Shape of bits_hat: \", bits_hat.shape)\n```\n\n\n```python\nShape of bits:  (128, 1, 1, 912)\nShape of codewords:  (128, 1, 1, 1824)\nShape of x:  (128, 1, 1, 912)\nShape of x_rg:  (128, 1, 1, 14, 76)\nShape of y_rg:  (128, 1, 4, 14, 76)\nShape of h_freq:  (128, 1, 4, 1, 1, 14, 76)\nShape of h_hat:  (128, 1, 4, 1, 1, 14, 76)\nShape of err_var:  (1, 1, 1, 1, 1, 14, 76)\nShape of x_hat:  (128, 1, 1, 912)\nShape of no_eff:  (128, 1, 1, 912)\nShape of llr:  (128, 1, 1, 1824)\nShape of bits_hat:  (128, 1, 1, 912)\n```"
"The next cell implements the previous system as a Keras model.\n\nMoreover, a boolean given as parameter to the initializer enables using either LS estimation or perfect CSI, as shown in the figure below.\n\n\n```python\nclass OFDMSystem(Model): # Inherits from Keras Model\n    def __init__(self, perfect_csi):\n        super().__init__() # Must call the Keras model initializer\n        self.perfect_csi = perfect_csi\n        n = int(RESOURCE_GRID.num_data_symbols*NUM_BITS_PER_SYMBOL) # Number of coded bits\n        k = int(n*CODERATE) # Number of information bits\n        self.k = k\n        # The binary source will create batches of information bits\n        self.binary_source = sn.utils.BinarySource()\n        # The encoder maps information bits to coded bits\n        self.encoder = sn.fec.ldpc.LDPC5GEncoder(k, n)\n        # The mapper maps blocks of information bits to constellation symbols\n        self.mapper = sn.mapping.Mapper(\"qam\", NUM_BITS_PER_SYMBOL)\n        # The resource grid mapper maps symbols onto an OFDM resource grid\n        self.rg_mapper = sn.ofdm.ResourceGridMapper(RESOURCE_GRID)\n        # Frequency domain channel\n        self.channel = sn.channel.OFDMChannel(CDL, RESOURCE_GRID, add_awgn=True, normalize_channel=True, return_channel=True)\n        # The LS channel estimator will provide channel estimates and error variances\n        self.ls_est = sn.ofdm.LSChannelEstimator(RESOURCE_GRID, interpolation_type=\"nn\")\n        # The LMMSE equalizer will provide soft symbols together with noise variance estimates\n        self.lmmse_equ = sn.ofdm.LMMSEEqualizer(RESOURCE_GRID, STREAM_MANAGEMENT)\n        # The demapper produces LLR for all coded bits\n        self.demapper = sn.mapping.Demapper(\"app\", \"qam\", NUM_BITS_PER_SYMBOL)\n        # The decoder provides hard-decisions on the information bits\n        self.decoder = sn.fec.ldpc.LDPC5GDecoder(self.encoder, hard_out=True)\n    @tf.function # Graph execution to speed things up\n    def __call__(self, batch_size, ebno_db):\n        no = sn.utils.ebnodb2no(ebno_db, num_bits_per_symbol=NUM_BITS_PER_SYMBOL, coderate=CODERATE, resource_grid=RESOURCE_GRID)\n        # Transmitter\n        bits = self.binary_source([batch_size, NUM_UT, RESOURCE_GRID.num_streams_per_tx, self.k])\n        codewords = self.encoder(bits)\n        x = self.mapper(codewords)\n        x_rg = self.rg_mapper(x)\n        # Channel\n        y, h_freq = self.channel([x_rg, no])\n        # Receiver\n        if self.perfect_csi:\n            h_hat, err_var = h_freq, 0.\n        else:\n            h_hat, err_var = self.ls_est ([y, no])\n        x_hat, no_eff = self.lmmse_equ([y, h_hat, err_var, no])\n        llr = self.demapper([x_hat, no_eff])\n        bits_hat = self.decoder(llr)\n        return bits, bits_hat\n```"
"```python\nEBN0_DB_MIN = -8.0 # Minimum value of Eb/N0 [dB] for simulations\nEBN0_DB_MAX = 3.0 # Maximum value of Eb/N0 [dB] for simulations\nber_plots = sn.utils.PlotBER(\"OFDM over 3GPP CDL\")\nmodel_ls = OFDMSystem(False)\nber_plots.simulate(model_ls,\n                  ebno_dbs=np.linspace(EBN0_DB_MIN, EBN0_DB_MAX, 20),\n                  batch_size=BATCH_SIZE,\n                  num_target_block_errors=100, # simulate until 100 block errors occured\n                  legend=\"LS Estimation\",\n                  soft_estimates=True,\n                  max_mc_iter=100, # run 100 Monte-Carlo simulations (each with batch_size samples)\n                  show_fig=False);\nmodel_pcsi = OFDMSystem(True)\nber_plots.simulate(model_pcsi,\n                  ebno_dbs=np.linspace(EBN0_DB_MIN, EBN0_DB_MAX, 20),\n                  batch_size=BATCH_SIZE,\n                  num_target_block_errors=100, # simulate until 100 block errors occured\n                  legend=\"Perfect CSI\",\n                  soft_estimates=True,\n                  max_mc_iter=100, # run 100 Monte-Carlo simulations (each with batch_size samples)\n                  show_fig=False);\nber_plots();\n```\n\n\n```python\nWARNING:tensorflow:From /usr/local/lib/python3.8/dist-packages/tensorflow/python/util/dispatch.py:1082: calling gather (from tensorflow.python.ops.array_ops) with validate_indices is deprecated and will be removed in a future version.\nInstructions for updating:\nThe `validate_indices` argument has no effect. Indices are always validated on CPU and never validated on GPU.\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -8.0 | 4.2978e-01 | 1.0000e+00 |       50171 |      116736 |          128 |         128 |         7.0 |reached target block errors\n   -7.421 | 4.1871e-01 | 1.0000e+00 |       48878 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -6.842 | 4.1140e-01 | 1.0000e+00 |       48025 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -6.263 | 4.0080e-01 | 1.0000e+00 |       46788 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -5.684 | 3.8840e-01 | 1.0000e+00 |       45340 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -5.105 | 3.7817e-01 | 1.0000e+00 |       44146 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -4.526 | 3.6195e-01 | 1.0000e+00 |       42253 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -3.947 | 3.4381e-01 | 1.0000e+00 |       40135 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -3.368 | 3.2687e-01 | 1.0000e+00 |       38158 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -2.789 | 3.0678e-01 | 1.0000e+00 |       35812 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -2.211 | 2.8767e-01 | 1.0000e+00 |       33582 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -1.632 | 2.6431e-01 | 1.0000e+00 |       30855 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -1.053 | 2.4057e-01 | 1.0000e+00 |       28083 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -0.474 | 2.1041e-01 | 1.0000e+00 |       24563 |      116736 |          128 |         128 |         0.2 |reached target block errors\n    0.105 | 1.5792e-01 | 9.8438e-01 |       18435 |      116736 |          126 |         128 |         0.2 |reached target block errors\n    0.684 | 3.1259e-02 | 4.3750e-01 |        7298 |      233472 |          112 |         256 |         0.3 |reached target block errors\n    1.263 | 4.5551e-04 | 1.2525e-02 |        3350 |     7354368 |          101 |        8064 |         9.9 |reached target block errors\n    1.842 | 0.0000e+00 | 0.0000e+00 |           0 |    11673600 |            0 |       12800 |        15.8 |reached max iter\nSimulation stopped as no error occurred @ EbNo = 1.8 dB.\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -8.0 | 2.8242e-01 | 1.0000e+00 |       32969 |      116736 |          128 |         128 |         3.4 |reached target block errors\n   -7.421 | 2.6455e-01 | 1.0000e+00 |       30883 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -6.842 | 2.4662e-01 | 1.0000e+00 |       28790 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -6.263 | 2.2697e-01 | 1.0000e+00 |       26495 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -5.684 | 2.0201e-01 | 1.0000e+00 |       23582 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -5.105 | 1.7199e-01 | 1.0000e+00 |       20078 |      116736 |          128 |         128 |         0.2 |reached target block errors\n   -4.526 | 1.0359e-01 | 9.6094e-01 |       12093 |      116736 |          123 |         128 |         0.2 |reached target block errors\n   -3.947 | 1.7351e-02 | 4.1016e-01 |        4051 |      233472 |          105 |         256 |         0.3 |reached target block errors\n   -3.368 | 1.4470e-04 | 8.4918e-03 |        1554 |    10739712 |          100 |       11776 |        14.8 |reached target block errors\n   -2.789 | 0.0000e+00 | 0.0000e+00 |           0 |    11673600 |            0 |       12800 |        16.1 |reached max iter\nSimulation stopped as no error occurred @ EbNo = -2.8 dB.\n\n```"

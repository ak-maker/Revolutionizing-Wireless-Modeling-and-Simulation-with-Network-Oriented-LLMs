"# Wireless\n\nThis module provides layers and functions that implement wireless channel models.\nModels currently available include [`AWGN`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.AWGN), [flat-fading](https://nvlabs.github.io/sionna/api/channel.wireless.html#flat-fading) with (optional) [`SpatialCorrelation`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.SpatialCorrelation), [`RayleighBlockFading`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.RayleighBlockFading), as well as models from the 3rd Generation Partnership Project (3GPP) [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901): [TDL](https://nvlabs.github.io/sionna/api/channel.wireless.html#tdl), [CDL](https://nvlabs.github.io/sionna/api/channel.wireless.html#cdl), [UMi](https://nvlabs.github.io/sionna/api/channel.wireless.html#umi), [UMa](https://nvlabs.github.io/sionna/api/channel.wireless.html#uma), and [RMa](https://nvlabs.github.io/sionna/api/channel.wireless.html#rma). It is also possible to [use externally generated CIRs](https://nvlabs.github.io/sionna/api/channel.wireless.html#external-datasets).\n\nApart from [flat-fading](https://nvlabs.github.io/sionna/api/channel.wireless.html#flat-fading), all of these models generate channel impulse responses (CIRs) that can then be used to\nimplement a channel transfer function in the [time domain](https://nvlabs.github.io/sionna/api/channel.wireless.html#time-domain) or\n[assuming an OFDM waveform](https://nvlabs.github.io/sionna/api/channel.wireless.html#ofdm-waveform).\n\nThis is achieved using the different functions, classes, and Keras layers which\noperate as shown in the figures below.\n ig. 7 Channel module architecture for time domain simulations.\n\n ig. 8 Channel module architecture for simulations assuming OFDM waveform.\n\nA channel model generate CIRs from which channel responses in the time domain\nor in the frequency domain are computed using the\n[`cir_to_time_channel()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.cir_to_time_channel) or\n[`cir_to_ofdm_channel()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.cir_to_ofdm_channel) functions, respectively.\nIf one does not need access to the raw CIRs, the\n[`GenerateTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateTimeChannel) and\n[`GenerateOFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateOFDMChannel) classes can be used to conveniently\nsample CIRs and generate channel responses in the desired domain.\n\nOnce the channel responses in the time or frequency domain are computed, they\ncan be applied to the channel input using the\n[`ApplyTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyTimeChannel) or\n[`ApplyOFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyOFDMChannel) Keras layers.\n\nThe following code snippets show how to setup and run a Rayleigh block fading\nmodel assuming an OFDM waveform, and without accessing the CIRs or\nchannel responses.\nThis is the easiest way to setup a channel model.\nSetting-up other models is done in a similar way, except for\n[`AWGN`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.AWGN) (see the [`AWGN`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.AWGN)\nclass documentation)."
"```python\nrayleigh = RayleighBlockFading(num_rx = 1,\n                               num_rx_ant = 32,\n                               num_tx = 4,\n                               num_tx_ant = 2)\nchannel  = OFDMChannel(channel_model = rayleigh,\n                       resource_grid = rg)\n```\n\n\nwhere `rg` is an instance of [`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid).\n\nRunning the channel model is done as follows:\n```python\n# x is the channel input\n# no is the noise variance\ny = channel([x, no])\n```\n\n\nTo use the time domain representation of the channel, one can use\n[`TimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.TimeChannel) instead of\n[`OFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.OFDMChannel).\n\nIf access to the channel responses is needed, one can separate their\ngeneration from their application to the channel input by setting up the channel\nmodel as follows:\n```python\nrayleigh = RayleighBlockFading(num_rx = 1,\n                               num_rx_ant = 32,\n                               num_tx = 4,\n                               num_tx_ant = 2)\ngenerate_channel = GenerateOFDMChannel(channel_model = rayleigh,\n                                       resource_grid = rg)\napply_channel = ApplyOFDMChannel()\n```\n\n\nwhere `rg` is an instance of [`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid).\nRunning the channel model is done as follows:\n```python\n# Generate a batch of channel responses\nh = generate_channel(batch_size)\n# Apply the channel\n# x is the channel input\n# no is the noise variance\ny = apply_channel([x, h, no])\n```\n\n\nGenerating and applying the channel in the time domain can be achieved by using\n[`GenerateTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateTimeChannel) and\n[`ApplyTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyTimeChannel) instead of\n[`GenerateOFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateOFDMChannel) and\n[`ApplyOFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyOFDMChannel), respectively.\n\nTo access the CIRs, setting up the channel can be done as follows:"
"```python\nrayleigh = RayleighBlockFading(num_rx = 1,\n                               num_rx_ant = 32,\n                               num_tx = 4,\n                               num_tx_ant = 2)\napply_channel = ApplyOFDMChannel()\n```\n\n\nand running the channel model as follows:\n```python\ncir = rayleigh(batch_size)\nh = cir_to_ofdm_channel(frequencies, *cir)\ny = apply_channel([x, h, no])\n```\n\n\nwhere `frequencies` are the subcarrier frequencies in the baseband, which can\nbe computed using the [`subcarrier_frequencies()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.subcarrier_frequencies) utility\nfunction.\n\nApplying the channel in the time domain can be done by using\n[`cir_to_time_channel()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.cir_to_time_channel) and\n[`ApplyTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyTimeChannel) instead of\n[`cir_to_ofdm_channel()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.cir_to_ofdm_channel) and\n[`ApplyOFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyOFDMChannel), respectively.\n\nFor the purpose of the present document, the following symbols apply:\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 24%\" />\n<col style=\"width: 76%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td>\n$N_T (u)$</td>\n<td>\nNumber of transmitters (transmitter index)</td>\n</tr>\n<tr class=\"row-even\"><td>\n$N_R (v)$</td>\n<td>\nNumber of receivers (receiver index)</td>\n</tr>\n<tr class=\"row-odd\"><td>\n$N_{TA} (k)$</td>\n<td>\nNumber of antennas per transmitter (transmit antenna index)</td>\n</tr>\n<tr class=\"row-even\"><td>\n$N_{RA} (l)$</td>\n<td>\nNumber of antennas per receiver (receive antenna index)</td>\n</tr>\n<tr class=\"row-odd\"><td>\n$N_S (s)$</td>\n<td>\nNumber of OFDM symbols (OFDM symbol index)</td>\n</tr>\n<tr class=\"row-even\"><td>\n$N_F (n)$</td>\n<td>\nNumber of subcarriers (subcarrier index)</td>\n</tr>\n<tr class=\"row-odd\"><td>\n$N_B (b)$</td>\n<td>\nNumber of time samples forming the channel input (baseband symbol index)</td>\n</tr>\n<tr class=\"row-even\"><td>\n$L_{\\text{min}}$</td>\n<td>\nSmallest time-lag for the discrete complex baseband channel</td>\n</tr>\n<tr class=\"row-odd\"><td>\n$L_{\\text{max}}$</td>\n<td>\nLargest time-lag for the discrete complex baseband channel</td>\n</tr>\n<tr class=\"row-even\"><td>\n$M (m)$</td>\n<td>\nNumber of paths (clusters) forming a power delay profile (path index)</td>\n</tr>\n<tr class=\"row-odd\"><td>\n$\\tau_m(t)$</td>\n<td>\n$m^{th}$ path (cluster) delay at time step $t$</td>\n</tr>\n<tr class=\"row-even\"><td>\n$a_m(t)$</td>\n<td>\n$m^{th}$ path (cluster) complex coefficient at time step $t$</td>\n</tr>\n<tr class=\"row-odd\"><td>\n$\\Delta_f$</td>\n<td>\nSubcarrier spacing</td>\n</tr>\n<tr class=\"row-even\"><td>\n$W$</td>\n<td>\nBandwidth</td>\n</tr>\n<tr class=\"row-odd\"><td>\n$N_0$</td>\n<td>\nNoise variance</td>\n</tr>\n</tbody>\n</table>\n\nAll transmitters are equipped with $N_{TA}$ antennas and all receivers\nwith $N_{RA}$ antennas.\n\nA channel model, such as [`RayleighBlockFading`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.RayleighBlockFading) or\n[`UMi`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMi), is used to generate for each link between\nantenna $k$ of transmitter $u$ and antenna $l$ of receiver\n$v$ a power delay profile\n$(a_{u, k, v, l, m}(t), \\tau_{u, v, m}), 0 \\leq m \\leq M-1$.\nThe delays are assumed not to depend on time $t$, and transmit and receive\nantennas $k$ and $l$.\nSuch a power delay profile corresponds to the channel impulse response\n\n$$\nh_{u, k, v, l}(t,\\tau) =\n\\sum_{m=0}^{M-1} a_{u, k, v, l,m}(t) \\delta(\\tau - \\tau_{u, v, m})\n$$\n\nwhere $\\delta(\\cdot)$ is the Dirac delta measure.\nFor example, in the case of Rayleigh block fading, the power delay profiles are\ntime-invariant and such that for every link $(u, k, v, l)$\n\n$$\n\\begin{split}\\begin{align}\n   M                     &= 1\\\\\n   \\tau_{u, v, 0}  &= 0\\\\\n   a_{u, k, v, l, 0}     &\\sim \\mathcal{CN}(0,1).\n\\end{align}\\end{split}\n$$\n\n3GPP channel models use the procedure depicted in [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) to generate power\ndelay profiles. With these models, the power delay profiles are time-*variant*\nin the event of mobility."
"## AWGN\n\n`class` `sionna.channel.``AWGN`(*`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/channel/awgn.html#AWGN)\n\nAdd complex AWGN to the inputs with a certain variance.\n\nThis class inherits from the Keras <cite>Layer</cite> class and can be used as layer in\na Keras model.\n\nThis layer adds complex AWGN noise with variance `no` to the input.\nThe noise has variance `no/2` per real dimension.\nIt can be either a scalar or a tensor which can be broadcast to the shape\nof the input.\n xample\n\nSetting-up:\n```python\n>>> awgn_channel = AWGN()\n```\n\n\nRunning:\n```python\n>>> # x is the channel input\n>>> # no is the noise variance\n>>> y = awgn_channel((x, no))\n```\n\nParameters\n\n**dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\nInput\n\n- **(x, no)**  Tuple:\n- **x** (*Tensor, tf.complex*)  Channel input\n- **no** (*Scalar or Tensor, tf.float*)  Scalar or tensor whose shape can be broadcast to the shape of `x`.\nThe noise power `no` is per complex dimension. If `no` is a\nscalar, noise of the same variance will be added to the input.\nIf `no` is a tensor, it must have a shape that can be broadcast to\nthe shape of `x`. This allows, e.g., adding noise of different\nvariance to each example in a batch. If `no` has a lower rank than\n`x`, then `no` will be broadcast to the shape of `x` by adding\ndummy dimensions after the last axis.\n\n\nOutput\n\n**y** (Tensor with same shape as `x`, tf.complex)  Channel output"
"### FlatFadingChannel\n\n`class` `sionna.channel.``FlatFadingChannel`(*`num_tx_ant`*, *`num_rx_ant`*, *`spatial_corr``=``None`*, *`add_awgn``=``True`*, *`return_channel``=``False`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/channel/flat_fading_channel.html#FlatFadingChannel)\n\nApplies random channel matrices to a vector input and adds AWGN.\n\nThis class combines [`GenerateFlatFadingChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateFlatFadingChannel) and\n[`ApplyFlatFadingChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyFlatFadingChannel) and computes the output of\na flat-fading channel with AWGN.\n\nFor a given batch of input vectors $\\mathbf{x}\\in\\mathbb{C}^{K}$,\nthe output is\n\n$$\n\\mathbf{y} = \\mathbf{H}\\mathbf{x} + \\mathbf{n}\n$$\n\nwhere $\\mathbf{H}\\in\\mathbb{C}^{M\\times K}$ are randomly generated\nflat-fading channel matrices and\n$\\mathbf{n}\\in\\mathbb{C}^{M}\\sim\\mathcal{CN}(0, N_o\\mathbf{I})$\nis an AWGN vector that is optionally added.\n\nA [`SpatialCorrelation`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.SpatialCorrelation) can be configured and the\nchannel realizations optionally returned. This is useful to simulate\nreceiver algorithms with perfect channel knowledge.\nParameters\n\n- **num_tx_ant** (*int*)  Number of transmit antennas.\n- **num_rx_ant** (*int*)  Number of receive antennas.\n- **spatial_corr** (*, **None*)  An instance of [`SpatialCorrelation`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.SpatialCorrelation) or <cite>None</cite>.\nDefaults to <cite>None</cite>.\n- **add_awgn** (*bool*)  Indicates if AWGN noise should be added to the output.\nDefaults to <cite>True</cite>.\n- **return_channel** (*bool*)  Indicates if the channel realizations should be returned.\nDefaults  to <cite>False</cite>.\n- **dtype** (*tf.complex64**, **tf.complex128*)  The dtype of the output. Defaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(x, no)**  Tuple or Tensor:\n- **x** (*[batch_size, num_tx_ant], tf.complex*)  Tensor of transmit vectors.\n- **no** (*Scalar of Tensor, tf.float*)  The noise power `no` is per complex dimension.\nOnly required if `add_awgn==True`.\nWill be broadcast to the dimensions of the channel output if needed.\nFor more details, see [`AWGN`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.AWGN).\n\n\nOutput\n\n- **(y, h)**  Tuple or Tensor:\n- **y** ([batch_size, num_rx_ant, num_tx_ant], `dtype`)  Channel output.\n- **h** ([batch_size, num_rx_ant, num_tx_ant], `dtype`)  Channel realizations. Will only be returned if\n`return_channel==True`.\n\n\n`property` `apply`\n\nCalls the internal [`ApplyFlatFadingChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyFlatFadingChannel).\n\n\n`property` `generate`\n\nCalls the internal [`GenerateFlatFadingChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateFlatFadingChannel).\n\n\n`property` `spatial_corr`\n\nThe [`SpatialCorrelation`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.SpatialCorrelation) to be used."
"### GenerateFlatFadingChannel\n\n`class` `sionna.channel.``GenerateFlatFadingChannel`(*`num_tx_ant`*, *`num_rx_ant`*, *`spatial_corr``=``None`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/channel/flat_fading_channel.html#GenerateFlatFadingChannel)\n\nGenerates tensors of flat-fading channel realizations.\n\nThis class generates batches of random flat-fading channel matrices.\nA spatial correlation can be applied.\nParameters\n\n- **num_tx_ant** (*int*)  Number of transmit antennas.\n- **num_rx_ant** (*int*)  Number of receive antennas.\n- **spatial_corr** (*, **None*)  An instance of [`SpatialCorrelation`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.SpatialCorrelation) or <cite>None</cite>.\nDefaults to <cite>None</cite>.\n- **dtype** (*tf.complex64**, **tf.complex128*)  The dtype of the output. Defaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n**batch_size** (*int*)  The batch size, i.e., the number of channel matrices to generate.\n\nOutput\n\n**h** ([batch_size, num_rx_ant, num_tx_ant], `dtype`)  Batch of random flat fading channel matrices.\n\n\n`property` `spatial_corr`\n\nThe [`SpatialCorrelation`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.SpatialCorrelation) to be used."
"### ApplyFlatFadingChannel\n\n`class` `sionna.channel.``ApplyFlatFadingChannel`(*`add_awgn``=``True`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/channel/flat_fading_channel.html#ApplyFlatFadingChannel)\n\nApplies given channel matrices to a vector input and adds AWGN.\n\nThis class applies a given tensor of flat-fading channel matrices\nto an input tensor. AWGN noise can be optionally added.\nMathematically, for channel matrices\n$\\mathbf{H}\\in\\mathbb{C}^{M\\times K}$\nand input $\\mathbf{x}\\in\\mathbb{C}^{K}$, the output is\n\n$$\n\\mathbf{y} = \\mathbf{H}\\mathbf{x} + \\mathbf{n}\n$$\n\nwhere $\\mathbf{n}\\in\\mathbb{C}^{M}\\sim\\mathcal{CN}(0, N_o\\mathbf{I})$\nis an AWGN vector that is optionally added.\nParameters\n\n- **add_awgn** (*bool*)  Indicates if AWGN noise should be added to the output.\nDefaults to <cite>True</cite>.\n- **dtype** (*tf.complex64**, **tf.complex128*)  The dtype of the output. Defaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(x, h, no)**  Tuple:\n- **x** (*[batch_size, num_tx_ant], tf.complex*)  Tensor of transmit vectors.\n- **h** (*[batch_size, num_rx_ant, num_tx_ant], tf.complex*)  Tensor of channel realizations. Will be broadcast to the\ndimensions of `x` if needed.\n- **no** (*Scalar or Tensor, tf.float*)  The noise power `no` is per complex dimension.\nOnly required if `add_awgn==True`.\nWill be broadcast to the shape of `y`.\nFor more details, see [`AWGN`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.AWGN).\n\n\nOutput\n\n**y** ([batch_size, num_rx_ant, num_tx_ant], `dtype`)  Channel output."
"### SpatialCorrelation\n\n`class` `sionna.channel.``SpatialCorrelation`[`[source]`](../_modules/sionna/channel/spatial_correlation.html#SpatialCorrelation)\n\nAbstract class that defines an interface for spatial correlation functions.\n\nThe [`FlatFadingChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.FlatFadingChannel) model can be configured with a\nspatial correlation model.\nInput\n\n**h** (*tf.complex*)  Tensor of arbitrary shape containing spatially uncorrelated\nchannel coefficients\n\nOutput\n\n**h_corr** (*tf.complex*)  Tensor of the same shape and dtype as `h` containing the spatially\ncorrelated channel coefficients."
"### KroneckerModel\n\n`class` `sionna.channel.``KroneckerModel`(*`r_tx``=``None`*, *`r_rx``=``None`*)[`[source]`](../_modules/sionna/channel/spatial_correlation.html#KroneckerModel)\n\nKronecker model for spatial correlation.\n\nGiven a batch of matrices $\\mathbf{H}\\in\\mathbb{C}^{M\\times K}$,\n$\\mathbf{R}_\\text{tx}\\in\\mathbb{C}^{K\\times K}$, and\n$\\mathbf{R}_\\text{rx}\\in\\mathbb{C}^{M\\times M}$, this function\nwill generate the following output:\n\n$$\n\\mathbf{H}_\\text{corr} = \\mathbf{R}^{\\frac12}_\\text{rx} \\mathbf{H} \\mathbf{R}^{\\frac12}_\\text{tx}\n$$\n\nNote that $\\mathbf{R}_\\text{tx}\\in\\mathbb{C}^{K\\times K}$ and $\\mathbf{R}_\\text{rx}\\in\\mathbb{C}^{M\\times M}$\nmust be positive semi-definite, such as the ones generated by\n[`exp_corr_mat()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.exp_corr_mat).\nParameters\n\n- **r_tx** (*[**...**, **K**, **K**]**, **tf.complex*)  Tensor containing the transmit correlation matrices. If\nthe rank of `r_tx` is smaller than that of the input `h`,\nit will be broadcast.\n- **r_rx** (*[**...**, **M**, **M**]**, **tf.complex*)  Tensor containing the receive correlation matrices. If\nthe rank of `r_rx` is smaller than that of the input `h`,\nit will be broadcast.\n\n\nInput\n\n**h** (*[, M, K], tf.complex*)  Tensor containing spatially uncorrelated\nchannel coeffficients.\n\nOutput\n\n**h_corr** (*[, M, K], tf.complex*)  Tensor containing the spatially\ncorrelated channel coefficients.\n\n\n`property` `r_rx`\n\nTensor containing the receive correlation matrices.\n\n**Note**\n\nIf you want to set this property in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat).\n\n\n`property` `r_tx`\n\nTensor containing the transmit correlation matrices.\n\n**Note**\n\nIf you want to set this property in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### PerColumnModel\n\n`class` `sionna.channel.``PerColumnModel`(*`r_rx`*)[`[source]`](../_modules/sionna/channel/spatial_correlation.html#PerColumnModel)\n\nPer-column model for spatial correlation.\n\nGiven a batch of matrices $\\mathbf{H}\\in\\mathbb{C}^{M\\times K}$\nand correlation matrices $\\mathbf{R}_k\\in\\mathbb{C}^{M\\times M}, k=1,\\dots,K$,\nthis function will generate the output $\\mathbf{H}_\\text{corr}\\in\\mathbb{C}^{M\\times K}$,\nwith columns\n\n$$\n\\mathbf{h}^\\text{corr}_k = \\mathbf{R}^{\\frac12}_k \\mathbf{h}_k,\\quad k=1, \\dots, K\n$$\n\nwhere $\\mathbf{h}_k$ is the kth column of $\\mathbf{H}$.\nNote that all $\\mathbf{R}_k\\in\\mathbb{C}^{M\\times M}$ must\nbe positive semi-definite, such as the ones generated\nby [`one_ring_corr_mat()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.one_ring_corr_mat).\n\nThis model is typically used to simulate a MIMO channel between multiple\nsingle-antenna users and a base station with multiple antennas.\nThe resulting SIMO channel for each user has a different spatial correlation.\nParameters\n\n**r_rx** (*[**...**, **M**, **M**]**, **tf.complex*)  Tensor containing the receive correlation matrices. If\nthe rank of `r_rx` is smaller than that of the input `h`,\nit will be broadcast. For a typically use of this model, `r_rx`\nhas shape [, K, M, M], i.e., a different correlation matrix for each\ncolumn of `h`.\n\nInput\n\n**h** (*[, M, K], tf.complex*)  Tensor containing spatially uncorrelated\nchannel coeffficients.\n\nOutput\n\n**h_corr** (*[, M, K], tf.complex*)  Tensor containing the spatially\ncorrelated channel coefficients.\n\n\n`property` `r_rx`\n\nTensor containing the receive correlation matrices.\n\n**Note**\n\nIf you want to set this property in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"## Channel model interface\n\n`class` `sionna.channel.``ChannelModel`[`[source]`](../_modules/sionna/channel/channel_model.html#ChannelModel)\n\nAbstract class that defines an interface for channel models.\n\nAny channel model which generates channel impulse responses must implement this interface.\nAll the channel models available in Sionna, such as [`RayleighBlockFading`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.RayleighBlockFading) or [`TDL`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.TDL), implement this interface.\n\n*Remark:* Some channel models only require a subset of the input parameters.\nInput\n\n- **batch_size** (*int*)  Batch size\n- **num_time_steps** (*int*)  Number of time steps\n- **sampling_frequency** (*float*)  Sampling frequency [Hz]\n\n\nOutput\n\n- **a** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx, num_tx, num_paths], tf.float*)  Path delays [s]"
"## Time domain channel\n\nThe model of the channel in the time domain assumes pulse shaping and receive\nfiltering are performed using a conventional sinc filter (see, e.g., [[Tse]](../em_primer.html#tse)).\nUsing sinc for transmit and receive filtering, the discrete-time domain received\nsignal at time step $b$ is\n\n$$\ny_{v, l, b} = \\sum_{u=0}^{N_{T}-1}\\sum_{k=0}^{N_{TA}-1}\n   \\sum_{\\ell = L_{\\text{min}}}^{L_{\\text{max}}}\n   \\bar{h}_{u, k, v, l, b, \\ell} x_{u, k, b-\\ell}\n   + w_{v, l, b}\n$$\n\nwhere $x_{u, k, b}$ is the baseband symbol transmitted by transmitter\n$u$ on antenna $k$ and at time step $b$,\n$w_{v, l, b} \\sim \\mathcal{CN}\\left(0,N_0\\right)$ the additive white\nGaussian noise, and $\\bar{h}_{u, k, v, l, b, \\ell}$ the channel filter tap\nat time step $b$ and for time-lag $\\ell$, which is given by\n\n$$\n\\bar{h}_{u, k, v, l, b, \\ell}\n= \\sum_{m=0}^{M-1} a_{u, k, v, l, m}\\left(\\frac{b}{W}\\right)\n   \\text{sinc}\\left( \\ell - W\\tau_{u, v, m} \\right).\n$$\n\n**Note**\n\nThe two parameters $L_{\\text{min}}$ and $L_{\\text{max}}$ control the smallest\nand largest time-lag for the discrete-time channel model, respectively.\nThey are set when instantiating [`TimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.TimeChannel),\n[`GenerateTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateTimeChannel), and when calling the utility\nfunction [`cir_to_time_channel()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.cir_to_time_channel).\nBecause the sinc filter is neither time-limited nor causal, the discrete-time\nchannel model is not causal. Therefore, ideally, one would set\n$L_{\\text{min}} = -\\infty$ and $L_{\\text{max}} = +\\infty$.\nIn practice, however, these two parameters need to be set to reasonable\nfinite values. Values for these two parameters can be computed using the\n[`time_lag_discrete_time_channel()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.time_lag_discrete_time_channel) utility function from\na given bandwidth and maximum delay spread.\nThis function returns $-6$ for $L_{\\text{min}}$. $L_{\\text{max}}$ is computed\nfrom the specified bandwidth and maximum delay spread, which default value is\n$3 \\mu s$. These values for $L_{\\text{min}}$ and the maximum delay spread\nwere found to be valid for all the models available in Sionna when an RMS delay\nspread of 100ns is assumed."
"### TimeChannel\n\n`class` `sionna.channel.``TimeChannel`(*`channel_model`*, *`bandwidth`*, *`num_time_samples`*, *`maximum_delay_spread``=``3e-6`*, *`l_min``=``None`*, *`l_max``=``None`*, *`normalize_channel``=``False`*, *`add_awgn``=``True`*, *`return_channel``=``False`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/channel/time_channel.html#TimeChannel)\n\nGenerate channel responses and apply them to channel inputs in the time domain.\n\nThis class inherits from the Keras <cite>Layer</cite> class and can be used as layer\nin a Keras model.\n\nThe channel output consists of `num_time_samples` + `l_max` - `l_min`\ntime samples, as it is the result of filtering the channel input of length\n`num_time_samples` with the time-variant channel filter  of length\n`l_max` - `l_min` + 1. In the case of a single-input single-output link and given a sequence of channel\ninputs $x_0,\\cdots,x_{N_B}$, where $N_B$ is `num_time_samples`, this\nlayer outputs\n\n$$\ny_b = \\sum_{\\ell = L_{\\text{min}}}^{L_{\\text{max}}} x_{b-\\ell} \\bar{h}_{b,\\ell} + w_b\n$$\n\nwhere $L_{\\text{min}}$ corresponds `l_min`, $L_{\\text{max}}$ to `l_max`, $w_b$ to\nthe additive noise, and $\\bar{h}_{b,\\ell}$ to the\n$\\ell^{th}$ tap of the $b^{th}$ channel sample.\nThis layer outputs $y_b$ for $b$ ranging from $L_{\\text{min}}$ to\n$N_B + L_{\\text{max}} - 1$, and $x_{b}$ is set to 0 for $b < 0$ or $b \\geq N_B$.\nThe channel taps $\\bar{h}_{b,\\ell}$ are computed assuming a sinc filter\nis used for pulse shaping and receive filtering. Therefore, given a channel impulse response\n$(a_{m}(t), \\tau_{m}), 0 \\leq m \\leq M-1$, generated by the `channel_model`,\nthe channel taps are computed as follows:\n\n$$\n\\bar{h}_{b, \\ell}\n= \\sum_{m=0}^{M-1} a_{m}\\left(\\frac{b}{W}\\right)\n    \\text{sinc}\\left( \\ell - W\\tau_{m} \\right)\n$$\n\nfor $\\ell$ ranging from `l_min` to `l_max`, and where $W$ is\nthe `bandwidth`.\n\nFor multiple-input multiple-output (MIMO) links, the channel output is computed for each antenna of each receiver and by summing over all the antennas of all transmitters.\nParameters\n\n- **channel_model** ([`ChannelModel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ChannelModel) object)  An instance of a [`ChannelModel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ChannelModel), such as\n[`RayleighBlockFading`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.RayleighBlockFading) or\n[`UMi`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMi).\n- **bandwidth** (*float*)  Bandwidth ($W$) [Hz]\n- **num_time_samples** (*int*)  Number of time samples forming the channel input ($N_B$)\n- **maximum_delay_spread** (*float*)  Maximum delay spread [s].\nUsed to compute the default value of `l_max` if `l_max` is set to\n<cite>None</cite>. If a value is given for `l_max`, this parameter is not used.\nIt defaults to 3us, which was found\nto be large enough to include most significant paths with all channel\nmodels included in Sionna assuming a nominal delay spread of 100ns.\n- **l_min** (*int*)  Smallest time-lag for the discrete complex baseband channel ($L_{\\text{min}}$).\nIf set to <cite>None</cite>, defaults to the value given by [`time_lag_discrete_time_channel()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.time_lag_discrete_time_channel).\n- **l_max** (*int*)  Largest time-lag for the discrete complex baseband channel ($L_{\\text{max}}$).\nIf set to <cite>None</cite>, it is computed from `bandwidth` and `maximum_delay_spread`\nusing [`time_lag_discrete_time_channel()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.time_lag_discrete_time_channel). If it is not set to <cite>None</cite>,\nthen the parameter `maximum_delay_spread` is not used.\n- **add_awgn** (*bool*)  If set to <cite>False</cite>, no white Gaussian noise is added.\nDefaults to <cite>True</cite>.\n- **normalize_channel** (*bool*)  If set to <cite>True</cite>, the channel is normalized over the block size\nto ensure unit average energy per time step. Defaults to <cite>False</cite>.\n- **return_channel** (*bool*)  If set to <cite>True</cite>, the channel response is returned in addition to the\nchannel output. Defaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  Complex datatype to use for internal processing and output.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(x, no) or x**  Tuple or Tensor:\n- **x** (*[batch size, num_tx, num_tx_ant, num_time_samples], tf.complex*)  Channel inputs\n- **no** (*Scalar or Tensor, tf.float*)  Scalar or tensor whose shape can be broadcast to the shape of the\nchannel outputs: [batch size, num_rx, num_rx_ant, num_time_samples].\nOnly required if `add_awgn` is set to <cite>True</cite>.\nThe noise power `no` is per complex dimension. If `no` is a scalar,\nnoise of the same variance will be added to the outputs.\nIf `no` is a tensor, it must have a shape that can be broadcast to\nthe shape of the channel outputs. This allows, e.g., adding noise of\ndifferent variance to each example in a batch. If `no` has a lower\nrank than the channel outputs, then `no` will be broadcast to the\nshape of the channel outputs by adding dummy dimensions after the last\naxis.\n\n\nOutput\n\n- **y** (*[batch size, num_rx, num_rx_ant, num_time_samples + l_max - l_min], tf.complex*)  Channel outputs\nThe channel output consists of `num_time_samples` + `l_max` - `l_min`\ntime samples, as it is the result of filtering the channel input of length\n`num_time_samples` with the time-variant channel filter  of length\n`l_max` - `l_min` + 1.\n- **h_time** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_time_samples + l_max - l_min, l_max - l_min + 1], tf.complex*)  (Optional) Channel responses. Returned only if `return_channel`\nis set to <cite>True</cite>.\nFor each batch example, `num_time_samples` + `l_max` - `l_min` time\nsteps of the channel realizations are generated to filter the channel input."
"### GenerateTimeChannel\n\n`class` `sionna.channel.``GenerateTimeChannel`(*`channel_model`*, *`bandwidth`*, *`num_time_samples`*, *`l_min`*, *`l_max`*, *`normalize_channel``=``False`*)[`[source]`](../_modules/sionna/channel/generate_time_channel.html#GenerateTimeChannel)\n\nGenerate channel responses in the time domain.\n\nFor each batch example, `num_time_samples` + `l_max` - `l_min` time steps of a\nchannel realization are generated by this layer.\nThese can be used to filter a channel input of length `num_time_samples` using the\n[`ApplyTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyTimeChannel) layer.\n\nThe channel taps $\\bar{h}_{b,\\ell}$ (`h_time`) returned by this layer\nare computed assuming a sinc filter is used for pulse shaping and receive filtering.\nTherefore, given a channel impulse response\n$(a_{m}(t), \\tau_{m}), 0 \\leq m \\leq M-1$, generated by the `channel_model`,\nthe channel taps are computed as follows:\n\n$$\n\\bar{h}_{b, \\ell}\n= \\sum_{m=0}^{M-1} a_{m}\\left(\\frac{b}{W}\\right)\n    \\text{sinc}\\left( \\ell - W\\tau_{m} \\right)\n$$\n\nfor $\\ell$ ranging from `l_min` to `l_max`, and where $W$ is\nthe `bandwidth`.\nParameters\n\n- **channel_model** ([`ChannelModel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ChannelModel) object)  An instance of a [`ChannelModel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ChannelModel), such as\n[`RayleighBlockFading`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.RayleighBlockFading) or\n[`UMi`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMi).\n- **bandwidth** (*float*)  Bandwidth ($W$) [Hz]\n- **num_time_samples** (*int*)  Number of time samples forming the channel input ($N_B$)\n- **l_min** (*int*)  Smallest time-lag for the discrete complex baseband channel ($L_{\\text{min}}$)\n- **l_max** (*int*)  Largest time-lag for the discrete complex baseband channel ($L_{\\text{max}}$)\n- **normalize_channel** (*bool*)  If set to <cite>True</cite>, the channel is normalized over the block size\nto ensure unit average energy per time step. Defaults to <cite>False</cite>.\n\n\nInput\n\n**batch_size** (*int*)  Batch size. Defaults to <cite>None</cite> for channel models that do not require this paranmeter.\n\nOutput\n\n**h_time** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_time_samples + l_max - l_min, l_max - l_min + 1], tf.complex*)  Channel responses.\nFor each batch example, `num_time_samples` + `l_max` - `l_min` time steps of a\nchannel realization are generated by this layer.\nThese can be used to filter a channel input of length `num_time_samples` using the\n[`ApplyTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyTimeChannel) layer."
"### ApplyTimeChannel\n\n`class` `sionna.channel.``ApplyTimeChannel`(*`num_time_samples`*, *`l_tot`*, *`add_awgn``=``True`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/channel/apply_time_channel.html#ApplyTimeChannel)\n\nApply time domain channel responses `h_time` to channel inputs `x`,\nby filtering the channel inputs with time-variant channel responses.\n\nThis class inherits from the Keras <cite>Layer</cite> class and can be used as layer\nin a Keras model.\n\nFor each batch example, `num_time_samples` + `l_tot` - 1 time steps of a\nchannel realization are required to filter the channel inputs.\n\nThe channel output consists of `num_time_samples` + `l_tot` - 1\ntime samples, as it is the result of filtering the channel input of length\n`num_time_samples` with the time-variant channel filter  of length\n`l_tot`. In the case of a single-input single-output link and given a sequence of channel\ninputs $x_0,\\cdots,x_{N_B}$, where $N_B$ is `num_time_samples`, this\nlayer outputs\n\n$$\ny_b = \\sum_{\\ell = 0}^{L_{\\text{tot}}} x_{b-\\ell} \\bar{h}_{b,\\ell} + w_b\n$$\n\nwhere $L_{\\text{tot}}$ corresponds `l_tot`, $w_b$ to the additive noise, and\n$\\bar{h}_{b,\\ell}$ to the $\\ell^{th}$ tap of the $b^{th}$ channel sample.\nThis layer outputs $y_b$ for $b$ ranging from 0 to\n$N_B + L_{\\text{tot}} - 1$, and $x_{b}$ is set to 0 for $b \\geq N_B$.\n\nFor multiple-input multiple-output (MIMO) links, the channel output is computed for each antenna\nof each receiver and by summing over all the antennas of all transmitters.\nParameters\n\n- **num_time_samples** (*int*)  Number of time samples forming the channel input ($N_B$)\n- **l_tot** (*int*)  Length of the channel filter ($L_{\\text{tot}} = L_{\\text{max}} - L_{\\text{min}} + 1$)\n- **add_awgn** (*bool*)  If set to <cite>False</cite>, no white Gaussian noise is added.\nDefaults to <cite>True</cite>.\n- **dtype** (*tf.DType*)  Complex datatype to use for internal processing and output.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(x, h_time, no) or (x, h_time)**  Tuple:\n- **x** (*[batch size, num_tx, num_tx_ant, num_time_samples], tf.complex*)  Channel inputs\n- **h_time** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_time_samples + l_tot - 1, l_tot], tf.complex*)  Channel responses.\nFor each batch example, `num_time_samples` + `l_tot` - 1 time steps of a\nchannel realization are required to filter the channel inputs.\n- **no** (*Scalar or Tensor, tf.float*)  Scalar or tensor whose shape can be broadcast to the shape of the channel outputs: [batch size, num_rx, num_rx_ant, num_time_samples + l_tot - 1].\nOnly required if `add_awgn` is set to <cite>True</cite>.\nThe noise power `no` is per complex dimension. If `no` is a\nscalar, noise of the same variance will be added to the outputs.\nIf `no` is a tensor, it must have a shape that can be broadcast to\nthe shape of the channel outputs. This allows, e.g., adding noise of\ndifferent variance to each example in a batch. If `no` has a lower\nrank than the channel outputs, then `no` will be broadcast to the\nshape of the channel outputs by adding dummy dimensions after the\nlast axis.\n\n\nOutput\n\n**y** (*[batch size, num_rx, num_rx_ant, num_time_samples + l_tot - 1], tf.complex*)  Channel outputs.\nThe channel output consists of `num_time_samples` + `l_tot` - 1\ntime samples, as it is the result of filtering the channel input of length\n`num_time_samples` with the time-variant channel filter  of length\n`l_tot`."
"### cir_to_time_channel\n\n`sionna.channel.``cir_to_time_channel`(*`bandwidth`*, *`a`*, *`tau`*, *`l_min`*, *`l_max`*, *`normalize``=``False`*)[`[source]`](../_modules/sionna/channel/utils.html#cir_to_time_channel)\n\nCompute the channel taps forming the discrete complex-baseband\nrepresentation of the channel from the channel impulse response\n(`a`, `tau`).\n\nThis function assumes that a sinc filter is used for pulse shaping and receive\nfiltering. Therefore, given a channel impulse response\n$(a_{m}(t), \\tau_{m}), 0 \\leq m \\leq M-1$, the channel taps\nare computed as follows:\n\n$$\n\\bar{h}_{b, \\ell}\n= \\sum_{m=0}^{M-1} a_{m}\\left(\\frac{b}{W}\\right)\n    \\text{sinc}\\left( \\ell - W\\tau_{m} \\right)\n$$\n\nfor $\\ell$ ranging from `l_min` to `l_max`, and where $W$ is\nthe `bandwidth`.\nInput\n\n- **bandwidth** (*float*)  Bandwidth [Hz]\n- **a** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx, num_tx, num_paths] or [batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths], tf.float*)  Path delays [s]\n- **l_min** (*int*)  Smallest time-lag for the discrete complex baseband channel ($L_{\\text{min}}$)\n- **l_max** (*int*)  Largest time-lag for the discrete complex baseband channel ($L_{\\text{max}}$)\n- **normalize** (*bool*)  If set to <cite>True</cite>, the channel is normalized over the block size\nto ensure unit average energy per time step. Defaults to <cite>False</cite>.\n\n\nOutput\n\n**hm** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_time_steps, l_max - l_min + 1], tf.complex*)  Channel taps coefficients"
"### time_to_ofdm_channel\n\n`sionna.channel.``time_to_ofdm_channel`(*`h_t`*, *`rg`*, *`l_min`*)[`[source]`](../_modules/sionna/channel/utils.html#time_to_ofdm_channel)\n\nCompute the channel frequency response from the discrete complex-baseband\nchannel impulse response.\n\nGiven a discrete complex-baseband channel impulse response\n$\\bar{h}_{b,\\ell}$, for $\\ell$ ranging from $L_\\text{min}\\le 0$\nto $L_\\text{max}$, the discrete channel frequency response is computed as\n\n$$\n\\hat{h}_{b,n} = \\sum_{k=0}^{L_\\text{max}} \\bar{h}_{b,k} e^{-j \\frac{2\\pi kn}{N}} + \\sum_{k=L_\\text{min}}^{-1} \\bar{h}_{b,k} e^{-j \\frac{2\\pi n(N+k)}{N}}, \\quad n=0,\\dots,N-1\n$$\n\nwhere $N$ is the FFT size and $b$ is the time step.\n\nThis function only produces one channel frequency response per OFDM symbol, i.e.,\nonly values of $b$ corresponding to the start of an OFDM symbol (after\ncyclic prefix removal) are considered.\nInput\n\n- **h_t** (*[num_time_steps,l_max-l_min+1], tf.complex*)  Tensor of discrete complex-baseband channel impulse responses\n- **resource_grid** ([`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid))  Resource grid\n- **l_min** (*int*)  Smallest time-lag for the discrete complex baseband\nchannel impulse response ($L_{\\text{min}}$)\n\n\nOutput\n\n**h_f** (*[,num_ofdm_symbols,fft_size], tf.complex*)  Tensor of discrete complex-baseband channel frequency responses\n\n\n**Note**\n\nNote that the result of this function is generally different from the\noutput of `cir_to_ofdm_channel()` because\nthe discrete complex-baseband channel impulse response is truncated\n(see `cir_to_time_channel()`). This effect\ncan be observed in the example below.\n xamples\n```python\n# Setup resource grid and channel model\ntf.random.set_seed(4)\nsm = StreamManagement(np.array([[1]]), 1)\nrg = ResourceGrid(num_ofdm_symbols=1,\n                  fft_size=1024,\n                  subcarrier_spacing=15e3)\ntdl = TDL(\"A\", 100e-9, 3.5e9)\n# Generate CIR\ncir = tdl(batch_size=1, num_time_steps=1, sampling_frequency=rg.bandwidth)\n# Generate OFDM channel from CIR\nfrequencies = subcarrier_frequencies(rg.fft_size, rg.subcarrier_spacing)\nh_freq = tf.squeeze(cir_to_ofdm_channel(frequencies, *cir, normalize=True))\n# Generate time channel from CIR\nl_min, l_max = time_lag_discrete_time_channel(rg.bandwidth)\nh_time = cir_to_time_channel(rg.bandwidth, *cir, l_min=l_min, l_max=l_max, normalize=True)\n# Generate OFDM channel from time channel\nh_freq_hat = tf.squeeze(time_to_ofdm_channel(h_time, rg, l_min))\n# Visualize results\nplt.figure()\nplt.plot(np.real(h_freq), \"-\")\nplt.plot(np.real(h_freq_hat), \"--\")\nplt.plot(np.imag(h_freq), \"-\")\nplt.plot(np.imag(h_freq_hat), \"--\")\nplt.xlabel(\"Subcarrier index\")\nplt.ylabel(r\"Channel frequency response\")\nplt.legend([\"OFDM Channel (real)\", \"OFDM Channel from time (real)\", \"OFDM Channel (imag)\", \"OFDM Channel from time (imag)\"])\n```"
"## Channel with OFDM waveform\n\nTo implement the channel response assuming an OFDM waveform, it is assumed that\nthe power delay profiles are invariant over the duration of an OFDM symbol.\nMoreover, it is assumed that the duration of the cyclic prefix (CP) equals at\nleast the maximum delay spread. These assumptions are common in the literature, as they\nenable modeling of the channel transfer function in the frequency domain as a\nsingle-tap channel.\n\nFor every link $(u, k, v, l)$ and resource element $(s,n)$,\nthe frequency channel response is obtained by computing the Fourier transform of\nthe channel response at the subcarrier frequencies, i.e.,\n\n$$\n\\begin{split}\\begin{align}\n\\widehat{h}_{u, k, v, l, s, n}\n   &= \\int_{-\\infty}^{+\\infty} h_{u, k, v, l}(s,\\tau) e^{-j2\\pi n \\Delta_f \\tau} d\\tau\\\\\n   &= \\sum_{m=0}^{M-1} a_{u, k, v, l, m}(s)\n   e^{-j2\\pi n \\Delta_f \\tau_{u, k, v, l, m}}\n\\end{align}\\end{split}\n$$\n\nwhere $s$ is used as time step to indicate that the channel response can\nchange from one OFDM symbol to the next in the event of mobility, even if it is\nassumed static over the duration of an OFDM symbol.\n\nFor every receive antenna $l$ of every receiver $v$, the\nreceived signal $y_{v, l, s, n}$ for resource element\n$(s, n)$ is computed by\n\n$$\ny_{v, l, s, n} = \\sum_{u=0}^{N_{T}-1}\\sum_{k=0}^{N_{TA}-1}\n   \\widehat{h}_{u, k, v, l, s, n} x_{u, k, s, n}\n   + w_{v, l, s, n}\n$$\n\nwhere $x_{u, k, s, n}$ is the baseband symbol transmitted by transmitter\n$u$ on antenna $k$ and resource element $(s, n)$, and\n$w_{v, l, s, n} \\sim \\mathcal{CN}\\left(0,N_0\\right)$ the additive white\nGaussian noise.\n\n**Note**\n\nThis model does not account for intersymbol interference (ISI) nor\nintercarrier interference (ICI). To model the ICI due to channel aging over\nthe duration of an OFDM symbol or the ISI due to a delay spread exceeding the\nCP duration, one would need to simulate the channel in the time domain.\nThis can be achieved by using the [`OFDMModulator`](ofdm.html#sionna.ofdm.OFDMModulator) and\n[`OFDMDemodulator`](ofdm.html#sionna.ofdm.OFDMDemodulator) layers, and the\n[time domain channel model](https://nvlabs.github.io/sionna/api/channel.wireless.html#time-domain).\nBy doing so, one performs inverse discrete Fourier transform (IDFT) on\nthe transmitter side and discrete Fourier transform (DFT) on the receiver side\non top of a single-carrier sinc-shaped waveform.\nThis is equivalent to\n[simulating the channel in the frequency domain](https://nvlabs.github.io/sionna/api/channel.wireless.html#ofdm-waveform) if no\nISI nor ICI is assumed, but allows the simulation of these effects in the\nevent of a non-stationary channel or long delay spreads.\nNote that simulating the channel in the time domain is typically significantly\nmore computationally demanding that simulating the channel in the frequency\ndomain."
"### OFDMChannel\n\n`class` `sionna.channel.``OFDMChannel`(*`channel_model`*, *`resource_grid`*, *`add_awgn``=``True`*, *`normalize_channel``=``False`*, *`return_channel``=``False`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/channel/ofdm_channel.html#OFDMChannel)\n\nGenerate channel frequency responses and apply them to channel inputs\nassuming an OFDM waveform with no ICI nor ISI.\n\nThis class inherits from the Keras <cite>Layer</cite> class and can be used as layer\nin a Keras model.\n\nFor each OFDM symbol $s$ and subcarrier $n$, the channel output is computed as follows:\n\n$$\ny_{s,n} = \\widehat{h}_{s, n} x_{s,n} + w_{s,n}\n$$\n\nwhere $y_{s,n}$ is the channel output computed by this layer,\n$\\widehat{h}_{s, n}$ the frequency channel response,\n$x_{s,n}$ the channel input `x`, and $w_{s,n}$ the additive noise.\n\nFor multiple-input multiple-output (MIMO) links, the channel output is computed for each antenna\nof each receiver and by summing over all the antennas of all transmitters.\n\nThe channel frequency response for the $s^{th}$ OFDM symbol and\n$n^{th}$ subcarrier is computed from a given channel impulse response\n$(a_{m}(t), \\tau_{m}), 0 \\leq m \\leq M-1$ generated by the `channel_model`\nas follows:\n\n$$\n\\widehat{h}_{s, n} = \\sum_{m=0}^{M-1} a_{m}(s) e^{-j2\\pi n \\Delta_f \\tau_{m}}\n$$\n\nwhere $\\Delta_f$ is the subcarrier spacing, and $s$ is used as time\nstep to indicate that the channel impulse response can change from one OFDM symbol to the\nnext in the event of mobility, even if it is assumed static over the duration\nof an OFDM symbol.\nParameters\n\n- **channel_model** ([`ChannelModel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ChannelModel) object)  An instance of a [`ChannelModel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ChannelModel) object, such as\n[`RayleighBlockFading`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.RayleighBlockFading) or\n[`UMi`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMi).\n- **resource_grid** ([`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid))  Resource grid\n- **add_awgn** (*bool*)  If set to <cite>False</cite>, no white Gaussian noise is added.\nDefaults to <cite>True</cite>.\n- **normalize_channel** (*bool*)  If set to <cite>True</cite>, the channel is normalized over the resource grid\nto ensure unit average energy per resource element. Defaults to <cite>False</cite>.\n- **return_channel** (*bool*)  If set to <cite>True</cite>, the channel response is returned in addition to the\nchannel output. Defaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  Complex datatype to use for internal processing and output.\nDefaults to tf.complex64.\n\n\nInput\n\n- **(x, no) or x**  Tuple or Tensor:\n- **x** (*[batch size, num_tx, num_tx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Channel inputs\n- **no** (*Scalar or Tensor, tf.float*)  Scalar or tensor whose shape can be broadcast to the shape of the\nchannel outputs:\n[batch size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size].\nOnly required if `add_awgn` is set to <cite>True</cite>.\nThe noise power `no` is per complex dimension. If `no` is a scalar,\nnoise of the same variance will be added to the outputs.\nIf `no` is a tensor, it must have a shape that can be broadcast to\nthe shape of the channel outputs. This allows, e.g., adding noise of\ndifferent variance to each example in a batch. If `no` has a lower\nrank than the channel outputs, then `no` will be broadcast to the\nshape of the channel outputs by adding dummy dimensions after the last\naxis.\n\n\nOutput\n\n- **y** (*[batch size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Channel outputs\n- **h_freq** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_ofdm_symbols, fft_size], tf.complex*)  (Optional) Channel frequency responses. Returned only if\n`return_channel` is set to <cite>True</cite>."
"### GenerateOFDMChannel\n\n`class` `sionna.channel.``GenerateOFDMChannel`(*`channel_model`*, *`resource_grid`*, *`normalize_channel``=``False`*)[`[source]`](../_modules/sionna/channel/generate_ofdm_channel.html#GenerateOFDMChannel)\n\nGenerate channel frequency responses.\nThe channel impulse response is constant over the duration of an OFDM symbol.\n\nGiven a channel impulse response\n$(a_{m}(t), \\tau_{m}), 0 \\leq m \\leq M-1$, generated by the `channel_model`,\nthe channel frequency response for the $s^{th}$ OFDM symbol and\n$n^{th}$ subcarrier is computed as follows:\n\n$$\n\\widehat{h}_{s, n} = \\sum_{m=0}^{M-1} a_{m}(s) e^{-j2\\pi n \\Delta_f \\tau_{m}}\n$$\n\nwhere $\\Delta_f$ is the subcarrier spacing, and $s$ is used as time\nstep to indicate that the channel impulse response can change from one OFDM symbol to the\nnext in the event of mobility, even if it is assumed static over the duration\nof an OFDM symbol.\nParameters\n\n- **channel_model** ([`ChannelModel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ChannelModel) object)  An instance of a [`ChannelModel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ChannelModel) object, such as\n[`RayleighBlockFading`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.RayleighBlockFading) or\n[`UMi`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMi).\n- **resource_grid** ([`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid))  Resource grid\n- **normalize_channel** (*bool*)  If set to <cite>True</cite>, the channel is normalized over the resource grid\nto ensure unit average energy per resource element. Defaults to <cite>False</cite>.\n- **dtype** (*tf.DType*)  Complex datatype to use for internal processing and output.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n**batch_size** (*int*)  Batch size. Defaults to <cite>None</cite> for channel models that do not require this paranmeter.\n\nOutput\n\n**h_freq** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_ofdm_symbols, num_subcarriers], tf.complex*)  Channel frequency responses"
"### ApplyOFDMChannel\n\n`class` `sionna.channel.``ApplyOFDMChannel`(*`add_awgn``=``True`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/channel/apply_ofdm_channel.html#ApplyOFDMChannel)\n\nApply single-tap channel frequency responses to channel inputs.\n\nThis class inherits from the Keras <cite>Layer</cite> class and can be used as layer\nin a Keras model.\n\nFor each OFDM symbol $s$ and subcarrier $n$, the single-tap channel\nis applied as follows:\n\n$$\ny_{s,n} = \\widehat{h}_{s, n} x_{s,n} + w_{s,n}\n$$\n\nwhere $y_{s,n}$ is the channel output computed by this layer,\n$\\widehat{h}_{s, n}$ the frequency channel response (`h_freq`),\n$x_{s,n}$ the channel input `x`, and $w_{s,n}$ the additive noise.\n\nFor multiple-input multiple-output (MIMO) links, the channel output is computed for each antenna\nof each receiver and by summing over all the antennas of all transmitters.\nParameters\n\n- **add_awgn** (*bool*)  If set to <cite>False</cite>, no white Gaussian noise is added.\nDefaults to <cite>True</cite>.\n- **dtype** (*tf.DType*)  Complex datatype to use for internal processing and output. Defaults to\n<cite>tf.complex64</cite>.\n\n\nInput\n\n- **(x, h_freq, no) or (x, h_freq)**  Tuple:\n- **x** (*[batch size, num_tx, num_tx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Channel inputs\n- **h_freq** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Channel frequency responses\n- **no** (*Scalar or Tensor, tf.float*)  Scalar or tensor whose shape can be broadcast to the shape of the\nchannel outputs:\n[batch size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size].\nOnly required if `add_awgn` is set to <cite>True</cite>.\nThe noise power `no` is per complex dimension. If `no` is a\nscalar, noise of the same variance will be added to the outputs.\nIf `no` is a tensor, it must have a shape that can be broadcast to\nthe shape of the channel outputs. This allows, e.g., adding noise of\ndifferent variance to each example in a batch. If `no` has a lower\nrank than the channel outputs, then `no` will be broadcast to the\nshape of the channel outputs by adding dummy dimensions after the\nlast axis.\n\n\nOutput\n\n**y** (*[batch size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Channel outputs"
"### cir_to_ofdm_channel\n\n`sionna.channel.``cir_to_ofdm_channel`(*`frequencies`*, *`a`*, *`tau`*, *`normalize``=``False`*)[`[source]`](../_modules/sionna/channel/utils.html#cir_to_ofdm_channel)\n\nCompute the frequency response of the channel at `frequencies`.\n\nGiven a channel impulse response\n$(a_{m}, \\tau_{m}), 0 \\leq m \\leq M-1$ (inputs `a` and `tau`),\nthe channel frequency response for the frequency $f$\nis computed as follows:\n\n$$\n\\widehat{h}(f) = \\sum_{m=0}^{M-1} a_{m} e^{-j2\\pi f \\tau_{m}}\n$$\n\nInput\n\n- **frequencies** (*[fft_size], tf.float*)  Frequencies at which to compute the channel response\n- **a** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx, num_tx, num_paths] or [batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths], tf.float*)  Path delays\n- **normalize** (*bool*)  If set to <cite>True</cite>, the channel is normalized over the resource grid\nto ensure unit average energy per resource element. Defaults to <cite>False</cite>.\n\n\nOutput\n\n**h_f** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_time_steps, fft_size], tf.complex*)  Channel frequency responses at `frequencies`"
"## Rayleigh block fading\n\n`class` `sionna.channel.``RayleighBlockFading`(*`num_rx`*, *`num_rx_ant`*, *`num_tx`*, *`num_tx_ant`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/rayleigh_block_fading.html#RayleighBlockFading)\n\nGenerate channel impulse responses corresponding to a Rayleigh block\nfading channel model.\n\nThe channel impulse responses generated are formed of a single path with\nzero delay and a normally distributed fading coefficient.\nAll time steps of a batch example share the same channel coefficient\n(block fading).\n\nThis class can be used in conjunction with the classes that simulate the\nchannel response in time or frequency domain, i.e.,\n[`OFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.OFDMChannel),\n[`TimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.TimeChannel),\n[`GenerateOFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateOFDMChannel),\n[`ApplyOFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyOFDMChannel),\n[`GenerateTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.GenerateTimeChannel),\n[`ApplyTimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.ApplyTimeChannel).\nParameters\n\n- **num_rx** (*int*)  Number of receivers ($N_R$)\n- **num_rx_ant** (*int*)  Number of antennas per receiver ($N_{RA}$)\n- **num_tx** (*int*)  Number of transmitters ($N_T$)\n- **num_tx_ant** (*int*)  Number of antennas per transmitter ($N_{TA}$)\n- **dtype** (*tf.DType*)  Complex datatype to use for internal processing and output.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **batch_size** (*int*)  Batch size\n- **num_time_steps** (*int*)  Number of time steps\n\n\nOutput\n\n- **a** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths = 1, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx, num_tx, num_paths = 1], tf.float*)  Path delays [s]"
"## 3GPP 38.901 channel models\n\nThe submodule `tr38901` implements 3GPP channel models from [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901).\n\nThe [CDL](https://nvlabs.github.io/sionna/api/channel.wireless.html#cdl), [UMi](https://nvlabs.github.io/sionna/api/channel.wireless.html#umi), [UMa](https://nvlabs.github.io/sionna/api/channel.wireless.html#uma), and [RMa](https://nvlabs.github.io/sionna/api/channel.wireless.html#rma)\nmodels require setting-up antenna models for the transmitters and\nreceivers. This is achieved using the\n[`PanelArray`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.PanelArray) class.\n\nThe [UMi](https://nvlabs.github.io/sionna/api/channel.wireless.html#umi), [UMa](https://nvlabs.github.io/sionna/api/channel.wireless.html#uma), and [RMa](https://nvlabs.github.io/sionna/api/channel.wireless.html#rma) models require\nsetting-up a network topology, specifying, e.g., the user terminals (UTs) and\nbase stations (BSs) locations, the UTs velocities, etc.\n[Utility functions](https://nvlabs.github.io/sionna/api/channel.wireless.html#utility-functions) are available to help laying out\ncomplex topologies or to quickly setup simple but widely used topologies."
"### PanelArray\n\n`class` `sionna.channel.tr38901.``PanelArray`(*`num_rows_per_panel`*, *`num_cols_per_panel`*, *`polarization`*, *`polarization_type`*, *`antenna_pattern`*, *`carrier_frequency`*, *`num_rows``=``1`*, *`num_cols``=``1`*, *`panel_vertical_spacing``=``None`*, *`panel_horizontal_spacing``=``None`*, *`element_vertical_spacing``=``None`*, *`element_horizontal_spacing``=``None`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/tr38901/antenna.html#PanelArray)\n\nAntenna panel array following the [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) specification.\n\nThis class is used to create models of the panel arrays used by the\ntransmitters and receivers and that need to be specified when using the\n[CDL](https://nvlabs.github.io/sionna/api/channel.wireless.html#cdl), [UMi](https://nvlabs.github.io/sionna/api/channel.wireless.html#umi), [UMa](https://nvlabs.github.io/sionna/api/channel.wireless.html#uma), and [RMa](https://nvlabs.github.io/sionna/api/channel.wireless.html#rma)\nmodels.\n xample\n```python\n>>> array = PanelArray(num_rows_per_panel = 4,\n...                    num_cols_per_panel = 4,\n...                    polarization = 'dual',\n...                    polarization_type = 'VH',\n...                    antenna_pattern = '38.901',\n...                    carrier_frequency = 3.5e9,\n...                    num_cols = 2,\n...                    panel_horizontal_spacing = 3.)\n>>> array.show()\n```\n\nParameters\n\n- **num_rows_per_panel** (*int*)  Number of rows of elements per panel\n- **num_cols_per_panel** (*int*)  Number of columns of elements per panel\n- **polarization** (*str*)  Polarization, either single or dual\n- **polarization_type** (*str*)  Type of polarization. For single polarization, must be V or H.\nFor dual polarization, must be VH or cross.\n- **antenna_pattern** (*str*)  Element radiation pattern, either omni or 38.901\n- **carrier_frequency** (*float*)  Carrier frequency [Hz]\n- **num_rows** (*int*)  Number of rows of panels. Defaults to 1.\n- **num_cols** (*int*)  Number of columns of panels. Defaults to 1.\n- **panel_vertical_spacing** (<cite>None</cite> or float)  Vertical spacing of panels [multiples of wavelength].\nMust be greater than the panel width.\nIf set to <cite>None</cite> (default value), it is set to the panel width + 0.5.\n- **panel_horizontal_spacing** (<cite>None</cite> or float)  Horizontal spacing of panels [in multiples of wavelength].\nMust be greater than the panel height.\nIf set to <cite>None</cite> (default value), it is set to the panel height + 0.5.\n- **element_vertical_spacing** (<cite>None</cite> or float)  Element vertical spacing [multiple of wavelength].\nDefaults to 0.5 if set to <cite>None</cite>.\n- **element_horizontal_spacing** (<cite>None</cite> or float)  Element horizontal spacing [multiple of wavelength].\nDefaults to 0.5 if set to <cite>None</cite>.\n- **dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\n`property` `ant_ind_pol1`\n\nIndices of antenna elements with the first polarization direction\n\n\n`property` `ant_ind_pol2`\n\nIndices of antenna elements with the second polarization direction.\nOnly defined with dual polarization.\n\n\n`property` `ant_pol1`\n\nField of an antenna element with the first polarization direction\n\n\n`property` `ant_pol2`\n\nField of an antenna element with the second polarization direction.\nOnly defined with dual polarization.\n\n\n`property` `ant_pos`\n\nPositions of the antennas\n\n\n`property` `ant_pos_pol1`\n\nPositions of the antenna elements with the first polarization\ndirection\n\n\n`property` `ant_pos_pol2`\n\nPositions of antenna elements with the second polarization direction.\nOnly defined with dual polarization.\n\n\n`property` `element_horizontal_spacing`\n\nHorizontal spacing between the antenna elements within a panel\n[multiple of wavelength]\n\n\n`property` `element_vertical_spacing`\n\nVertical spacing between the antenna elements within a panel\n[multiple of wavelength]\n\n\n`property` `num_ant`\n\nTotal number of antenna elements\n\n\n`property` `num_cols`\n\nNumber of columns of panels\n\n\n`property` `num_cols_per_panel`\n\nNumber of columns of elements per panel\n\n\n`property` `num_panels`\n\nNumber of panels\n\n\n`property` `num_panels_ant`\n\nNumber of antenna elements per panel\n\n\n`property` `num_rows`\n\nNumber of rows of panels\n\n\n`property` `num_rows_per_panel`\n\nNumber of rows of elements per panel\n\n\n`property` `panel_horizontal_spacing`\n\nHorizontal spacing between the panels [multiple of wavelength]\n\n\n`property` `panel_vertical_spacing`\n\nVertical spacing between the panels [multiple of wavelength]\n\n\n`property` `polarization`\n\nPolarization (single or dual)\n\n\n`property` `polarization_type`\n\nPolarization type. V or H for single polarization.\nVH or cross for dual polarization.\n\n\n`show`()[`[source]`](../_modules/sionna/channel/tr38901/antenna.html#PanelArray.show)\n\nShow the panel array geometry\n\n\n`show_element_radiation_pattern`()[`[source]`](../_modules/sionna/channel/tr38901/antenna.html#PanelArray.show_element_radiation_pattern)\n\nShow the radiation field of antenna elements forming the panel"
"### Antenna\n\n`class` `sionna.channel.tr38901.``Antenna`(*`polarization`*, *`polarization_type`*, *`antenna_pattern`*, *`carrier_frequency`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/tr38901/antenna.html#Antenna)\n\nSingle antenna following the [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) specification.\n\nThis class is a special case of [`PanelArray`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.PanelArray),\nand can be used in lieu of it.\nParameters\n\n- **polarization** (*str*)  Polarization, either single or dual\n- **polarization_type** (*str*)  Type of polarization. For single polarization, must be V or H.\nFor dual polarization, must be VH or cross.\n- **antenna_pattern** (*str*)  Element radiation pattern, either omni or 38.901\n- **carrier_frequency** (*float*)  Carrier frequency [Hz]\n- **dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>."
"### AntennaArray\n\n`class` `sionna.channel.tr38901.``AntennaArray`(*`num_rows`*, *`num_cols`*, *`polarization`*, *`polarization_type`*, *`antenna_pattern`*, *`carrier_frequency`*, *`vertical_spacing`*, *`horizontal_spacing`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/tr38901/antenna.html#AntennaArray)\n\nAntenna array following the [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) specification.\n\nThis class is a special case of [`PanelArray`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.PanelArray),\nand can used in lieu of it.\nParameters\n\n- **num_rows** (*int*)  Number of rows of elements\n- **num_cols** (*int*)  Number of columns of elements\n- **polarization** (*str*)  Polarization, either single or dual\n- **polarization_type** (*str*)  Type of polarization. For single polarization, must be V or H.\nFor dual polarization, must be VH or cross.\n- **antenna_pattern** (*str*)  Element radiation pattern, either omni or 38.901\n- **carrier_frequency** (*float*)  Carrier frequency [Hz]\n- **vertical_spacing** (<cite>None</cite> or float)  Element vertical spacing [multiple of wavelength].\nDefaults to 0.5 if set to <cite>None</cite>.\n- **horizontal_spacing** (<cite>None</cite> or float)  Element horizontal spacing [multiple of wavelength].\nDefaults to 0.5 if set to <cite>None</cite>.\n- **dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>."
"### Tapped delay line (TDL)\n\n`class` `sionna.channel.tr38901.``TDL`(*`model`*, *`delay_spread`*, *`carrier_frequency`*, *`num_sinusoids``=``20`*, *`los_angle_of_arrival``=``PI` `/` `4.`*, *`min_speed``=``0.`*, *`max_speed``=``None`*, *`num_rx_ant``=``1`*, *`num_tx_ant``=``1`*, *`spatial_corr_mat``=``None`*, *`rx_corr_mat``=``None`*, *`tx_corr_mat``=``None`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/tr38901/tdl.html#TDL)\n\nTapped delay line (TDL) channel model from the 3GPP [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) specification.\n\nThe power delay profiles (PDPs) are normalized to have a total energy of one.\n\nChannel coefficients are generated using a sum-of-sinusoids model [[SoS]](https://nvlabs.github.io/sionna/api/channel.wireless.html#sos).\nChannel aging is simulated in the event of mobility.\n\nIf a minimum speed and a maximum speed are specified such that the\nmaximum speed is greater than the minimum speed, then speeds are randomly\nand uniformly sampled from the specified interval for each link and each\nbatch example.\n\nThe TDL model only works for systems with a single transmitter and a single\nreceiver. The transmitter and receiver can be equipped with multiple\nantennas. Spatial correlation is simulated through filtering by specified\ncorrelation matrices.\n\nThe `spatial_corr_mat` parameter can be used to specify an arbitrary\nspatial correlation matrix. In particular, it can be used to model\ncorrelated cross-polarized transmit and receive antennas as follows\n(see, e.g., Annex G.2.3.2.1 [[TS38141-1]](https://nvlabs.github.io/sionna/api/channel.wireless.html#ts38141-1)):\n\n$$\n\\mathbf{R} = \\mathbf{R}_{\\text{rx}} \\otimes \\mathbf{\\Gamma} \\otimes \\mathbf{R}_{\\text{tx}}\n$$\n\nwhere $\\mathbf{R}$ is the spatial correlation matrix `spatial_corr_mat`,\n$\\mathbf{R}_{\\text{rx}}$ the spatial correlation matrix at the receiver\nwith same polarization, $\\mathbf{R}_{\\text{tx}}$ the spatial correlation\nmatrix at the transmitter with same polarization, and $\\mathbf{\\Gamma}$\nthe polarization correlation matrix. $\\mathbf{\\Gamma}$ is 1x1 for single-polarized\nantennas, 2x2 when only the transmit or receive antennas are cross-polarized, and 4x4 when\ntransmit and receive antennas are cross-polarized.\n\nIt is also possible not to specify `spatial_corr_mat`, but instead the correlation matrices\nat the receiver and transmitter, using the `rx_corr_mat` and `tx_corr_mat`\nparameters, respectively.\nThis can be useful when single polarized antennas are simulated, and it is also\nmore computationally efficient.\nThis is equivalent to setting `spatial_corr_mat` to :\n\n$$\n\\mathbf{R} = \\mathbf{R}_{\\text{rx}} \\otimes \\mathbf{R}_{\\text{tx}}\n$$\n\nwhere $\\mathbf{R}_{\\text{rx}}$ is the correlation matrix at the receiver\n`rx_corr_mat` and  $\\mathbf{R}_{\\text{tx}}$ the correlation matrix at\nthe transmitter `tx_corr_mat`.\n xample\n\nThe following code snippet shows how to setup a TDL channel model assuming\nan OFDM waveform:"
"```python\n>>> tdl = TDL(model = \"A\",\n...           delay_spread = 300e-9,\n...           carrier_frequency = 3.5e9,\n...           min_speed = 0.0,\n...           max_speed = 3.0)\n>>>\n>>> channel = OFDMChannel(channel_model = tdl,\n...                       resource_grid = rg)\n```\n\n\nwhere `rg` is an instance of [`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid).\n otes\n\nThe following tables from [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) provide typical values for the delay\nspread.\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 58%\" />\n<col style=\"width: 42%\" />\n</colgroup>\n<thead>\n<tr class=\"row-odd\"><th class=\"head\">\nModel</th>\n<th class=\"head\">\nDelay spread [ns]</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-even\"><td>\nVery short delay spread</td>\n<td>\n$10$</td>\n</tr>\n<tr class=\"row-odd\"><td>\nShort short delay spread</td>\n<td>\n$10$</td>\n</tr>\n<tr class=\"row-even\"><td>\nNominal delay spread</td>\n<td>\n$100$</td>\n</tr>\n<tr class=\"row-odd\"><td>\nLong delay spread</td>\n<td>\n$300$</td>\n</tr>\n<tr class=\"row-even\"><td>\nVery long delay spread</td>\n<td>\n$1000$</td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 30%\" />\n<col style=\"width: 27%\" />\n<col style=\"width: 7%\" />\n<col style=\"width: 7%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 6%\" />\n</colgroup>\n<thead>\n<tr class=\"row-odd\"><th class=\"head\" colspan=\"2\" rowspan=\"2\">\nDelay spread [ns]</th>\n<th class=\"head\" colspan=\"7\">\nFrequency [GHz]</th>\n</tr>\n<tr class=\"row-even\"><th class=\"head\">\n2</th>\n<th class=\"head\">\n6</th>\n<th class=\"head\">\n15</th>\n<th class=\"head\">\n28</th>\n<th class=\"head\">\n39</th>\n<th class=\"head\">\n60</th>\n<th class=\"head\">\n70</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-odd\"><td rowspan=\"3\">\nIndoor office</td>\n<td>\nShort delay profile</td>\n<td>\n20</td>\n<td>\n16</td>\n<td>\n16</td>\n<td>\n16</td>\n<td>\n16</td>\n<td>\n16</td>\n<td>\n16</td>\n</tr>\n<tr class=\"row-even\"><td>\nNormal delay profile</td>\n<td>\n39</td>\n<td>\n30</td>\n<td>\n24</td>\n<td>\n20</td>\n<td>\n18</td>\n<td>\n16</td>\n<td>\n16</td>\n</tr>\n<tr class=\"row-odd\"><td>\nLong delay profile</td>\n<td>\n59</td>\n<td>\n53</td>\n<td>\n47</td>\n<td>\n43</td>\n<td>\n41</td>\n<td>\n38</td>\n<td>\n37</td>\n</tr>\n<tr class=\"row-even\"><td rowspan=\"3\">\nUMi Street-canyon</td>\n<td>\nShort delay profile</td>\n<td>\n65</td>\n<td>\n45</td>\n<td>\n37</td>\n<td>\n32</td>\n<td>\n30</td>\n<td>\n27</td>\n<td>\n26</td>\n</tr>\n<tr class=\"row-odd\"><td>\nNormal delay profile</td>\n<td>\n129</td>\n<td>\n93</td>\n<td>\n76</td>\n<td>\n66</td>\n<td>\n61</td>\n<td>\n55</td>\n<td>\n53</td>\n</tr>\n<tr class=\"row-even\"><td>\nLong delay profile</td>\n<td>\n634</td>\n<td>\n316</td>\n<td>\n307</td>\n<td>\n301</td>\n<td>\n297</td>\n<td>\n293</td>\n<td>\n291</td>\n</tr>\n<tr class=\"row-odd\"><td rowspan=\"3\">\nUMa</td>\n<td>\nShort delay profile</td>\n<td>\n93</td>\n<td>\n93</td>\n<td>\n85</td>\n<td>\n80</td>\n<td>\n78</td>\n<td>\n75</td>\n<td>\n74</td>\n</tr>\n<tr class=\"row-even\"><td>\nNormal delay profile</td>\n<td>\n363</td>\n<td>\n363</td>\n<td>\n302</td>\n<td>\n266</td>\n<td>\n249</td>\n<td>\n228</td>\n<td>\n221</td>\n</tr>\n<tr class=\"row-odd\"><td>\nLong delay profile</td>\n<td>\n1148</td>\n<td>\n1148</td>\n<td>\n955</td>\n<td>\n841</td>\n<td>\n786</td>\n<td>\n720</td>\n<td>\n698</td>\n</tr>\n<tr class=\"row-even\"><td rowspan=\"3\">\nRMa / RMa O2I</td>\n<td>\nShort delay profile</td>\n<td>\n32</td>\n<td>\n32</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n</tr>\n<tr class=\"row-odd\"><td>\nNormal delay profile</td>\n<td>\n37</td>\n<td>\n37</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n</tr>\n<tr class=\"row-even\"><td>\nLong delay profile</td>\n<td>\n153</td>\n<td>\n153</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n</tr>\n<tr class=\"row-odd\"><td rowspan=\"2\">\nUMi / UMa O2I</td>\n<td>\nNormal delay profile</td>\n<td colspan=\"7\">\n242</td>\n</tr>\n<tr class=\"row-even\"><td>\nLong delay profile</td>\n<td colspan=\"7\">\n616</td>\n</tr>\n</tbody>\n</table>\nParameters\n\n- **model** (*str*)  TDL model to use. Must be one of A, B, C, D, E, A30, B100, or C300.\n- **delay_spread** (*float*)  RMS delay spread [s].\nFor the A30, B100, and C300 models, the delay spread must be set\nto 30ns, 100ns, and 300ns, respectively.\n- **carrier_frequency** (*float*)  Carrier frequency [Hz]\n- **num_sinusoids** (*int*)  Number of sinusoids for the sum-of-sinusoids model. Defaults to 20.\n- **los_angle_of_arrival** (*float*)  Angle-of-arrival for LoS path [radian]. Only used with LoS models.\nDefaults to $\\pi/4$.\n- **min_speed** (*float*)  Minimum speed [m/s]. Defaults to 0.\n- **max_speed** (*None** or **float*)  Maximum speed [m/s]. If set to <cite>None</cite>,\nthen `max_speed` takes the same value as `min_speed`.\nDefaults to <cite>None</cite>.\n- **num_rx_ant** (*int*)  Number of receive antennas.\nDefaults to 1.\n- **num_tx_ant** (*int*)  Number of transmit antennas.\nDefaults to 1.\n- **spatial_corr_mat** ([num_rx_ant*num_tx_ant,num_rx_ant*num_tx_ant], tf.complex or <cite>None</cite>)  Spatial correlation matrix.\nIf not set to <cite>None</cite>, then `rx_corr_mat` and `tx_corr_mat` are ignored and\nthis matrix is used for spatial correlation.\nIf set to <cite>None</cite> and `rx_corr_mat` and `tx_corr_mat` are also set to <cite>None</cite>,\nthen no correlation is applied.\nDefaults to <cite>None</cite>.\n- **rx_corr_mat** ([num_rx_ant,num_rx_ant], tf.complex or <cite>None</cite>)  Spatial correlation matrix for the receiver.\nIf set to <cite>None</cite> and `spatial_corr_mat` is also set to <cite>None</cite>, then no receive\ncorrelation is applied.\nDefaults to <cite>None</cite>.\n- **tx_corr_mat** ([num_tx_ant,num_tx_ant], tf.complex or <cite>None</cite>)  Spatial correlation matrix for the transmitter.\nIf set to <cite>None</cite> and `spatial_corr_mat` is also set to <cite>None</cite>, then no transmit\ncorrelation is applied.\nDefaults to <cite>None</cite>.\n- **dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **batch_size** (*int*)  Batch size\n- **num_time_steps** (*int*)  Number of time steps\n- **sampling_frequency** (*float*)  Sampling frequency [Hz]\n\n\nOutput\n\n- **a** (*[batch size, num_rx = 1, num_rx_ant = 1, num_tx = 1, num_tx_ant = 1, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx = 1, num_tx = 1, num_paths], tf.float*)  Path delays [s]\n\n\n`property` `delay_spread`\n\nRMS delay spread [s]\n\n\n`property` `delays`\n\nPath delays [s]\n\n\n`property` `k_factor`\n\nK-factor in linear scale. Only available with LoS models.\n\n\n`property` `los`\n\n<cite>True</cite> if this is a LoS model. <cite>False</cite> otherwise.\n\n\n`property` `mean_power_los`\n\nLoS component power in linear scale.\nOnly available with LoS models.\n\n\n`property` `mean_powers`\n\nPath powers in linear scale\n\n\n`property` `num_clusters`\n\nNumber of paths ($M$)"
"### Clustered delay line (CDL)\n\n`class` `sionna.channel.tr38901.``CDL`(*`model`*, *`delay_spread`*, *`carrier_frequency`*, *`ut_array`*, *`bs_array`*, *`direction`*, *`min_speed``=``0.`*, *`max_speed``=``None`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/tr38901/cdl.html#CDL)\n\nClustered delay line (CDL) channel model from the 3GPP [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) specification.\n\nThe power delay profiles (PDPs) are normalized to have a total energy of one.\n\nIf a minimum speed and a maximum speed are specified such that the\nmaximum speed is greater than the minimum speed, then UTs speeds are\nrandomly and uniformly sampled from the specified interval for each link\nand each batch example.\n\nThe CDL model only works for systems with a single transmitter and a single\nreceiver. The transmitter and receiver can be equipped with multiple\nantennas.\n xample\n\nThe following code snippet shows how to setup a CDL channel model assuming\nan OFDM waveform:\n```python\n>>> # Panel array configuration for the transmitter and receiver\n>>> bs_array = PanelArray(num_rows_per_panel = 4,\n...                       num_cols_per_panel = 4,\n...                       polarization = 'dual',\n...                       polarization_type = 'cross',\n...                       antenna_pattern = '38.901',\n...                       carrier_frequency = 3.5e9)\n>>> ut_array = PanelArray(num_rows_per_panel = 1,\n...                       num_cols_per_panel = 1,\n...                       polarization = 'single',\n...                       polarization_type = 'V',\n...                       antenna_pattern = 'omni',\n...                       carrier_frequency = 3.5e9)\n>>> # CDL channel model\n>>> cdl = CDL(model = \"A\",\n>>>           delay_spread = 300e-9,\n...           carrier_frequency = 3.5e9,\n...           ut_array = ut_array,\n...           bs_array = bs_array,\n...           direction = 'uplink')\n>>> channel = OFDMChannel(channel_model = cdl,\n...                       resource_grid = rg)\n```"
"where `rg` is an instance of [`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid).\n otes\n\nThe following tables from [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) provide typical values for the delay\nspread.\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 58%\" />\n<col style=\"width: 42%\" />\n</colgroup>\n<thead>\n<tr class=\"row-odd\"><th class=\"head\">\nModel</th>\n<th class=\"head\">\nDelay spread [ns]</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-even\"><td>\nVery short delay spread</td>\n<td>\n$10$</td>\n</tr>\n<tr class=\"row-odd\"><td>\nShort short delay spread</td>\n<td>\n$10$</td>\n</tr>\n<tr class=\"row-even\"><td>\nNominal delay spread</td>\n<td>\n$100$</td>\n</tr>\n<tr class=\"row-odd\"><td>\nLong delay spread</td>\n<td>\n$300$</td>\n</tr>\n<tr class=\"row-even\"><td>\nVery long delay spread</td>\n<td>\n$1000$</td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 30%\" />\n<col style=\"width: 27%\" />\n<col style=\"width: 7%\" />\n<col style=\"width: 7%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 6%\" />\n</colgroup>\n<thead>\n<tr class=\"row-odd\"><th class=\"head\" colspan=\"2\" rowspan=\"2\">\nDelay spread [ns]</th>\n<th class=\"head\" colspan=\"7\">\nFrequency [GHz]</th>\n</tr>\n<tr class=\"row-even\"><th class=\"head\">\n2</th>\n<th class=\"head\">\n6</th>\n<th class=\"head\">\n15</th>\n<th class=\"head\">\n28</th>\n<th class=\"head\">\n39</th>\n<th class=\"head\">\n60</th>\n<th class=\"head\">\n70</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-odd\"><td rowspan=\"3\">\nIndoor office</td>\n<td>\nShort delay profile</td>\n<td>\n20</td>\n<td>\n16</td>\n<td>\n16</td>\n<td>\n16</td>\n<td>\n16</td>\n<td>\n16</td>\n<td>\n16</td>\n</tr>\n<tr class=\"row-even\"><td>\nNormal delay profile</td>\n<td>\n39</td>\n<td>\n30</td>\n<td>\n24</td>\n<td>\n20</td>\n<td>\n18</td>\n<td>\n16</td>\n<td>\n16</td>\n</tr>\n<tr class=\"row-odd\"><td>\nLong delay profile</td>\n<td>\n59</td>\n<td>\n53</td>\n<td>\n47</td>\n<td>\n43</td>\n<td>\n41</td>\n<td>\n38</td>\n<td>\n37</td>\n</tr>\n<tr class=\"row-even\"><td rowspan=\"3\">\nUMi Street-canyon</td>\n<td>\nShort delay profile</td>\n<td>\n65</td>\n<td>\n45</td>\n<td>\n37</td>\n<td>\n32</td>\n<td>\n30</td>\n<td>\n27</td>\n<td>\n26</td>\n</tr>\n<tr class=\"row-odd\"><td>\nNormal delay profile</td>\n<td>\n129</td>\n<td>\n93</td>\n<td>\n76</td>\n<td>\n66</td>\n<td>\n61</td>\n<td>\n55</td>\n<td>\n53</td>\n</tr>\n<tr class=\"row-even\"><td>\nLong delay profile</td>\n<td>\n634</td>\n<td>\n316</td>\n<td>\n307</td>\n<td>\n301</td>\n<td>\n297</td>\n<td>\n293</td>\n<td>\n291</td>\n</tr>\n<tr class=\"row-odd\"><td rowspan=\"3\">\nUMa</td>\n<td>\nShort delay profile</td>\n<td>\n93</td>\n<td>\n93</td>\n<td>\n85</td>\n<td>\n80</td>\n<td>\n78</td>\n<td>\n75</td>\n<td>\n74</td>\n</tr>\n<tr class=\"row-even\"><td>\nNormal delay profile</td>\n<td>\n363</td>\n<td>\n363</td>\n<td>\n302</td>\n<td>\n266</td>\n<td>\n249</td>\n<td>\n228</td>\n<td>\n221</td>\n</tr>\n<tr class=\"row-odd\"><td>\nLong delay profile</td>\n<td>\n1148</td>\n<td>\n1148</td>\n<td>\n955</td>\n<td>\n841</td>\n<td>\n786</td>\n<td>\n720</td>\n<td>\n698</td>\n</tr>\n<tr class=\"row-even\"><td rowspan=\"3\">\nRMa / RMa O2I</td>\n<td>\nShort delay profile</td>\n<td>\n32</td>\n<td>\n32</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n</tr>\n<tr class=\"row-odd\"><td>\nNormal delay profile</td>\n<td>\n37</td>\n<td>\n37</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n</tr>\n<tr class=\"row-even\"><td>\nLong delay profile</td>\n<td>\n153</td>\n<td>\n153</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n<td>\nN/A</td>\n</tr>\n<tr class=\"row-odd\"><td rowspan=\"2\">\nUMi / UMa O2I</td>\n<td>\nNormal delay profile</td>\n<td colspan=\"7\">\n242</td>\n</tr>\n<tr class=\"row-even\"><td>\nLong delay profile</td>\n<td colspan=\"7\">\n616</td>\n</tr>\n</tbody>\n</table>\nParameters\n\n- **model** (*str*)  CDL model to use. Must be one of A, B, C, D or E.\n- **delay_spread** (*float*)  RMS delay spread [s].\n- **carrier_frequency** (*float*)  Carrier frequency [Hz].\n- **ut_array** ()  Panel array used by the UTs. All UTs share the same antenna array\nconfiguration.\n- **bs_array** ()  Panel array used by the Bs. All BSs share the same antenna array\nconfiguration.\n- **direction** (*str*)  Link direction. Must be either uplink or downlink.\n- **ut_orientation** (<cite>None</cite> or Tensor of shape [3], tf.float)  Orientation of the UT. If set to <cite>None</cite>, [$\\pi$, 0, 0] is used.\nDefaults to <cite>None</cite>.\n- **bs_orientation** (<cite>None</cite> or Tensor of shape [3], tf.float)  Orientation of the BS. If set to <cite>None</cite>, [0, 0, 0] is used.\nDefaults to <cite>None</cite>.\n- **min_speed** (*float*)  Minimum speed [m/s]. Defaults to 0.\n- **max_speed** (*None** or **float*)  Maximum speed [m/s]. If set to <cite>None</cite>,\nthen `max_speed` takes the same value as `min_speed`.\nDefaults to <cite>None</cite>.\n- **dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **batch_size** (*int*)  Batch size\n- **num_time_steps** (*int*)  Number of time steps\n- **sampling_frequency** (*float*)  Sampling frequency [Hz]\n\n\nOutput\n\n- **a** (*[batch size, num_rx = 1, num_rx_ant, num_tx = 1, num_tx_ant, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx = 1, num_tx = 1, num_paths], tf.float*)  Path delays [s]\n\n\n`property` `delay_spread`\n\nRMS delay spread [s]\n\n\n`property` `delays`\n\nPath delays [s]\n\n\n`property` `k_factor`\n\nK-factor in linear scale. Only available with LoS models.\n\n\n`property` `los`\n\n<cite>True</cite> is this is a LoS model. <cite>False</cite> otherwise.\n\n\n`property` `num_clusters`\n\nNumber of paths ($M$)\n\n\n`property` `powers`\n\nPath powers in linear scale"
"### Urban microcell (UMi)\n\n`class` `sionna.channel.tr38901.``UMi`(*`carrier_frequency`*, *`o2i_model`*, *`ut_array`*, *`bs_array`*, *`direction`*, *`enable_pathloss``=``True`*, *`enable_shadow_fading``=``True`*, *`always_generate_lsp``=``False`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/tr38901/umi.html#UMi)\n\nUrban microcell (UMi) channel model from 3GPP [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) specification.\n\nSetting up a UMi model requires configuring the network topology, i.e., the\nUTs and BSs locations, UTs velocities, etc. This is achieved using the\n[`set_topology()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMi.set_topology) method. Setting a different\ntopology for each batch example is possible. The batch size used when setting up the network topology\nis used for the link simulations.\n\nThe following code snippet shows how to setup a UMi channel model operating\nin the frequency domain:\n```python\n>>> # UT and BS panel arrays\n>>> bs_array = PanelArray(num_rows_per_panel = 4,\n...                       num_cols_per_panel = 4,\n...                       polarization = 'dual',\n...                       polarization_type  = 'cross',\n...                       antenna_pattern = '38.901',\n...                       carrier_frequency = 3.5e9)\n>>> ut_array = PanelArray(num_rows_per_panel = 1,\n...                       num_cols_per_panel = 1,\n...                       polarization = 'single',\n...                       polarization_type = 'V',\n...                       antenna_pattern = 'omni',\n...                       carrier_frequency = 3.5e9)\n>>> # Instantiating UMi channel model\n>>> channel_model = UMi(carrier_frequency = 3.5e9,\n...                     o2i_model = 'low',\n...                     ut_array = ut_array,\n...                     bs_array = bs_array,\n...                     direction = 'uplink')\n>>> # Setting up network topology\n>>> # ut_loc: UTs locations\n>>> # bs_loc: BSs locations\n>>> # ut_orientations: UTs array orientations\n>>> # bs_orientations: BSs array orientations\n>>> # in_state: Indoor/outdoor states of UTs\n>>> channel_model.set_topology(ut_loc,\n...                            bs_loc,\n...                            ut_orientations,\n...                            bs_orientations,\n...                            ut_velocities,\n...                            in_state)\n>>> # Instanting the frequency domain channel\n>>> channel = OFDMChannel(channel_model = channel_model,\n...                       resource_grid = rg)\n```"
"where `rg` is an instance of [`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid).\nParameters\n\n- **carrier_frequency** (*float*)  Carrier frequency in Hertz\n- **o2i_model** (*str*)  Outdoor-to-indoor loss model for UTs located indoor.\nSet this parameter to low to use the low-loss model, or to high\nto use the high-loss model.\nSee section 7.4.3 of [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) for details.\n- **rx_array** ()  Panel array used by the receivers. All receivers share the same\nantenna array configuration.\n- **tx_array** ()  Panel array used by the transmitters. All transmitters share the\nsame antenna array configuration.\n- **direction** (*str*)  Link direction. Either uplink or downlink.\n- **enable_pathloss** (*bool*)  If <cite>True</cite>, apply pathloss. Otherwise doesnt. Defaults to <cite>True</cite>.\n- **enable_shadow_fading** (*bool*)  If <cite>True</cite>, apply shadow fading. Otherwise doesnt.\nDefaults to <cite>True</cite>.\n- **always_generate_lsp** (*bool*)  If <cite>True</cite>, new large scale parameters (LSPs) are generated for every\nnew generation of channel impulse responses. Otherwise, always reuse\nthe same LSPs, except if the topology is changed. Defaults to\n<cite>False</cite>.\n- **dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **num_time_steps** (*int*)  Number of time steps\n- **sampling_frequency** (*float*)  Sampling frequency [Hz]\n\n\nOutput\n\n- **a** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx, num_tx, num_paths], tf.float*)  Path delays [s]\n\n\n`set_topology`(*`ut_loc``=``None`*, *`bs_loc``=``None`*, *`ut_orientations``=``None`*, *`bs_orientations``=``None`*, *`ut_velocities``=``None`*, *`in_state``=``None`*, *`los``=``None`*)\n\nSet the network topology.\n\nIt is possible to set up a different network topology for each batch\nexample. The batch size used when setting up the network topology\nis used for the link simulations.\n\nWhen calling this function, not specifying a parameter leads to the\nreuse of the previously given value. Not specifying a value that was not\nset at a former call rises an error.\nInput\n\n- **ut_loc** (*[batch size,num_ut, 3], tf.float*)  Locations of the UTs\n- **bs_loc** (*[batch size,num_bs, 3], tf.float*)  Locations of BSs\n- **ut_orientations** (*[batch size,num_ut, 3], tf.float*)  Orientations of the UTs arrays [radian]\n- **bs_orientations** (*[batch size,num_bs, 3], tf.float*)  Orientations of the BSs arrays [radian]\n- **ut_velocities** (*[batch size,num_ut, 3], tf.float*)  Velocity vectors of UTs\n- **in_state** (*[batch size,num_ut], tf.bool*)  Indoor/outdoor state of UTs. <cite>True</cite> means indoor and <cite>False</cite>\nmeans outdoor.\n- **los** (tf.bool or <cite>None</cite>)  If not <cite>None</cite> (default value), all UTs located outdoor are\nforced to be in LoS if `los` is set to <cite>True</cite>, or in NLoS\nif it is set to <cite>False</cite>. If set to <cite>None</cite>, the LoS/NLoS states\nof UTs is set following 3GPP specification [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901).\n\n\n**Note**\n\nIf you want to use this function in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat).\n\n\n`show_topology`(*`bs_index``=``0`*, *`batch_index``=``0`*)\n\nShows the network topology of the batch example with index\n`batch_index`.\n\nThe `bs_index` parameter specifies with respect to which BS the\nLoS/NLoS state of UTs is indicated.\nInput\n\n- **bs_index** (*int*)  BS index with respect to which the LoS/NLoS state of UTs is\nindicated. Defaults to 0.\n- **batch_index** (*int*)  Batch example for which the topology is shown. Defaults to 0."
"### Urban macrocell (UMa)\n\n`class` `sionna.channel.tr38901.``UMa`(*`carrier_frequency`*, *`o2i_model`*, *`ut_array`*, *`bs_array`*, *`direction`*, *`enable_pathloss``=``True`*, *`enable_shadow_fading``=``True`*, *`always_generate_lsp``=``False`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/tr38901/uma.html#UMa)\n\nUrban macrocell (UMa) channel model from 3GPP [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) specification.\n\nSetting up a UMa model requires configuring the network topology, i.e., the\nUTs and BSs locations, UTs velocities, etc. This is achieved using the\n[`set_topology()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMa.set_topology) method. Setting a different\ntopology for each batch example is possible. The batch size used when setting up the network topology\nis used for the link simulations.\n\nThe following code snippet shows how to setup an UMa channel model assuming\nan OFDM waveform:\n```python\n>>> # UT and BS panel arrays\n>>> bs_array = PanelArray(num_rows_per_panel = 4,\n...                       num_cols_per_panel = 4,\n...                       polarization = 'dual',\n...                       polarization_type = 'cross',\n...                       antenna_pattern = '38.901',\n...                       carrier_frequency = 3.5e9)\n>>> ut_array = PanelArray(num_rows_per_panel = 1,\n...                       num_cols_per_panel = 1,\n...                       polarization = 'single',\n...                       polarization_type = 'V',\n...                       antenna_pattern = 'omni',\n...                       carrier_frequency = 3.5e9)\n>>> # Instantiating UMa channel model\n>>> channel_model = UMa(carrier_frequency = 3.5e9,\n...                     o2i_model = 'low',\n...                     ut_array = ut_array,\n...                     bs_array = bs_array,\n...                     direction = 'uplink')\n>>> # Setting up network topology\n>>> # ut_loc: UTs locations\n>>> # bs_loc: BSs locations\n>>> # ut_orientations: UTs array orientations\n>>> # bs_orientations: BSs array orientations\n>>> # in_state: Indoor/outdoor states of UTs\n>>> channel_model.set_topology(ut_loc,\n...                            bs_loc,\n...                            ut_orientations,\n...                            bs_orientations,\n...                            ut_velocities,\n...                            in_state)\n>>> # Instanting the OFDM channel\n>>> channel = OFDMChannel(channel_model = channel_model,\n...                       resource_grid = rg)\n```"
"where `rg` is an instance of [`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid).\nParameters\n\n- **carrier_frequency** (*float*)  Carrier frequency in Hertz\n- **o2i_model** (*str*)  Outdoor-to-indoor loss model for UTs located indoor.\nSet this parameter to low to use the low-loss model, or to high\nto use the high-loss model.\nSee section 7.4.3 of [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) for details.\n- **rx_array** ()  Panel array used by the receivers. All receivers share the same\nantenna array configuration.\n- **tx_array** ()  Panel array used by the transmitters. All transmitters share the\nsame antenna array configuration.\n- **direction** (*str*)  Link direction. Either uplink or downlink.\n- **enable_pathloss** (*bool*)  If <cite>True</cite>, apply pathloss. Otherwise doesnt. Defaults to <cite>True</cite>.\n- **enable_shadow_fading** (*bool*)  If <cite>True</cite>, apply shadow fading. Otherwise doesnt.\nDefaults to <cite>True</cite>.\n- **always_generate_lsp** (*bool*)  If <cite>True</cite>, new large scale parameters (LSPs) are generated for every\nnew generation of channel impulse responses. Otherwise, always reuse\nthe same LSPs, except if the topology is changed. Defaults to\n<cite>False</cite>.\n- **dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **num_time_steps** (*int*)  Number of time steps\n- **sampling_frequency** (*float*)  Sampling frequency [Hz]\n\n\nOutput\n\n- **a** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx, num_tx, num_paths], tf.float*)  Path delays [s]\n\n\n`set_topology`(*`ut_loc``=``None`*, *`bs_loc``=``None`*, *`ut_orientations``=``None`*, *`bs_orientations``=``None`*, *`ut_velocities``=``None`*, *`in_state``=``None`*, *`los``=``None`*)\n\nSet the network topology.\n\nIt is possible to set up a different network topology for each batch\nexample. The batch size used when setting up the network topology\nis used for the link simulations.\n\nWhen calling this function, not specifying a parameter leads to the\nreuse of the previously given value. Not specifying a value that was not\nset at a former call rises an error.\nInput\n\n- **ut_loc** (*[batch size,num_ut, 3], tf.float*)  Locations of the UTs\n- **bs_loc** (*[batch size,num_bs, 3], tf.float*)  Locations of BSs\n- **ut_orientations** (*[batch size,num_ut, 3], tf.float*)  Orientations of the UTs arrays [radian]\n- **bs_orientations** (*[batch size,num_bs, 3], tf.float*)  Orientations of the BSs arrays [radian]\n- **ut_velocities** (*[batch size,num_ut, 3], tf.float*)  Velocity vectors of UTs\n- **in_state** (*[batch size,num_ut], tf.bool*)  Indoor/outdoor state of UTs. <cite>True</cite> means indoor and <cite>False</cite>\nmeans outdoor.\n- **los** (tf.bool or <cite>None</cite>)  If not <cite>None</cite> (default value), all UTs located outdoor are\nforced to be in LoS if `los` is set to <cite>True</cite>, or in NLoS\nif it is set to <cite>False</cite>. If set to <cite>None</cite>, the LoS/NLoS states\nof UTs is set following 3GPP specification [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901).\n\n\n**Note**\n\nIf you want to use this function in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat).\n\n\n`show_topology`(*`bs_index``=``0`*, *`batch_index``=``0`*)\n\nShows the network topology of the batch example with index\n`batch_index`.\n\nThe `bs_index` parameter specifies with respect to which BS the\nLoS/NLoS state of UTs is indicated.\nInput\n\n- **bs_index** (*int*)  BS index with respect to which the LoS/NLoS state of UTs is\nindicated. Defaults to 0.\n- **batch_index** (*int*)  Batch example for which the topology is shown. Defaults to 0."
"### Rural macrocell (RMa)\n\n`class` `sionna.channel.tr38901.``RMa`(*`carrier_frequency`*, *`ut_array`*, *`bs_array`*, *`direction`*, *`enable_pathloss``=``True`*, *`enable_shadow_fading``=``True`*, *`always_generate_lsp``=``False`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/tr38901/rma.html#RMa)\n\nRural macrocell (RMa) channel model from 3GPP [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901) specification.\n\nSetting up a RMa model requires configuring the network topology, i.e., the\nUTs and BSs locations, UTs velocities, etc. This is achieved using the\n[`set_topology()`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.RMa.set_topology) method. Setting a different\ntopology for each batch example is possible. The batch size used when setting up the network topology\nis used for the link simulations.\n\nThe following code snippet shows how to setup an RMa channel model assuming\nan OFDM waveform:\n```python\n>>> # UT and BS panel arrays\n>>> bs_array = PanelArray(num_rows_per_panel = 4,\n...                       num_cols_per_panel = 4,\n...                       polarization = 'dual',\n...                       polarization_type = 'cross',\n...                       antenna_pattern = '38.901',\n...                       carrier_frequency = 3.5e9)\n>>> ut_array = PanelArray(num_rows_per_panel = 1,\n...                       num_cols_per_panel = 1,\n...                       polarization = 'single',\n...                       polarization_type = 'V',\n...                       antenna_pattern = 'omni',\n...                       carrier_frequency = 3.5e9)\n>>> # Instantiating RMa channel model\n>>> channel_model = RMa(carrier_frequency = 3.5e9,\n...                     ut_array = ut_array,\n...                     bs_array = bs_array,\n...                     direction = 'uplink')\n>>> # Setting up network topology\n>>> # ut_loc: UTs locations\n>>> # bs_loc: BSs locations\n>>> # ut_orientations: UTs array orientations\n>>> # bs_orientations: BSs array orientations\n>>> # in_state: Indoor/outdoor states of UTs\n>>> channel_model.set_topology(ut_loc,\n...                            bs_loc,\n...                            ut_orientations,\n...                            bs_orientations,\n...                            ut_velocities,\n...                            in_state)\n>>> # Instanting the OFDM channel\n>>> channel = OFDMChannel(channel_model = channel_model,\n...                       resource_grid = rg)\n```"
"where `rg` is an instance of [`ResourceGrid`](ofdm.html#sionna.ofdm.ResourceGrid).\nParameters\n\n- **carrier_frequency** (*float*)  Carrier frequency [Hz]\n- **rx_array** ()  Panel array used by the receivers. All receivers share the same\nantenna array configuration.\n- **tx_array** ()  Panel array used by the transmitters. All transmitters share the\nsame antenna array configuration.\n- **direction** (*str*)  Link direction. Either uplink or downlink.\n- **enable_pathloss** (*bool*)  If <cite>True</cite>, apply pathloss. Otherwise doesnt. Defaults to <cite>True</cite>.\n- **enable_shadow_fading** (*bool*)  If <cite>True</cite>, apply shadow fading. Otherwise doesnt.\nDefaults to <cite>True</cite>.\n- **average_street_width** (*float*)  Average street width [m]. Defaults to 5m.\n- **average_street_width**  Average building height [m]. Defaults to 20m.\n- **always_generate_lsp** (*bool*)  If <cite>True</cite>, new large scale parameters (LSPs) are generated for every\nnew generation of channel impulse responses. Otherwise, always reuse\nthe same LSPs, except if the topology is changed. Defaults to\n<cite>False</cite>.\n- **dtype** (*Complex tf.DType*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **num_time_steps** (*int*)  Number of time steps\n- **sampling_frequency** (*float*)  Sampling frequency [Hz]\n\n\nOutput\n\n- **a** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx, num_tx, num_paths], tf.float*)  Path delays [s]\n\n\n`set_topology`(*`ut_loc``=``None`*, *`bs_loc``=``None`*, *`ut_orientations``=``None`*, *`bs_orientations``=``None`*, *`ut_velocities``=``None`*, *`in_state``=``None`*, *`los``=``None`*)\n\nSet the network topology.\n\nIt is possible to set up a different network topology for each batch\nexample. The batch size used when setting up the network topology\nis used for the link simulations.\n\nWhen calling this function, not specifying a parameter leads to the\nreuse of the previously given value. Not specifying a value that was not\nset at a former call rises an error.\nInput\n\n- **ut_loc** (*[batch size,num_ut, 3], tf.float*)  Locations of the UTs\n- **bs_loc** (*[batch size,num_bs, 3], tf.float*)  Locations of BSs\n- **ut_orientations** (*[batch size,num_ut, 3], tf.float*)  Orientations of the UTs arrays [radian]\n- **bs_orientations** (*[batch size,num_bs, 3], tf.float*)  Orientations of the BSs arrays [radian]\n- **ut_velocities** (*[batch size,num_ut, 3], tf.float*)  Velocity vectors of UTs\n- **in_state** (*[batch size,num_ut], tf.bool*)  Indoor/outdoor state of UTs. <cite>True</cite> means indoor and <cite>False</cite>\nmeans outdoor.\n- **los** (tf.bool or <cite>None</cite>)  If not <cite>None</cite> (default value), all UTs located outdoor are\nforced to be in LoS if `los` is set to <cite>True</cite>, or in NLoS\nif it is set to <cite>False</cite>. If set to <cite>None</cite>, the LoS/NLoS states\nof UTs is set following 3GPP specification [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901).\n\n\n**Note**\n\nIf you want to use this function in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat).\n\n\n`show_topology`(*`bs_index``=``0`*, *`batch_index``=``0`*)\n\nShows the network topology of the batch example with index\n`batch_index`.\n\nThe `bs_index` parameter specifies with respect to which BS the\nLoS/NLoS state of UTs is indicated.\nInput\n\n- **bs_index** (*int*)  BS index with respect to which the LoS/NLoS state of UTs is\nindicated. Defaults to 0.\n- **batch_index** (*int*)  Batch example for which the topology is shown. Defaults to 0."
"## External datasets\n\n`class` `sionna.channel.``CIRDataset`(*`cir_generator`*, *`batch_size`*, *`num_rx`*, *`num_rx_ant`*, *`num_tx`*, *`num_tx_ant`*, *`num_paths`*, *`num_time_steps`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/cir_dataset.html#CIRDataset)\n\nCreates a channel model from a dataset that can be used with classes such as\n[`TimeChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.TimeChannel) and [`OFDMChannel`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.OFDMChannel).\nThe dataset is defined by a [generator](https://wiki.python.org/moin/Generators).\n\nThe batch size is configured when instantiating the dataset or through the [`batch_size`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.CIRDataset.batch_size) property.\nThe number of time steps (<cite>num_time_steps</cite>) and sampling frequency (<cite>sampling_frequency</cite>) can only be set when instantiating the dataset.\nThe specified values must be in accordance with the data.\n xample\n\nThe following code snippet shows how to use this class as a channel model.\n```python\n>>> my_generator = MyGenerator(...)\n>>> channel_model = sionna.channel.CIRDataset(my_generator,\n...                                           batch_size,\n...                                           num_rx,\n...                                           num_rx_ant,\n...                                           num_tx,\n...                                           num_tx_ant,\n...                                           num_paths,\n...                                           num_time_steps+l_tot-1)\n>>> channel = sionna.channel.TimeChannel(channel_model, bandwidth, num_time_steps)\n```\n\n\nwhere `MyGenerator` is a generator\n```python\n>>> class MyGenerator:\n...\n...     def __call__(self):\n...         ...\n...         yield a, tau\n```\n\n\nthat returns complex-valued path coefficients `a` with shape\n<cite>[num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps]</cite>\nand real-valued path delays `tau` (in second)\n<cite>[num_rx, num_tx, num_paths]</cite>.\nParameters\n\n- **cir_generator**  Generator that returns channel impulse responses `(a,` `tau)` where\n`a` is the tensor of channel coefficients of shape\n<cite>[num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps]</cite>\nand dtype `dtype`, and `tau` the tensor of path delays\nof shape  <cite>[num_rx, num_tx, num_paths]</cite> and dtype `dtype.`\n`real_dtype`.\n- **batch_size** (*int*)  Batch size\n- **num_rx** (*int*)  Number of receivers ($N_R$)\n- **num_rx_ant** (*int*)  Number of antennas per receiver ($N_{RA}$)\n- **num_tx** (*int*)  Number of transmitters ($N_T$)\n- **num_tx_ant** (*int*)  Number of antennas per transmitter ($N_{TA}$)\n- **num_paths** (*int*)  Number of paths ($M$)\n- **num_time_steps** (*int*)  Number of time steps\n- **dtype** (*tf.DType*)  Complex datatype to use for internal processing and output.\nDefaults to <cite>tf.complex64</cite>.\n\n\nOutput\n\n- **a** (*[batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex*)  Path coefficients\n- **tau** (*[batch size, num_rx, num_tx, num_paths], tf.float*)  Path delays [s]\n\n\n`property` `batch_size`\n\nBatch size"
"### subcarrier_frequencies\n\n`sionna.channel.``subcarrier_frequencies`(*`num_subcarriers`*, *`subcarrier_spacing`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/utils.html#subcarrier_frequencies)\n\nCompute the baseband frequencies of `num_subcarrier` subcarriers spaced by\n`subcarrier_spacing`, i.e.,\n```python\n>>> # If num_subcarrier is even:\n>>> frequencies = [-num_subcarrier/2, ..., 0, ..., num_subcarrier/2-1] * subcarrier_spacing\n>>>\n>>> # If num_subcarrier is odd:\n>>> frequencies = [-(num_subcarrier-1)/2, ..., 0, ..., (num_subcarrier-1)/2] * subcarrier_spacing\n```\n\nInput\n\n- **num_subcarriers** (*int*)  Number of subcarriers\n- **subcarrier_spacing** (*float*)  Subcarrier spacing [Hz]\n- **dtype** (*tf.DType*)  Datatype to use for internal processing and output.\nIf a complex datatype is provided, the corresponding precision of\nreal components is used.\nDefaults to <cite>tf.complex64</cite> (<cite>tf.float32</cite>).\n\n\nOutput\n\n**frequencies** ([`num_subcarrier`], tf.float)  Baseband frequencies of subcarriers"
"### time_lag_discrete_time_channel\n\n`sionna.channel.``time_lag_discrete_time_channel`(*`bandwidth`*, *`maximum_delay_spread``=``3e-06`*)[`[source]`](../_modules/sionna/channel/utils.html#time_lag_discrete_time_channel)\n\nCompute the smallest and largest time-lag for the descrete complex baseband\nchannel, i.e., $L_{\\text{min}}$ and $L_{\\text{max}}$.\n\nThe smallest time-lag ($L_{\\text{min}}$) returned is always -6, as this value\nwas found small enough for all models included in Sionna.\n\nThe largest time-lag ($L_{\\text{max}}$) is computed from the `bandwidth`\nand `maximum_delay_spread` as follows:\n\n$$\nL_{\\text{max}} = \\lceil W \\tau_{\\text{max}} \\rceil + 6\n$$\n\nwhere $L_{\\text{max}}$ is the largest time-lag, $W$ the `bandwidth`,\nand $\\tau_{\\text{max}}$ the `maximum_delay_spread`.\n\nThe default value for the `maximum_delay_spread` is 3us, which was found\nto be large enough to include most significant paths with all channel models\nincluded in Sionna assuming a nominal delay spread of 100ns.\n\n**Note**\n\nThe values of $L_{\\text{min}}$ and $L_{\\text{max}}$ computed\nby this function are only recommended values.\n$L_{\\text{min}}$ and $L_{\\text{max}}$ should be set according to\nthe considered channel model. For OFDM systems, one also needs to be careful\nthat the effective length of the complex baseband channel is not larger than\nthe cyclic prefix length.\n\nInput\n\n- **bandwidth** (*float*)  Bandwith ($W$) [Hz]\n- **maximum_delay_spread** (*float*)  Maximum delay spread [s]. Defaults to 3us.\n\n\nOutput\n\n- **l_min** (*int*)  Smallest time-lag ($L_{\\text{min}}$) for the descrete complex baseband\nchannel. Set to -6, , as this value was found small enough for all models\nincluded in Sionna.\n- **l_max** (*int*)  Largest time-lag ($L_{\\text{max}}$) for the descrete complex baseband\nchannel"
"### deg_2_rad\n\n`sionna.channel.``deg_2_rad`(*`x`*)[`[source]`](../_modules/sionna/channel/utils.html#deg_2_rad)\n\nConvert degree to radian\nInput\n\n**x** (*Tensor*)  Angles in degree\n\nOutput\n\n**y** (*Tensor*)  Angles `x` converted to radian"
"### rad_2_deg\n\n`sionna.channel.``rad_2_deg`(*`x`*)[`[source]`](../_modules/sionna/channel/utils.html#rad_2_deg)\n\nConvert radian to degree\nInput\n\n**x** (*Tensor*)  Angles in radian\n\nOutput\n\n**y** (*Tensor*)  Angles `x` converted to degree"
"### wrap_angle_0_360\n\n`sionna.channel.``wrap_angle_0_360`(*`angle`*)[`[source]`](../_modules/sionna/channel/utils.html#wrap_angle_0_360)\n\nWrap `angle` to (0,360)\nInput\n\n**angle** (*Tensor*)  Input to wrap\n\nOutput\n\n**y** (*Tensor*)  `angle` wrapped to (0,360)"
"### drop_uts_in_sector\n\n`sionna.channel.``drop_uts_in_sector`(*`batch_size`*, *`num_ut`*, *`min_bs_ut_dist`*, *`isd`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/utils.html#drop_uts_in_sector)\n\nUniformly sample UT locations from a sector.\n\nThe sector from which UTs are sampled is shown in the following figure.\nThe BS is assumed to be located at the origin (0,0) of the coordinate\nsystem.\n\n\nInput\n\n- **batch_size** (*int*)  Batch size\n- **num_ut** (*int*)  Number of UTs to sample per batch example\n- **min_bs_ut_dist** (*tf.float*)  Minimum BS-UT distance [m]\n- **isd** (*tf.float*)  Inter-site distance, i.e., the distance between two adjacent BSs [m]\n- **dtype** (*tf.DType*)  Datatype to use for internal processing and output.\nIf a complex datatype is provided, the corresponding precision of\nreal components is used.\nDefaults to <cite>tf.complex64</cite> (<cite>tf.float32</cite>).\n\n\nOutput\n\n**ut_loc** (*[batch_size, num_ut, 2], tf.float*)  UTs locations in the X-Y plan"
"### relocate_uts\n\n`sionna.channel.``relocate_uts`(*`ut_loc`*, *`sector_id`*, *`cell_loc`*)[`[source]`](../_modules/sionna/channel/utils.html#relocate_uts)\n\nRelocate the UTs by rotating them into the sector with index `sector_id`\nand transposing them to the cell centered on `cell_loc`.\n\n`sector_id` gives the index of the sector to which the UTs are\nrotated to. The picture below shows how the three sectors of a cell are\nindexed.\n\n ig. 9 Indexing of sectors\n\nIf `sector_id` is a scalar, then all UTs are relocated to the same\nsector indexed by `sector_id`.\nIf `sector_id` is a tensor, it should be broadcastable with\n[`batch_size`, `num_ut`], and give the sector in which each UT or\nbatch example is relocated to.\n\nWhen calling the function, `ut_loc` gives the locations of the UTs to\nrelocate, which are all assumed to be in sector with index 0, and in the\ncell centered on the origin (0,0).\nInput\n\n- **ut_loc** (*[batch_size, num_ut, 2], tf.float*)  UTs locations in the X-Y plan\n- **sector_id** (*Tensor broadcastable with [batch_size, num_ut], int*)  Indexes of the sector to which to relocate the UTs\n- **cell_loc** (*Tensor broadcastable with [batch_size, num_ut], tf.float*)  Center of the cell to which to transpose the UTs\n\n\nOutput\n\n**ut_loc** (*[batch_size, num_ut, 2], tf.float*)  Relocated UTs locations in the X-Y plan"
"### set_3gpp_scenario_parameters\n\n`sionna.channel.``set_3gpp_scenario_parameters`(*`scenario`*, *`min_bs_ut_dist``=``None`*, *`isd``=``None`*, *`bs_height``=``None`*, *`min_ut_height``=``None`*, *`max_ut_height``=``None`*, *`indoor_probability``=``None`*, *`min_ut_velocity``=``None`*, *`max_ut_velocity``=``None`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/utils.html#set_3gpp_scenario_parameters)\n\nSet valid parameters for a specified 3GPP system level `scenario`\n(RMa, UMi, or UMa).\n\nIf a parameter is given, then it is returned. If it is set to <cite>None</cite>,\nthen a parameter valid according to the chosen scenario is returned\n(see [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901)).\nInput\n\n- **scenario** (*str*)  System level model scenario. Must be one of rma, umi, or uma.\n- **min_bs_ut_dist** (*None or tf.float*)  Minimum BS-UT distance [m]\n- **isd** (*None or tf.float*)  Inter-site distance [m]\n- **bs_height** (*None or tf.float*)  BS elevation [m]\n- **min_ut_height** (*None or tf.float*)  Minimum UT elevation [m]\n- **max_ut_height** (*None or tf.float*)  Maximum UT elevation [m]\n- **indoor_probability** (*None or tf.float*)  Probability of a UT to be indoor\n- **min_ut_velocity** (*None or tf.float*)  Minimum UT velocity [m/s]\n- **max_ut_velocity** (*None or tf.float*)  Maximim UT velocity [m/s]\n- **dtype** (*tf.DType*)  Datatype to use for internal processing and output.\nIf a complex datatype is provided, the corresponding precision of\nreal components is used.\nDefaults to <cite>tf.complex64</cite> (<cite>tf.float32</cite>).\n\n\nOutput\n\n- **min_bs_ut_dist** (*tf.float*)  Minimum BS-UT distance [m]\n- **isd** (*tf.float*)  Inter-site distance [m]\n- **bs_height** (*tf.float*)  BS elevation [m]\n- **min_ut_height** (*tf.float*)  Minimum UT elevation [m]\n- **max_ut_height** (*tf.float*)  Maximum UT elevation [m]\n- **indoor_probability** (*tf.float*)  Probability of a UT to be indoor\n- **min_ut_velocity** (*tf.float*)  Minimum UT velocity [m/s]\n- **max_ut_velocity** (*tf.float*)  Maximim UT velocity [m/s]"
"### gen_single_sector_topology\n\n`sionna.channel.``gen_single_sector_topology`(*`batch_size`*, *`num_ut`*, *`scenario`*, *`min_bs_ut_dist``=``None`*, *`isd``=``None`*, *`bs_height``=``None`*, *`min_ut_height``=``None`*, *`max_ut_height``=``None`*, *`indoor_probability``=``None`*, *`min_ut_velocity``=``None`*, *`max_ut_velocity``=``None`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/utils.html#gen_single_sector_topology)\n\nGenerate a batch of topologies consisting of a single BS located at the\norigin and `num_ut` UTs randomly and uniformly dropped in a cell sector.\n\nThe following picture shows the sector from which UTs are sampled.\n\n\nUTs orientations are randomly and uniformly set, whereas the BS orientation\nis set such that the it is oriented towards the center of the sector.\n\nThe drop configuration can be controlled through the optional parameters.\nParameters set to <cite>None</cite> are set to valid values according to the chosen\n`scenario` (see [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901)).\n\nThe returned batch of topologies can be used as-is with the\n`set_topology()` method of the system level models, i.e.\n[`UMi`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMi), [`UMa`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMa),\nand [`RMa`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.RMa).\n xample\n```python\n>>> # Create antenna arrays\n>>> bs_array = PanelArray(num_rows_per_panel = 4,\n...                      num_cols_per_panel = 4,\n...                      polarization = 'dual',\n...                      polarization_type = 'VH',\n...                      antenna_pattern = '38.901',\n...                      carrier_frequency = 3.5e9)\n>>>\n>>> ut_array = PanelArray(num_rows_per_panel = 1,\n...                       num_cols_per_panel = 1,\n...                       polarization = 'single',\n...                       polarization_type = 'V',\n...                       antenna_pattern = 'omni',\n...                       carrier_frequency = 3.5e9)\n>>> # Create channel model\n>>> channel_model = UMi(carrier_frequency = 3.5e9,\n...                     o2i_model = 'low',\n...                     ut_array = ut_array,\n...                     bs_array = bs_array,\n...                     direction = 'uplink')\n>>> # Generate the topology\n>>> topology = gen_single_sector_topology(batch_size = 100,\n...                                       num_ut = 4,\n...                                       scenario = 'umi')\n>>> # Set the topology\n>>> ut_loc, bs_loc, ut_orientations, bs_orientations, ut_velocities, in_state = topology\n>>> channel_model.set_topology(ut_loc,\n...                            bs_loc,\n...                            ut_orientations,\n...                            bs_orientations,\n...                            ut_velocities,\n...                            in_state)\n>>> channel_model.show_topology()\n```"
"Input\n\n- **batch_size** (*int*)  Batch size\n- **num_ut** (*int*)  Number of UTs to sample per batch example\n- **scenario** (*str*)  System leven model scenario. Must be one of rma, umi, or uma.\n- **min_bs_ut_dist** (*None or tf.float*)  Minimum BS-UT distance [m]\n- **isd** (*None or tf.float*)  Inter-site distance [m]\n- **bs_height** (*None or tf.float*)  BS elevation [m]\n- **min_ut_height** (*None or tf.float*)  Minimum UT elevation [m]\n- **max_ut_height** (*None or tf.float*)  Maximum UT elevation [m]\n- **indoor_probability** (*None or tf.float*)  Probability of a UT to be indoor\n- **min_ut_velocity** (*None or tf.float*)  Minimum UT velocity [m/s]\n- **max_ut_velocity** (*None or tf.float*)  Maximim UT velocity [m/s]\n- **dtype** (*tf.DType*)  Datatype to use for internal processing and output.\nIf a complex datatype is provided, the corresponding precision of\nreal components is used.\nDefaults to <cite>tf.complex64</cite> (<cite>tf.float32</cite>).\n\n\nOutput\n\n- **ut_loc** (*[batch_size, num_ut, 3], tf.float*)  UTs locations\n- **bs_loc** (*[batch_size, 1, 3], tf.float*)  BS location. Set to (0,0,0) for all batch examples.\n- **ut_orientations** (*[batch_size, num_ut, 3], tf.float*)  UTs orientations [radian]\n- **bs_orientations** (*[batch_size, 1, 3], tf.float*)  BS orientations [radian]. Oriented towards the center of the sector.\n- **ut_velocities** (*[batch_size, num_ut, 3], tf.float*)  UTs velocities [m/s]\n- **in_state** (*[batch_size, num_ut], tf.float*)  Indoor/outdoor state of UTs. <cite>True</cite> means indoor, <cite>False</cite> means\noutdoor."
"### gen_single_sector_topology_interferers\n\n`sionna.channel.``gen_single_sector_topology_interferers`(*`batch_size`*, *`num_ut`*, *`num_interferer`*, *`scenario`*, *`min_bs_ut_dist``=``None`*, *`isd``=``None`*, *`bs_height``=``None`*, *`min_ut_height``=``None`*, *`max_ut_height``=``None`*, *`indoor_probability``=``None`*, *`min_ut_velocity``=``None`*, *`max_ut_velocity``=``None`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/utils.html#gen_single_sector_topology_interferers)\n\nGenerate a batch of topologies consisting of a single BS located at the\norigin, `num_ut` UTs randomly and uniformly dropped in a cell sector, and\n`num_interferer` interfering UTs randomly dropped in the adjacent cells.\n\nThe following picture shows how UTs are sampled\n\n\nUTs orientations are randomly and uniformly set, whereas the BS orientation\nis set such that it is oriented towards the center of the sector it\nserves.\n\nThe drop configuration can be controlled through the optional parameters.\nParameters set to <cite>None</cite> are set to valid values according to the chosen\n`scenario` (see [[TR38901]](https://nvlabs.github.io/sionna/api/channel.wireless.html#tr38901)).\n\nThe returned batch of topologies can be used as-is with the\n`set_topology()` method of the system level models, i.e.\n[`UMi`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMi), [`UMa`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.UMa),\nand [`RMa`](https://nvlabs.github.io/sionna/api/channel.wireless.html#sionna.channel.tr38901.RMa).\n\nIn the returned `ut_loc`, `ut_orientations`, `ut_velocities`, and\n`in_state` tensors, the first `num_ut` items along the axis with index\n1 correspond to the served UTs, whereas the remaining `num_interferer`\nitems correspond to the interfering UTs.\n xample"
"```python\n>>> # Create antenna arrays\n>>> bs_array = PanelArray(num_rows_per_panel = 4,\n...                      num_cols_per_panel = 4,\n...                      polarization = 'dual',\n...                      polarization_type = 'VH',\n...                      antenna_pattern = '38.901',\n...                      carrier_frequency = 3.5e9)\n>>>\n>>> ut_array = PanelArray(num_rows_per_panel = 1,\n...                       num_cols_per_panel = 1,\n...                       polarization = 'single',\n...                       polarization_type = 'V',\n...                       antenna_pattern = 'omni',\n...                       carrier_frequency = 3.5e9)\n>>> # Create channel model\n>>> channel_model = UMi(carrier_frequency = 3.5e9,\n...                     o2i_model = 'low',\n...                     ut_array = ut_array,\n...                     bs_array = bs_array,\n...                     direction = 'uplink')\n>>> # Generate the topology\n>>> topology = gen_single_sector_topology_interferers(batch_size = 100,\n...                                                   num_ut = 4,\n...                                                   num_interferer = 4,\n...                                                   scenario = 'umi')\n>>> # Set the topology\n>>> ut_loc, bs_loc, ut_orientations, bs_orientations, ut_velocities, in_state = topology\n>>> channel_model.set_topology(ut_loc,\n...                            bs_loc,\n...                            ut_orientations,\n...                            bs_orientations,\n...                            ut_velocities,\n...                            in_state)\n>>> channel_model.show_topology()\n```\n\nInput\n\n- **batch_size** (*int*)  Batch size\n- **num_ut** (*int*)  Number of UTs to sample per batch example\n- **num_interferer** (*int*)  Number of interfeering UTs per batch example\n- **scenario** (*str*)  System leven model scenario. Must be one of rma, umi, or uma.\n- **min_bs_ut_dist** (*None or tf.float*)  Minimum BS-UT distance [m]\n- **isd** (*None or tf.float*)  Inter-site distance [m]\n- **bs_height** (*None or tf.float*)  BS elevation [m]\n- **min_ut_height** (*None or tf.float*)  Minimum UT elevation [m]\n- **max_ut_height** (*None or tf.float*)  Maximum UT elevation [m]\n- **indoor_probability** (*None or tf.float*)  Probability of a UT to be indoor\n- **min_ut_velocity** (*None or tf.float*)  Minimum UT velocity [m/s]\n- **max_ut_velocity** (*None or tf.float*)  Maximim UT velocity [m/s]\n- **dtype** (*tf.DType*)  Datatype to use for internal processing and output.\nIf a complex datatype is provided, the corresponding precision of\nreal components is used.\nDefaults to <cite>tf.complex64</cite> (<cite>tf.float32</cite>).\n\n\nOutput\n\n- **ut_loc** (*[batch_size, num_ut, 3], tf.float*)  UTs locations. The first `num_ut` items along the axis with index\n1 correspond to the served UTs, whereas the remaining\n`num_interferer` items correspond to the interfeering UTs.\n- **bs_loc** (*[batch_size, 1, 3], tf.float*)  BS location. Set to (0,0,0) for all batch examples.\n- **ut_orientations** (*[batch_size, num_ut, 3], tf.float*)  UTs orientations [radian]. The first `num_ut` items along the\naxis with index 1 correspond to the served UTs, whereas the\nremaining `num_interferer` items correspond to the interfeering\nUTs.\n- **bs_orientations** (*[batch_size, 1, 3], tf.float*)  BS orientation [radian]. Oriented towards the center of the sector.\n- **ut_velocities** (*[batch_size, num_ut, 3], tf.float*)  UTs velocities [m/s]. The first `num_ut` items along the axis\nwith index 1 correspond to the served UTs, whereas the remaining\n`num_interferer` items correspond to the interfeering UTs.\n- **in_state** (*[batch_size, num_ut], tf.float*)  Indoor/outdoor state of UTs. <cite>True</cite> means indoor, <cite>False</cite> means\noutdoor. The first `num_ut` items along the axis with\nindex 1 correspond to the served UTs, whereas the remaining\n`num_interferer` items correspond to the interfeering UTs."
"### exp_corr_mat\n\n`sionna.channel.``exp_corr_mat`(*`a`*, *`n`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/utils.html#exp_corr_mat)\n\nGenerate exponential correlation matrices.\n\nThis function computes for every element $a$ of a complex-valued\ntensor $\\mathbf{a}$ the corresponding $n\\times n$ exponential\ncorrelation matrix $\\mathbf{R}(a,n)$, defined as (Eq. 1, [[MAL2018]](https://nvlabs.github.io/sionna/api/channel.wireless.html#mal2018)):\n\n$$\n\\begin{split}\\mathbf{R}(a,n)_{i,j} = \\begin{cases}\n            1 & \\text{if } i=j\\\\\n            a^{i-j}  & \\text{if } i>j\\\\\n            (a^\\star)^{j-i}  & \\text{if } j<i, j=1,\\dots,n\\\\\n          \\end{cases}\\end{split}\n$$\n\nwhere $|a|<1$ and $\\mathbf{R}\\in\\mathbb{C}^{n\\times n}$.\nInput\n\n- **a** (*[n_0, , n_k], tf.complex*)  A tensor of arbitrary rank whose elements\nhave an absolute value smaller than one.\n- **n** (*int*)  Number of dimensions of the output correlation matrices.\n- **dtype** (*tf.complex64, tf.complex128*)  The dtype of the output.\n\n\nOutput\n\n**R** (*[n_0, , n_k, n, n], tf.complex*)  A tensor of the same dtype as the input tensor $\\mathbf{a}$."
"### one_ring_corr_mat\n\n`sionna.channel.``one_ring_corr_mat`(*`phi_deg`*, *`num_ant`*, *`d_h``=``0.5`*, *`sigma_phi_deg``=``15`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/channel/utils.html#one_ring_corr_mat)\n\nGenerate covariance matrices from the one-ring model.\n\nThis function generates approximate covariance matrices for the\nso-called <cite>one-ring</cite> model (Eq. 2.24) [[BHS2017]](https://nvlabs.github.io/sionna/api/channel.wireless.html#bhs2017). A uniform\nlinear array (ULA) with uniform antenna spacing is assumed. The elements\nof the covariance matrices are computed as:\n\n$$\n\\mathbf{R}_{\\ell,m} =\n      \\exp\\left( j2\\pi d_\\text{H} (\\ell -m)\\sin(\\varphi) \\right)\n      \\exp\\left( -\\frac{\\sigma_\\varphi^2}{2}\n      \\left( 2\\pi d_\\text{H}(\\ell -m)\\cos(\\varphi) \\right)^2 \\right)\n$$\n\nfor $\\ell,m = 1,\\dots, M$, where $M$ is the number of antennas,\n$\\varphi$ is the angle of arrival, $d_\\text{H}$ is the antenna\nspacing in multiples of the wavelength,\nand $\\sigma^2_\\varphi$ is the angular standard deviation.\nInput\n\n- **phi_deg** (*[n_0, , n_k], tf.float*)  A tensor of arbitrary rank containing azimuth angles (deg) of arrival.\n- **num_ant** (*int*)  Number of antennas\n- **d_h** (*float*)  Antenna spacing in multiples of the wavelength. Defaults to 0.5.\n- **sigma_phi_deg** (*float*)  Angular standard deviation (deg). Defaults to 15 (deg). Values greater\nthan 15 should not be used as the approximation becomes invalid.\n- **dtype** (*tf.complex64, tf.complex128*)  The dtype of the output.\n\n\nOutput\n\n**R** ([n_0, , n_k, num_ant, nun_ant], <cite>dtype</cite>)  Tensor containing the covariance matrices of the desired dtype.\n\n\nReferences:\nTR38901([1](https://nvlabs.github.io/sionna/api/channel.wireless.html#id1),[2](https://nvlabs.github.io/sionna/api/channel.wireless.html#id2),[3](https://nvlabs.github.io/sionna/api/channel.wireless.html#id4),[4](https://nvlabs.github.io/sionna/api/channel.wireless.html#id5),[5](https://nvlabs.github.io/sionna/api/channel.wireless.html#id6),[6](https://nvlabs.github.io/sionna/api/channel.wireless.html#id7),[7](https://nvlabs.github.io/sionna/api/channel.wireless.html#id8),[8](https://nvlabs.github.io/sionna/api/channel.wireless.html#id11),[9](https://nvlabs.github.io/sionna/api/channel.wireless.html#id12),[10](https://nvlabs.github.io/sionna/api/channel.wireless.html#id13),[11](https://nvlabs.github.io/sionna/api/channel.wireless.html#id14),[12](https://nvlabs.github.io/sionna/api/channel.wireless.html#id15),[13](https://nvlabs.github.io/sionna/api/channel.wireless.html#id16),[14](https://nvlabs.github.io/sionna/api/channel.wireless.html#id17),[15](https://nvlabs.github.io/sionna/api/channel.wireless.html#id18),[16](https://nvlabs.github.io/sionna/api/channel.wireless.html#id19),[17](https://nvlabs.github.io/sionna/api/channel.wireless.html#id20),[18](https://nvlabs.github.io/sionna/api/channel.wireless.html#id21),[19](https://nvlabs.github.io/sionna/api/channel.wireless.html#id25),[20](https://nvlabs.github.io/sionna/api/channel.wireless.html#id26),[21](https://nvlabs.github.io/sionna/api/channel.wireless.html#id27))\n\n3GPP TR 38.901,\nStudy on channel model for frequencies from 0.5 to 100 GHz, Release 16.1\n\n[TS38141-1](https://nvlabs.github.io/sionna/api/channel.wireless.html#id10)\n\n3GPP TS 38.141-1\nBase Station (BS) conformance testing Part 1: Conducted conformance testing,\nRelease 17\n\n[Tse](https://nvlabs.github.io/sionna/api/channel.wireless.html#id3)\n\nD. Tse and P. Viswanath, Fundamentals of wireless communication,\nCambridge university press, 2005.\n\n[SoS](https://nvlabs.github.io/sionna/api/channel.wireless.html#id9)\n<ol class=\"upperalpha simple\" start=\"3\">\n- Xiao, Y. R. Zheng and N. C. Beaulieu, Novel Sum-of-Sinusoids Simulation Models for Rayleigh and Rician Fading Channels, in IEEE Transactions on Wireless Communications, vol. 5, no. 12, pp. 3667-3679, December 2006, doi: 10.1109/TWC.2006.256990.\n</ol>\n\n[MAL2018](https://nvlabs.github.io/sionna/api/channel.wireless.html#id28)\n\nRanjan K. Mallik,\nThe exponential correlation matrix: Eigen-analysis and\napplications, IEEE Trans. Wireless Commun., vol. 17, no. 7,\npp. 4690-4705, Jul. 2018.\n\n[BHS2017](https://nvlabs.github.io/sionna/api/channel.wireless.html#id29)\n\nEmil Bjrnson, Jakob Hoydis and Luca Sanguinetti (2017),\n[Massive MIMO Networks: Spectral, Energy, and Hardware Efficiency](https://massivemimobook.com),\nFoundations and Trends in Signal Processing:\nVol. 11, No. 3-4, pp 154655."

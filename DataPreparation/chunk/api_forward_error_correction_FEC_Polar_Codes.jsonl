"# Polar Codes\n\nThe Polar code module supports 5G-compliant Polar codes and includes successive cancellation (SC), successive cancellation list (SCL), and belief propagation (BP) decoding.\n\nThe module supports rate-matching and CRC-aided decoding.\nFurther, Reed-Muller (RM) code design is available and can be used in combination with the Polar encoding/decoding algorithms.\n\nThe following code snippets show how to setup and run a rate-matched 5G compliant Polar encoder and a corresponding successive cancellation list (SCL) decoder.\n\nFirst, we need to create instances of [`Polar5GEncoder`](https://nvlabs.github.io/sionna/api/fec.polar.html#sionna.fec.polar.encoding.Polar5GEncoder) and [`Polar5GDecoder`](https://nvlabs.github.io/sionna/api/fec.polar.html#sionna.fec.polar.decoding.Polar5GDecoder):\n```python\nencoder = Polar5GEncoder(k          = 100, # number of information bits (input)\n                         n          = 200) # number of codeword bits (output)\n\ndecoder = Polar5GDecoder(encoder    = encoder, # connect the Polar decoder to the encoder\n                         dec_type   = \"SCL\", # can be also \"SC\" or \"BP\"\n                         list_size  = 8)\n```\n\n\nNow, the encoder and decoder can be used by:\n```python\n# --- encoder ---\n# u contains the information bits to be encoded and has shape [...,k].\n# c contains the polar encoded codewords and has shape [...,n].\nc = encoder(u)\n# --- decoder ---\n# llr contains the log-likelihood ratios from the demapper and has shape [...,n].\n# u_hat contains the estimated information bits and has shape [...,k].\nu_hat = decoder(llr)\n```"
"### Polar5GEncoder\n\n`class` `sionna.fec.polar.encoding.``Polar5GEncoder`(*`k`*, *`n`*, *`verbose``=``False`*, *`channel_type``=``'uplink'`*, *`dtype``=``tf.float32`*)[`[source]`](../_modules/sionna/fec/polar/encoding.html#Polar5GEncoder)\n\n5G compliant Polar encoder including rate-matching following [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212)\nfor the uplink scenario (<cite>UCI</cite>) and downlink scenario (<cite>DCI</cite>).\n\nThis layer performs polar encoding for `k` information bits and\nrate-matching such that the codeword lengths is `n`. This includes the CRC\nconcatenation and the interleaving as defined in [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212).\n\nNote: <cite>block segmentation</cite> is currently not supported (<cite>I_seq=False</cite>).\n\nWe follow the basic structure from Fig. 6 in [[Bioglio_Design]](https://nvlabs.github.io/sionna/api/fec.polar.html#bioglio-design).\n ig. 6 Fig. 1: Implemented 5G Polar encoding chain following Fig. 6 in\n[[Bioglio_Design]](https://nvlabs.github.io/sionna/api/fec.polar.html#bioglio-design) for the uplink (<cite>I_BIL</cite> = <cite>True</cite>) and the downlink\n(<cite>I_IL</cite> = <cite>True</cite>) scenario without <cite>block segmentation</cite>.\n\nFor further details, we refer to [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212), [[Bioglio_Design]](https://nvlabs.github.io/sionna/api/fec.polar.html#bioglio-design) and\n[[Hui_ChannelCoding]](https://nvlabs.github.io/sionna/api/fec.polar.html#hui-channelcoding).\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model. Further, the class inherits from PolarEncoder.\nParameters\n\n- **k** (*int*)  Defining the number of information bit per codeword.\n- **n** (*int*)  Defining the codeword length.\n- **channel_type** (*str*)  Defaults to uplink. Can be uplink or downlink.\n- **verbose** (*bool*)  Defaults to False. If True, rate-matching parameters will be\nprinted.\n- **dtype** (*tf.DType*)  Defaults to tf.float32. Defines the output datatype of the layer\n(internal precision remains tf.uint8).\n\n\nInput\n\n**inputs** (*[,k], tf.float32*)  2+D tensor containing the information bits to be encoded.\n\nOutput\n\n*[,n], tf.float32*  2+D tensor containing the codeword bits.\n\nRaises\n\n- **AssertionError**  `k` and `n` must be positive integers and `k` must be smaller\n    (or equal) than `n`.\n- **AssertionError**  If `n` and `k` are invalid code parameters (see [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212)).\n- **AssertionError**  If `verbose` is not <cite>bool</cite>.\n- **ValueError**  If `dtype` is not supported.\n\n\n**Note**\n\nThe encoder supports the <cite>uplink</cite> Polar coding (<cite>UCI</cite>) scheme from\n[[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212) and the <cite>downlink</cite> Polar coding (<cite>DCI</cite>) [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212),\nrespectively.\n\nFor <cite>12 <= k <= 19</cite> the 3 additional parity bits as defined in\n[[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212) are not implemented as it would also require a\nmodified decoding procedure to materialize the potential gains.\n\n<cite>Code segmentation</cite> is currently not supported and, thus, `n` is\nlimited to a maximum length of 1088 codeword bits.\n\nFor the downlink scenario, the input length is limited to <cite>k <= 140</cite>\ninformation bits due to the limited input bit interleaver size\n[[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212).\n\nFor simplicity, the implementation does not exactly re-implement the\n<cite>DCI</cite> scheme from [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212). This implementation neglects the\n<cite>all-one</cite> initialization of the CRC shift register and the scrambling of the CRC parity bits with the <cite>RNTI</cite>.\n\n`channel_interleaver`(*`c`*)[`[source]`](../_modules/sionna/fec/polar/encoding.html#Polar5GEncoder.channel_interleaver)\n\nTriangular interleaver following Sec. 5.4.1.3 in [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212).\nInput\n\n**c** (*ndarray*)  1D array to be interleaved.\n\nOutput\n\n*ndarray*  Interleaved version of `c` with same shape and dtype as `c`.\n\n\n`property` `enc_crc`\n\nCRC encoder layer used for CRC concatenation.\n\n\n`input_interleaver`(*`c`*)[`[source]`](../_modules/sionna/fec/polar/encoding.html#Polar5GEncoder.input_interleaver)\n\nInput interleaver following Sec. 5.4.1.1 in [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212).\nInput\n\n**c** (*ndarray*)  1D array to be interleaved.\n\nOutput\n\n*ndarray*  Interleaved version of `c` with same shape and dtype as `c`.\n\n\n`property` `k`\n\nNumber of information bits including rate-matching.\n\n\n`property` `k_polar`\n\nNumber of information bits of the underlying Polar code.\n\n\n`property` `k_target`\n\nNumber of information bits including rate-matching.\n\n\n`property` `n`\n\nCodeword length including rate-matching.\n\n\n`property` `n_polar`\n\nCodeword length of the underlying Polar code.\n\n\n`property` `n_target`\n\nCodeword length including rate-matching.\n\n\n`subblock_interleaving`(*`u`*)[`[source]`](../_modules/sionna/fec/polar/encoding.html#Polar5GEncoder.subblock_interleaving)\n\nInput bit interleaving as defined in Sec 5.4.1.1 [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212).\nInput\n\n**u** (*ndarray*)  1D array to be interleaved. Length of `u` must be a multiple\nof 32.\n\nOutput\n\n*ndarray*  Interleaved version of `u` with same shape and dtype as `u`.\n\nRaises\n\n**AssertionError**  If length of `u` is not a multiple of 32."
"### PolarEncoder\n\n`class` `sionna.fec.polar.encoding.``PolarEncoder`(*`frozen_pos`*, *`n`*, *`dtype``=``tf.float32`*)[`[source]`](../_modules/sionna/fec/polar/encoding.html#PolarEncoder)\n\nPolar encoder for given code parameters.\n\nThis layer performs polar encoding for the given `k` information bits and\nthe <cite>frozen set</cite> (i.e., indices of frozen positions) specified by\n`frozen_pos`.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **frozen_pos** (*ndarray*)  Array of <cite>int</cite> defining the <cite>n-k</cite> frozen indices, i.e., information\nbits are mapped onto the <cite>k</cite> complementary positions.\n- **n** (*int*)  Defining the codeword length.\n- **dtype** (*tf.DType*)  Defaults to <cite>tf.float32</cite>. Defines the output datatype of the layer\n(internal precision is <cite>tf.uint8</cite>).\n\n\nInput\n\n**inputs** (*[,k], tf.float32*)  2+D tensor containing the information bits to be encoded.\n\nOutput\n\n*[,n], tf.float32*  2+D tensor containing the codeword bits.\n\nRaises\n\n- **AssertionError**  `k` and `n` must be positive integers and `k` must be smaller\n    (or equal) than `n`.\n- **AssertionError**  If `n` is not a power of 2.\n- **AssertionError**  If the number of elements in `frozen_pos` is great than `n`.\n- **AssertionError**  If `frozen_pos` does not consists of <cite>int</cite>.\n- **ValueError**  If `dtype` is not supported.\n- **ValueError**  If `inputs` contains other values than <cite>0</cite> or <cite>1</cite>.\n- **TypeError**  If `inputs` is not <cite>tf.float32</cite>.\n- **InvalidArgumentError**  When rank(`inputs`)<2.\n- **InvalidArgumentError**  When shape of last dim is not `k`.\n\n\n**Note**\n\nAs commonly done, we assume frozen bits are set to <cite>0</cite>. Please note\nthat - although its practical relevance is only little - setting frozen\nbits to <cite>1</cite> may result in <cite>affine</cite> codes instead of linear code as the\n<cite>all-zero</cite> codeword is not necessarily part of the code any more.\n\n`property` `frozen_pos`\n\nFrozen positions for Polar decoding.\n\n\n`property` `info_pos`\n\nInformation bit positions for Polar encoding.\n\n\n`property` `k`\n\nNumber of information bits.\n\n\n`property` `n`\n\nCodeword length."
"### Polar5GDecoder\n\n`class` `sionna.fec.polar.decoding.``Polar5GDecoder`(*`enc_polar`*, *`dec_type``=``'SC'`*, *`list_size``=``8`*, *`num_iter``=``20`*, *`return_crc_status``=``False`*, *`output_dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/polar/decoding.html#Polar5GDecoder)\n\nWrapper for 5G compliant decoding including rate-recovery and CRC removal.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **enc_polar** ()  Instance of the [`Polar5GEncoder`](https://nvlabs.github.io/sionna/api/fec.polar.html#sionna.fec.polar.encoding.Polar5GEncoder)\nused for encoding including rate-matching.\n- **dec_type** (*str*)  Defaults to <cite>SC</cite>. Defining the decoder to be used.\nMust be one of the following <cite>{SC, SCL, hybSCL, BP}</cite>.\n- **list_size** (*int*)  Defaults to 8. Defining the list size <cite>iff</cite> list-decoding is used.\nOnly required for `dec_types` <cite>{SCL, hybSCL}</cite>.\n- **num_iter** (*int*)  Defaults to 20. Defining the number of BP iterations. Only required\nfor `dec_type` <cite>BP</cite>.\n- **return_crc_status** (*bool*)  Defaults to False. If True, the decoder additionally returns the\nCRC status indicating if a codeword was (most likely) correctly\nrecovered.\n- **output_dtype** (*tf.DType*)  Defaults to tf.float32. Defines the output datatype of the layer\n(internal precision remains tf.float32).\n\n\nInput\n\n**inputs** (*[,n], tf.float32*)  2+D tensor containing the channel logits/llr values.\n\nOutput\n\n- **b_hat** (*[,k], tf.float32*)  2+D tensor containing hard-decided estimations of all <cite>k</cite>\ninformation bits.\n- **crc_status** (*[], tf.bool*)  CRC status indicating if a codeword was (most likely) correctly\nrecovered. This is only returned if `return_crc_status` is True.\nNote that false positives are possible.\n\n\nRaises\n\n- **AssertionError**  If `enc_polar` is not <cite>Polar5GEncoder</cite>.\n- **ValueError**  If `dec_type` is not <cite>{SC, SCL, SCL8, SCL32, hybSCL,\n    BP}</cite>.\n- **AssertionError**  If `dec_type` is not <cite>str</cite>.\n- **ValueError**  If `inputs` is not of shape <cite>[, n]</cite> or <cite>dtype</cite> is not\n    the same as `output_dtype`.\n- **InvalidArgumentError**  When rank(`inputs`)<2.\n\n\n**Note**\n\nThis layer supports the uplink and downlink Polar rate-matching scheme\nwithout <cite>codeword segmentation</cite>.\n\nAlthough the decoding <cite>list size</cite> is not provided by 3GPP\n[[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212), the consortium has agreed on a <cite>list size</cite> of 8 for the\n5G decoding reference curves [[Bioglio_Design]](https://nvlabs.github.io/sionna/api/fec.polar.html#bioglio-design).\n\nAll list-decoders apply <cite>CRC-aided</cite> decoding, however, the non-list\ndecoders (<cite>SC</cite> and <cite>BP</cite>) cannot materialize the CRC leading to an\neffective rate-loss.\n\n`property` `dec_type`\n\nDecoder type used for decoding as str.\n\n\n`property` `frozen_pos`\n\nFrozen positions for Polar decoding.\n\n\n`property` `info_pos`\n\nInformation bit positions for Polar encoding.\n\n\n`property` `k_polar`\n\nNumber of information bits of mother Polar code.\n\n\n`property` `k_target`\n\nNumber of information bits including rate-matching.\n\n\n`property` `llr_max`\n\nMaximum LLR value for internal calculations.\n\n\n`property` `n_polar`\n\nCodeword length of mother Polar code.\n\n\n`property` `n_target`\n\nCodeword length including rate-matching.\n\n\n`property` `output_dtype`\n\nOutput dtype of decoder.\n\n\n`property` `polar_dec`\n\nDecoder instance used for decoding."
"### PolarSCDecoder\n\n`class` `sionna.fec.polar.decoding.``PolarSCDecoder`(*`frozen_pos`*, *`n`*, *`output_dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/polar/decoding.html#PolarSCDecoder)\n\nSuccessive cancellation (SC) decoder [[Arikan_Polar]](https://nvlabs.github.io/sionna/api/fec.polar.html#arikan-polar) for Polar codes and\nPolar-like codes.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **frozen_pos** (*ndarray*)  Array of <cite>int</cite> defining the `n-k` indices of the frozen positions.\n- **n**  Defining the codeword length.\n\n\nInput\n\n**inputs** (*[,n], tf.float32*)  2+D tensor containing the channel LLR values (as logits).\n\nOutput\n\n*[,k], tf.float32*  2+D tensor  containing hard-decided estimations of all `k`\ninformation bits.\n\nRaises\n\n- **AssertionError**  If `n` is not <cite>int</cite>.\n- **AssertionError**  If `n` is not a power of 2.\n- **AssertionError**  If the number of elements in `frozen_pos` is greater than `n`.\n- **AssertionError**  If `frozen_pos` does not consists of <cite>int</cite>.\n- **ValueError**  If `output_dtype` is not {tf.float16, tf.float32, tf.float64}.\n\n\n**Note**\n\nThis layer implements the SC decoder as described in\n[[Arikan_Polar]](https://nvlabs.github.io/sionna/api/fec.polar.html#arikan-polar). However, the implementation follows the <cite>recursive\ntree</cite> [[Gross_Fast_SCL]](https://nvlabs.github.io/sionna/api/fec.polar.html#gross-fast-scl) terminology and combines nodes for increased\nthroughputs without changing the outcome of the algorithm.\n\nAs commonly done, we assume frozen bits are set to <cite>0</cite>. Please note\nthat - although its practical relevance is only little - setting frozen\nbits to <cite>1</cite> may result in <cite>affine</cite> codes instead of linear code as the\n<cite>all-zero</cite> codeword is not necessarily part of the code any more.\n\n`property` `frozen_pos`\n\nFrozen positions for Polar decoding.\n\n\n`property` `info_pos`\n\nInformation bit positions for Polar encoding.\n\n\n`property` `k`\n\nNumber of information bits.\n\n\n`property` `llr_max`\n\nMaximum LLR value for internal calculations.\n\n\n`property` `n`\n\nCodeword length.\n\n\n`property` `output_dtype`\n\nOutput dtype of decoder."
"### PolarSCLDecoder\n\n`class` `sionna.fec.polar.decoding.``PolarSCLDecoder`(*`frozen_pos`*, *`n`*, *`list_size``=``8`*, *`crc_degree``=``None`*, *`use_hybrid_sc``=``False`*, *`use_fast_scl``=``True`*, *`cpu_only``=``False`*, *`use_scatter``=``False`*, *`ind_iil_inv``=``None`*, *`return_crc_status``=``False`*, *`output_dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/polar/decoding.html#PolarSCLDecoder)\n\nSuccessive cancellation list (SCL) decoder [[Tal_SCL]](https://nvlabs.github.io/sionna/api/fec.polar.html#tal-scl) for Polar codes\nand Polar-like codes.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **frozen_pos** (*ndarray*)  Array of <cite>int</cite> defining the `n-k` indices of the frozen positions.\n- **n** (*int*)  Defining the codeword length.\n- **list_size** (*int*)  Defaults to 8. Defines the list size of the decoder.\n- **crc_degree** (*str*)  Defining the CRC polynomial to be used. Can be any value from\n<cite>{CRC24A, CRC24B, CRC24C, CRC16, CRC11, CRC6}</cite>.\n- **use_hybrid_sc** (*bool*)  Defaults to False. If True, SC decoding is applied and only the\ncodewords with invalid CRC are decoded with SCL. This option\nrequires an outer CRC specified via `crc_degree`.\nRemark: hybrid_sc does not support XLA optimization, i.e.,\n<cite>@tf.function(jit_compile=True)</cite>.\n- **use_fast_scl** (*bool*)  Defaults to True. If True, Tree pruning is used to\nreduce the decoding complexity. The output is equivalent to the\nnon-pruned version (besides numerical differences).\n- **cpu_only** (*bool*)  Defaults to False. If True, <cite>tf.py_function</cite> embedding\nis used and the decoder runs on the CPU. This option is usually\nslower, but also more memory efficient and, in particular,\nrecommended for larger blocklengths. Remark: cpu_only does not\nsupport XLA optimization <cite>@tf.function(jit_compile=True)</cite>.\n- **use_scatter** (*bool*)  Defaults to False. If True, <cite>tf.tensor_scatter_update</cite> is used for\ntensor updates. This option is usually slower, but more memory\nefficient.\n- **ind_iil_inv** (*None** or **[**k+k_crc**]**, **int** or **tf.int*)  Defaults to None. If not <cite>None</cite>, the sequence is used as inverse\ninput bit interleaver before evaluating the CRC.\nRemark: this only effects the CRC evaluation but the output\nsequence is not permuted.\n- **return_crc_status** (*bool*)  Defaults to False. If True, the decoder additionally returns the\nCRC status indicating if a codeword was (most likely) correctly\nrecovered. This is only available if `crc_degree` is not None.\n- **output_dtype** (*tf.DType*)  Defaults to tf.float32. Defines the output datatype of the layer\n(internal precision remains tf.float32).\n\n\nInput\n\n**inputs** (*[,n], tf.float32*)  2+D tensor containing the channel LLR values (as logits).\n\nOutput\n\n- **b_hat** (*[,k], tf.float32*)  2+D tensor containing hard-decided estimations of all <cite>k</cite>\ninformation bits.\n- **crc_status** (*[], tf.bool*)  CRC status indicating if a codeword was (most likely) correctly\nrecovered. This is only returned if `return_crc_status` is True.\nNote that false positives are possible.\n\n\nRaises\n\n- **AssertionError**  If `n` is not <cite>int</cite>.\n- **AssertionError**  If `n` is not a power of 2.\n- **AssertionError**  If the number of elements in `frozen_pos` is greater than `n`.\n- **AssertionError**  If `frozen_pos` does not consists of <cite>int</cite>.\n- **AssertionError**  If `list_size` is not <cite>int</cite>.\n- **AssertionError**  If `cpu_only` is not <cite>bool</cite>.\n- **AssertionError**  If `use_scatter` is not <cite>bool</cite>.\n- **AssertionError**  If `use_fast_scl` is not <cite>bool</cite>.\n- **AssertionError**  If `use_hybrid_sc` is not <cite>bool</cite>.\n- **AssertionError**  If `list_size` is not a power of 2.\n- **ValueError**  If `output_dtype` is not {tf.float16, tf.float32, tf.\n    float64}.\n- **ValueError**  If `inputs` is not of shape <cite>[, n]</cite> or <cite>dtype</cite> is not\n    correct.\n- **InvalidArgumentError**  When rank(`inputs`)<2.\n\n\n**Note**\n\nThis layer implements the successive cancellation list (SCL) decoder\nas described in [[Tal_SCL]](https://nvlabs.github.io/sionna/api/fec.polar.html#tal-scl) but uses LLR-based message updates\n[[Stimming_LLR]](https://nvlabs.github.io/sionna/api/fec.polar.html#stimming-llr). The implementation follows the notation from\n[[Gross_Fast_SCL]](https://nvlabs.github.io/sionna/api/fec.polar.html#gross-fast-scl), [[Hashemi_SSCL]](https://nvlabs.github.io/sionna/api/fec.polar.html#hashemi-sscl). If option <cite>use_fast_scl</cite> is active\ntree pruning is used and tree nodes are combined if possible (see\n[[Hashemi_SSCL]](https://nvlabs.github.io/sionna/api/fec.polar.html#hashemi-sscl) for details).\n\nImplementing SCL decoding as TensorFlow graph is a difficult task that\nrequires several design tradeoffs to match the TF constraints while\nmaintaining a reasonable throughput. Thus, the decoder minimizes\nthe <cite>control flow</cite> as much as possible, leading to a strong memory\noccupation (e.g., due to full path duplication after each decision).\nFor longer code lengths, the complexity of the decoding graph becomes\nlarge and we recommend to use the <cite>CPU_only</cite> option that uses an\nembedded Numpy decoder. Further, this function recursively unrolls the\nSCL decoding tree, thus, for larger values of `n` building the\ndecoding graph can become time consuming. Please consider the\n`cpu_only` option if building the graph takes to long.\n\nA hybrid SC/SCL decoder as proposed in [[Cammerer_Hybrid_SCL]](https://nvlabs.github.io/sionna/api/fec.polar.html#cammerer-hybrid-scl) (using SC\ninstead of BP) can be activated with option `use_hybrid_sc` iff an\nouter CRC is available. Please note that the results are not exactly\nSCL performance caused by the false positive rate of the CRC.\n\nAs commonly done, we assume frozen bits are set to <cite>0</cite>. Please note\nthat - although its practical relevance is only little - setting frozen\nbits to <cite>1</cite> may result in <cite>affine</cite> codes instead of linear code as the\n<cite>all-zero</cite> codeword is not necessarily part of the code any more.\n\n`property` `frozen_pos`\n\nFrozen positions for Polar decoding.\n\n\n`property` `info_pos`\n\nInformation bit positions for Polar encoding.\n\n\n`property` `k`\n\nNumber of information bits.\n\n\n`property` `k_crc`\n\nNumber of CRC bits.\n\n\n`property` `list_size`\n\nList size for SCL decoding.\n\n\n`property` `llr_max`\n\nMaximum LLR value for internal calculations.\n\n\n`property` `n`\n\nCodeword length.\n\n\n`property` `output_dtype`\n\nOutput dtype of decoder."
"### PolarBPDecoder\n\n`class` `sionna.fec.polar.decoding.``PolarBPDecoder`(*`frozen_pos`*, *`n`*, *`num_iter``=``20`*, *`hard_out``=``True`*, *`output_dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/polar/decoding.html#PolarBPDecoder)\n\nBelief propagation (BP) decoder for Polar codes [[Arikan_Polar]](https://nvlabs.github.io/sionna/api/fec.polar.html#arikan-polar) and\nPolar-like codes based on [[Arikan_BP]](https://nvlabs.github.io/sionna/api/fec.polar.html#arikan-bp) and [[Forney_Graphs]](https://nvlabs.github.io/sionna/api/fec.polar.html#forney-graphs).\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\n\nRemark: The PolarBPDecoder does currently not support XLA.\nParameters\n\n- **frozen_pos** (*ndarray*)  Array of <cite>int</cite> defining the `n-k` indices of the frozen positions.\n- **n** (*int*)  Defining the codeword length.\n- **num_iter** (*int*)  Defining the number of decoder iterations (no early stopping used\nat the moment).\n- **hard_out** (*bool*)  Defaults to True. If True, the decoder provides hard-decided\ninformation bits instead of soft-values.\n- **output_dtype** (*tf.DType*)  Defaults to tf.float32. Defines the output datatype of the layer\n(internal precision remains tf.float32).\n\n\nInput\n\n**inputs** (*[,n], tf.float32*)  2+D tensor containing the channel logits/llr values.\n\nOutput\n\n*[,k], tf.float32*  2+D tensor containing bit-wise soft-estimates\n(or hard-decided bit-values) of all `k` information bits.\n\nRaises\n\n- **AssertionError**  If `n` is not <cite>int</cite>.\n- **AssertionError**  If `n` is not a power of 2.\n- **AssertionError**  If the number of elements in `frozen_pos` is greater than `n`.\n- **AssertionError**  If `frozen_pos` does not consists of <cite>int</cite>.\n- **AssertionError**  If `hard_out` is not <cite>bool</cite>.\n- **ValueError**  If `output_dtype` is not {tf.float16, tf.float32, tf.float64}.\n- **AssertionError**  If `num_iter` is not <cite>int</cite>.\n- **AssertionError**  If `num_iter` is not a positive value.\n\n\n**Note**\n\nThis decoder is fully differentiable and, thus, well-suited for\ngradient descent-based learning tasks such as <cite>learned code design</cite>\n[[Ebada_Design]](https://nvlabs.github.io/sionna/api/fec.polar.html#ebada-design).\n\nAs commonly done, we assume frozen bits are set to <cite>0</cite>. Please note\nthat - although its practical relevance is only little - setting frozen\nbits to <cite>1</cite> may result in <cite>affine</cite> codes instead of linear code as the\n<cite>all-zero</cite> codeword is not necessarily part of the code any more.\n\n`property` `frozen_pos`\n\nFrozen positions for Polar decoding.\n\n\n`property` `hard_out`\n\nIndicates if decoder hard-decides outputs.\n\n\n`property` `info_pos`\n\nInformation bit positions for Polar encoding.\n\n\n`property` `k`\n\nNumber of information bits.\n\n\n`property` `llr_max`\n\nMaximum LLR value for internal calculations.\n\n\n`property` `n`\n\nCodeword length.\n\n\n`property` `num_iter`\n\nNumber of decoding iterations.\n\n\n`property` `output_dtype`\n\nOutput dtype of decoder."
"### generate_5g_ranking\n\n`sionna.fec.polar.utils.``generate_5g_ranking`(*`k`*, *`n`*, *`sort``=``True`*)[`[source]`](../_modules/sionna/fec/polar/utils.html#generate_5g_ranking)\n\nReturns information and frozen bit positions of the 5G Polar code\nas defined in Tab. 5.3.1.2-1 in [[3GPPTS38212]](https://nvlabs.github.io/sionna/api/fec.polar.html#gppts38212) for given values of `k`\nand `n`.\nInput\n\n- **k** (*int*)  The number of information bit per codeword.\n- **n** (*int*)  The desired codeword length. Must be a power of two.\n- **sort** (*bool*)  Defaults to True. Indicates if the returned indices are\nsorted.\n\n\nOutput\n\n- **[frozen_pos, info_pos]**  List:\n- **frozen_pos** (*ndarray*)  An array of ints of shape <cite>[n-k]</cite> containing the frozen\nposition indices.\n- **info_pos** (*ndarray*)  An array of ints of shape <cite>[k]</cite> containing the information\nposition indices.\n\n\nRaises\n\n- **AssertionError**  If `k` or `n` are not positve ints.\n- **AssertionError**  If `sort` is not bool.\n- **AssertionError**  If `k` or `n` are larger than 1024\n- **AssertionError**  If `n` is less than 32.\n- **AssertionError**  If the resulting coderate is invalid (<cite>>1.0</cite>).\n- **AssertionError**  If `n` is not a power of 2."
"### generate_polar_transform_mat\n\n`sionna.fec.polar.utils.``generate_polar_transform_mat`(*`n_lift`*)[`[source]`](../_modules/sionna/fec/polar/utils.html#generate_polar_transform_mat)\n\nGenerate the polar transformation matrix (Kronecker product).\nInput\n\n**n_lift** (*int*)  Defining the Kronecker power, i.e., how often is the kernel lifted.\n\nOutput\n\n*ndarray*  Array of <cite>0s</cite> and <cite>1s</cite> of shape <cite>[2^n_lift , 2^n_lift]</cite> containing\nthe Polar transformation matrix."
"### generate_rm_code\n\n`sionna.fec.polar.utils.``generate_rm_code`(*`r`*, *`m`*)[`[source]`](../_modules/sionna/fec/polar/utils.html#generate_rm_code)\n\nGenerate frozen positions of the (r, m) Reed Muller (RM) code.\nInput\n\n- **r** (*int*)  The order of the RM code.\n- **m** (*int*)  <cite>log2</cite> of the desired codeword length.\n\n\nOutput\n\n- **[frozen_pos, info_pos, n, k, d_min]**  List:\n- **frozen_pos** (*ndarray*)  An array of ints of shape <cite>[n-k]</cite> containing the frozen\nposition indices.\n- **info_pos** (*ndarray*)  An array of ints of shape <cite>[k]</cite> containing the information\nposition indices.\n- **n** (*int*)  Resulting codeword length\n- **k** (*int*)  Number of information bits\n- **d_min** (*int*)  Minimum distance of the code.\n\n\nRaises\n\n- **AssertionError**  If `r` is larger than `m`.\n- **AssertionError**  If `r` or `m` are not positive ints."
"### generate_dense_polar\n\n`sionna.fec.polar.utils.``generate_dense_polar`(*`frozen_pos`*, *`n`*, *`verbose``=``True`*)[`[source]`](../_modules/sionna/fec/polar/utils.html#generate_dense_polar)\n\nGenerate *naive* (dense) Polar parity-check and generator matrix.\n\nThis function follows Lemma 1 in [[Goala_LP]](https://nvlabs.github.io/sionna/api/fec.polar.html#goala-lp) and returns a parity-check\nmatrix for Polar codes.\n\n**Note**\n\nThe resulting matrix can be used for decoding with the\n`LDPCBPDecoder` class. However, the resulting\nparity-check matrix is (usually) not sparse and, thus, not suitable for\nbelief propagation decoding as the graph has many short cycles.\nPlease consider `PolarBPDecoder` for iterative\ndecoding over the encoding graph.\n\nInput\n\n- **frozen_pos** (*ndarray*)  Array of <cite>int</cite> defining the `n-k` indices of the frozen positions.\n- **n** (*int*)  The codeword length.\n- **verbose** (*bool*)  Defaults to True. If True, the code properties are printed.\n\n\nOutput\n\n- **pcm** (ndarray of <cite>zeros</cite> and <cite>ones</cite> of shape [n-k, n])  The parity-check matrix.\n- **gm** (ndarray of <cite>zeros</cite> and <cite>ones</cite> of shape [k, n])  The generator matrix.\n\n\nReferences:\n3GPPTS38212([1](https://nvlabs.github.io/sionna/api/fec.polar.html#id1),[2](https://nvlabs.github.io/sionna/api/fec.polar.html#id2),[3](https://nvlabs.github.io/sionna/api/fec.polar.html#id5),[4](https://nvlabs.github.io/sionna/api/fec.polar.html#id8),[5](https://nvlabs.github.io/sionna/api/fec.polar.html#id9),[6](https://nvlabs.github.io/sionna/api/fec.polar.html#id10),[7](https://nvlabs.github.io/sionna/api/fec.polar.html#id11),[8](https://nvlabs.github.io/sionna/api/fec.polar.html#id12),[9](https://nvlabs.github.io/sionna/api/fec.polar.html#id13),[10](https://nvlabs.github.io/sionna/api/fec.polar.html#id14),[11](https://nvlabs.github.io/sionna/api/fec.polar.html#id15),[12](https://nvlabs.github.io/sionna/api/fec.polar.html#id16),[13](https://nvlabs.github.io/sionna/api/fec.polar.html#id17),[14](https://nvlabs.github.io/sionna/api/fec.polar.html#id33))\n\nETSI 3GPP TS 38.212 5G NR Multiplexing and channel\ncoding, v.16.5.0, 2021-03.\n\nBioglio_Design([1](https://nvlabs.github.io/sionna/api/fec.polar.html#id3),[2](https://nvlabs.github.io/sionna/api/fec.polar.html#id4),[3](https://nvlabs.github.io/sionna/api/fec.polar.html#id6),[4](https://nvlabs.github.io/sionna/api/fec.polar.html#id18))\n\nV. Bioglio, C. Condo, I. Land, Design of\nPolar Codes in 5G New Radio, IEEE Communications Surveys &\nTutorials, 2020. Online availabe [https://arxiv.org/pdf/1804.04389.pdf](https://arxiv.org/pdf/1804.04389.pdf)\n\n[Hui_ChannelCoding](https://nvlabs.github.io/sionna/api/fec.polar.html#id7)\n\nD. Hui, S. Sandberg, Y. Blankenship, M.\nAndersson, L. Grosjean Channel coding in 5G new radio: A\nTutorial Overview and Performance Comparison with 4G LTE, IEEE\nVehicular Technology Magazine, 2018.\n\nArikan_Polar([1](https://nvlabs.github.io/sionna/api/fec.polar.html#id19),[2](https://nvlabs.github.io/sionna/api/fec.polar.html#id20),[3](https://nvlabs.github.io/sionna/api/fec.polar.html#id29))\n\nE. Arikan, Channel polarization: A method for\nconstructing capacity-achieving codes for symmetric\nbinary-input memoryless channels, IEEE Trans. on Information\nTheory, 2009.\n\nGross_Fast_SCL([1](https://nvlabs.github.io/sionna/api/fec.polar.html#id21),[2](https://nvlabs.github.io/sionna/api/fec.polar.html#id25))\n\nSeyyed Ali Hashemi, Carlo Condo, and Warren J.\nGross, Fast and Flexible Successive-cancellation List Decoders\nfor Polar Codes. IEEE Trans. on Signal Processing, 2017.\n\nTal_SCL([1](https://nvlabs.github.io/sionna/api/fec.polar.html#id22),[2](https://nvlabs.github.io/sionna/api/fec.polar.html#id23))\n\nIdo Tal and Alexander Vardy, List Decoding of Polar\nCodes. IEEE Trans Inf Theory, 2015.\n\n[Stimming_LLR](https://nvlabs.github.io/sionna/api/fec.polar.html#id24)\n\nAlexios Balatsoukas-Stimming, Mani Bastani Parizi,\nAndreas Burg, LLR-Based Successive Cancellation List Decoding\nof Polar Codes. IEEE Trans Signal Processing, 2015.\n\nHashemi_SSCL([1](https://nvlabs.github.io/sionna/api/fec.polar.html#id26),[2](https://nvlabs.github.io/sionna/api/fec.polar.html#id27))\n\nSeyyed Ali Hashemi, Carlo Condo, and Warren J.\nGross, Simplified Successive-Cancellation List Decoding\nof Polar Codes. IEEE ISIT, 2016.\n\n[Cammerer_Hybrid_SCL](https://nvlabs.github.io/sionna/api/fec.polar.html#id28)\n\nSebastian Cammerer, Benedikt Leible, Matthias\nStahl, Jakob Hoydis, and Stephan ten Brink, Combining Belief\nPropagation and Successive Cancellation List Decoding of Polar\nCodes on a GPU Platform, IEEE ICASSP, 2017.\n\n[Arikan_BP](https://nvlabs.github.io/sionna/api/fec.polar.html#id30)\n\nE. Arikan, A Performance Comparison of Polar Codes and\nReed-Muller Codes, IEEE Commun. Lett., vol. 12, no. 6, pp.\n447-449, Jun. 2008.\n\n[Forney_Graphs](https://nvlabs.github.io/sionna/api/fec.polar.html#id31)\n\nG. D. Forney, Codes on graphs: normal realizations,\nIEEE Trans. Inform. Theory, vol. 47, no. 2, pp. 520-548, Feb. 2001.\n\n[Ebada_Design](https://nvlabs.github.io/sionna/api/fec.polar.html#id32)\n\nM. Ebada, S. Cammerer, A. Elkelesh and S. ten Brink,\nDeep Learning-based Polar Code Design, Annual Allerton\nConference on Communication, Control, and Computing, 2019.\n\n[Goala_LP](https://nvlabs.github.io/sionna/api/fec.polar.html#id34)\n\nN. Goela, S. Korada, M. Gastpar, On LP decoding of Polar\nCodes, IEEE ITW 2010."

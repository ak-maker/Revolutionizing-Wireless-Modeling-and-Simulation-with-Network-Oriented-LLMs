"# Channel Models from Datasets\n\nIn this notebook, you will learn how to create a channel model from a [generator](https://wiki.python.org/moin/Generators). This can be used, e.g., to import datasets of channel impulse responses."
"## GPU Configuration and Imports\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Import Sionna\ntry:\n    import sionna as sn\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna as sn\nimport numpy as np\nimport h5py\n```\n\n```python\n# Configure the notebook to use only a single GPU and allocate only as much memory as needed\n# For more details, see https://www.tensorflow.org/guide/gpu\nimport tensorflow as tf\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\n```"
"## Simulation Parameters\n\n\n```python\nnum_rx = 2\nnum_rx_ant = 2\nnum_tx = 1\nnum_tx_ant = 8\nnum_time_steps = 100\nnum_paths = 10\n```"
"## Creating a Simple Dataset\n\nTo illustrate how to load dataset, we will first create one.\n\nThe next cell creates a very small HDF5 file storing Gaussian distributed i.i.d. path coefficients and uniformly distributed i.i.d. path delays.\n\n\n```python\n# Number of examples in the dataset\ndataset_size = 1000\n# Random path coefficients\na_shape = [dataset_size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps]\na = (np.random.normal(size=a_shape) + 1j*np.random.normal(size=a_shape))/np.sqrt(2)\n# Random path delays\ntau = np.random.uniform(size=[dataset_size, num_rx, num_tx, num_paths])\n```\n\n```python\nfilename = 'my_dataset.h5'\nhf = h5py.File(filename, 'w')\nhf.create_dataset('a', data=a)\nhf.create_dataset('tau', data=tau)\nhf.close()\n```"
"## Generators\n\nThe first step to load a dataset is to create a [generator](https://wiki.python.org/moin/Generators). A generator is a callable object, i.e., a function or a class that implements the `__call__()` method, and that behaves like an iterator.\n\nThe next cell shows how to create a generator that parses an HDF5 file storing path coefficients and delays. Note that how the HDF5 file is parsed depends on its structure. The following generator is specific to the dataset previously created.\n\nIf you have another dataset, you will need to change the way it is parsed in the generator. The generator can also carry out any type of desired pre-processing of your data, e.g., normalization.\n\n\n```python\nclass HD5CIRGen:\n    def __init__(self, filename):\n        self.filename = filename\n    def __call__(self):\n        with h5py.File(self.filename, 'r') as hf:\n            for im in zip(hf[\"a\"], hf[\"tau\"]):\n                a = im[0]\n                tau = im[1]\n                # One could do some preprocessing on the dataset here\n                # ...\n                yield im\n```\n\n```python\ngenerator = HD5CIRGen(filename)\n```\n\n\nWe can use the generator to sample the first 5 items of the dataset:\n\n\n```python\ni = 0\nfor (a,tau) in generator():\n    print(a.shape)\n    print(tau.shape)\n    i = i + 1\n    if i == 5:\n        break\n```\n\n\n```python\n(2, 2, 1, 8, 10, 100)\n(2, 1, 10)\n(2, 2, 1, 8, 10, 100)\n(2, 1, 10)\n(2, 2, 1, 8, 10, 100)\n(2, 1, 10)\n(2, 2, 1, 8, 10, 100)\n(2, 1, 10)\n(2, 2, 1, 8, 10, 100)\n(2, 1, 10)\n```\n\n\nLet us create a channel model from this dataset:\n\n\n```python\nbatch_size = 64 # The batch_size cannot be changed after the creation of the channel model\nchannel_model = sn.channel.CIRDataset(generator,\n                                      batch_size,\n                                      num_rx,\n                                      num_rx_ant,\n                                      num_tx,\n                                      num_tx_ant,\n                                      num_paths,\n                                      num_time_steps)\n```"
"We can now sample from this dataset in the same way as we would from a stochastic channel model:\n\n\n```python\n# Note that the arguments batch_size, num_time_steps, and smapling_frequency\n# of the __call__ function are ignored as they are already specified by the dataset.\na, tau = channel_model()\n```\n\n```python\nprint(a.shape)\nprint(a.dtype)\nprint(tau.shape)\nprint(tau.dtype)\n```\n\n\n```python\n(64, 2, 2, 1, 8, 10, 100)\n<dtype: 'complex64'>\n(64, 2, 1, 10)\n<dtype: 'float32'>\n```"
"## Use the Channel Model for OFDM Transmissions\n\nThe following code demonstrates how you can use the channel model to generate channel frequency responses that can be used for the simulation of communication system based on OFDM.\n\n\n```python\n# Create an OFDM resource grid\n# Each time step is assumed to correspond to one OFDM symbol over which it is constant.\nresource_grid = sn.ofdm.ResourceGrid(num_ofdm_symbols=num_time_steps,\n                                     fft_size=76,\n                                     subcarrier_spacing=15e3,\n                                     num_tx=num_tx,\n                                     num_streams_per_tx=num_tx_ant)\n```\n\n```python\nofdm_channel = sn.channel.GenerateOFDMChannel(channel_model, resource_grid)\n```\n\n```python\n# Generate a batch of frequency responses\n# Shape: [batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_ofdm_symbols, num_subcarriers]\nh_freq = ofdm_channel()\nprint(h_freq.shape)\n```\n\n\n```python\n(64, 2, 2, 1, 8, 100, 76)\n```"

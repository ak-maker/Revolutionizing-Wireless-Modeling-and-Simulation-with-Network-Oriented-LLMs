"# Orthogonal Frequency-Division Multiplexing (OFDM)\n\nThis module provides layers and functions to support\nsimulation of OFDM-based systems. The key component is the\n[`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) that defines how data and pilot symbols\nare mapped onto a sequence of OFDM symbols with a given FFT size. The resource\ngrid can also define guard and DC carriers which are nulled. In 4G/5G parlance,\na [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) would be a slot.\nOnce a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) is defined, one can use the\n[`ResourceGridMapper`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGridMapper) to map a tensor of complex-valued\ndata symbols onto the resource grid, prior to OFDM modulation using the\n[`OFDMModulator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.OFDMModulator) or further processing in the\nfrequency domain.\n\nThe [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern) allows for a fine-grained configuration\nof how transmitters send pilots for each of their streams or antennas. As the\nmanagement of pilots in multi-cell MIMO setups can quickly become complicated,\nthe module provides the [`KroneckerPilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.KroneckerPilotPattern) class\nthat automatically generates orthogonal pilot transmissions for all transmitters\nand streams.\n\nAdditionally, the module contains layers for channel estimation, precoding,\nequalization, and detection,\nsuch as the [`LSChannelEstimator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.LSChannelEstimator), the\n[`ZFPrecoder`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ZFPrecoder), and the [`LMMSEEqualizer`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.LMMSEEqualizer) and\n[`LinearDetector`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.LinearDetector).\nThese are good starting points for the development of more advanced algorithms\nand provide robust baselines for benchmarking."
"## Resource Grid\n\nThe following code snippet shows how to setup and visualize an instance of\n[`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid):\n```python\nrg = ResourceGrid(num_ofdm_symbols = 14,\n                  fft_size = 64,\n                  subcarrier_spacing = 30e3,\n                  num_tx = 1,\n                  num_streams_per_tx = 1,\n                  num_guard_carriers = [5, 6],\n                  dc_null = True,\n                  pilot_pattern = \"kronecker\",\n                  pilot_ofdm_symbol_indices = [2, 11])\nrg.show();\n```\n\n\nThis code creates a resource grid consisting of 14 OFDM symbols with 64\nsubcarriers. The first five and last six subcarriers as well as the DC\nsubcarriers are nulled. The second and eleventh OFDM symbol are reserved\nfor pilot transmissions.\n\nSubcarriers are numbered from $0$ to $N-1$, where $N$\nis the FTT size. The index $0$ corresponds to the lowest frequency,\nwhich is $-\\frac{N}{2}\\Delta_f$ (for $N$ even) or\n$-\\frac{N-1}{2}\\Delta_f$ (for $N$ odd), where $\\Delta_f$\nis the subcarrier spacing which is irrelevant for the resource grid.\nThe index $N-1$ corresponds to the highest frequency,\nwhich is $(\\frac{N}{2}-1)\\Delta_f$ (for $N$ even) or\n$\\frac{N-1}{2}\\Delta_f$ (for $N$ odd)."
"### ResourceGrid\n\n`class` `sionna.ofdm.``ResourceGrid`(*`num_ofdm_symbols`*, *`fft_size`*, *`subcarrier_spacing`*, *`num_tx``=``1`*, *`num_streams_per_tx``=``1`*, *`cyclic_prefix_length``=``0`*, *`num_guard_carriers``=``(0,` `0)`*, *`dc_null``=``False`*, *`pilot_pattern``=``None`*, *`pilot_ofdm_symbol_indices``=``None`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/ofdm/resource_grid.html#ResourceGrid)\n\nDefines a <cite>ResourceGrid</cite> spanning multiple OFDM symbols and subcarriers.\nParameters\n\n- **num_ofdm_symbols** (*int*)  Number of OFDM symbols.\n- **fft_size** (*int*)  FFT size (, i.e., the number of subcarriers).\n- **subcarrier_spacing** (*float*)  The subcarrier spacing in Hz.\n- **num_tx** (*int*)  Number of transmitters.\n- **num_streams_per_tx** (*int*)  Number of streams per transmitter.\n- **cyclic_prefix_length** (*int*)  Length of the cyclic prefix.\n- **num_guard_carriers** (*int*)  List of two integers defining the number of guardcarriers at the\nleft and right side of the resource grid.\n- **dc_null** (*bool*)  Indicates if the DC carrier is nulled or not.\n- **pilot_pattern** (*One of** [**None**, **\"kronecker\"**, **\"empty\"**, **]*)  An instance of [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern), a string\nshorthand for the [`KroneckerPilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.KroneckerPilotPattern)\nor [`EmptyPilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.EmptyPilotPattern), or <cite>None</cite>.\nDefaults to <cite>None</cite> which is equivalent to <cite>empty</cite>.\n- **pilot_ofdm_symbol_indices** (*List**, **int*)  List of indices of OFDM symbols reserved for pilot transmissions.\nOnly needed if `pilot_pattern=\"kronecker\"`. Defaults to <cite>None</cite>.\n- **dtype** (*tf.Dtype*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\n`property` `bandwidth`\n\n`fft_size*subcarrier_spacing`.\nType\n\nThe occupied bandwidth [Hz]\n\n\n`build_type_grid`()[`[source]`](../_modules/sionna/ofdm/resource_grid.html#ResourceGrid.build_type_grid)\n\nReturns a tensor indicating the type of each resource element.\n\nResource elements can be one of\n\n- 0 : Data symbol\n- 1 : Pilot symbol\n- 2 : Guard carrier symbol\n- 3 : DC carrier symbol\n\nOutput\n\n*[num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.int32*  Tensor indicating for each transmitter and stream the type of\nthe resource elements of the corresponding resource grid.\nThe type can be one of [0,1,2,3] as explained above.\n\n\n`property` `cyclic_prefix_length`\n\nLength of the cyclic prefix.\n\n\n`property` `dc_ind`\n\nIndex of the DC subcarrier.\n\nIf `fft_size` is odd, the index is (`fft_size`-1)/2.\nIf `fft_size` is even, the index is `fft_size`/2.\n\n\n`property` `dc_null`\n\nIndicates if the DC carriers is nulled or not.\n\n\n`property` `effective_subcarrier_ind`\n\nReturns the indices of the effective subcarriers.\n\n\n`property` `fft_size`\n\nThe FFT size.\n\n\n`property` `num_data_symbols`\n\nNumber of resource elements used for data transmissions.\n\n\n`property` `num_effective_subcarriers`\n\nNumber of subcarriers used for data and pilot transmissions.\n\n\n`property` `num_guard_carriers`\n\nNumber of left and right guard carriers.\n\n\n`property` `num_ofdm_symbols`\n\nThe number of OFDM symbols of the resource grid.\n\n\n`property` `num_pilot_symbols`\n\nNumber of resource elements used for pilot symbols.\n\n\n`property` `num_resource_elements`\n\nNumber of resource elements.\n\n\n`property` `num_streams_per_tx`\n\nNumber of streams  per transmitter.\n\n\n`property` `num_time_samples`\n\nThe number of time-domain samples occupied by the resource grid.\n\n\n`property` `num_tx`\n\nNumber of transmitters.\n\n\n`property` `num_zero_symbols`\n\nNumber of empty resource elements.\n\n\n`property` `ofdm_symbol_duration`\n\nDuration of an OFDM symbol with cyclic prefix [s].\n\n\n`property` `pilot_pattern`\n\nThe used PilotPattern.\n\n\n`show`(*`tx_ind``=``0`*, *`tx_stream_ind``=``0`*)[`[source]`](../_modules/sionna/ofdm/resource_grid.html#ResourceGrid.show)\n\nVisualizes the resource grid for a specific transmitter and stream.\nInput\n\n- **tx_ind** (*int*)  Indicates the transmitter index.\n- **tx_stream_ind** (*int*)  Indicates the index of the stream.\n\n\nOutput\n\n<cite>matplotlib.figure</cite>  A handle to a matplot figure object.\n\n\n`property` `subcarrier_spacing`\n\nThe subcarrier spacing [Hz]."
"### ResourceGridMapper\n\n`class` `sionna.ofdm.``ResourceGridMapper`(*`resource_grid`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/resource_grid.html#ResourceGridMapper)\n\nMaps a tensor of modulated data symbols to a ResourceGrid.\n\nThis layer takes as input a tensor of modulated data symbols\nand maps them together with pilot symbols onto an\nOFDM [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid). The output can be\nconverted to a time-domain signal with the\n`Modulator` or further processed in the\nfrequency domain.\nParameters\n\n- **resource_grid** ()  An instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n*[batch_size, num_tx, num_streams_per_tx, num_data_symbols], tf.complex*  The modulated data symbols to be mapped onto the resource grid.\n\nOutput\n\n*[batch_size, num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.complex*  The full OFDM resource grid in the frequency domain."
"### ResourceGridDemapper\n\n`class` `sionna.ofdm.``ResourceGridDemapper`(*`resource_grid`*, *`stream_management`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/resource_grid.html#ResourceGridDemapper)\n\nExtracts data-carrying resource elements from a resource grid.\n\nThis layer takes as input an OFDM [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\nextracts the data-carrying resource elements. In other words, it implements\nthe reverse operation of [`ResourceGridMapper`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGridMapper).\nParameters\n\n- **resource_grid** ()  An instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n- **stream_management** ()  An instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement).\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n*[batch_size, num_rx, num_streams_per_rx, num_ofdm_symbols, fft_size, data_dim]*  The full OFDM resource grid in the frequency domain.\nThe last dimension <cite>data_dim</cite> is optional. If <cite>data_dim</cite>\nis used, it refers to the dimensionality of the data that should be\ndemapped to individual streams. An example would be LLRs.\n\nOutput\n\n*[batch_size, num_rx, num_streams_per_rx, num_data_symbols, data_dim]*  The data that were mapped into the resource grid.\nThe last dimension <cite>data_dim</cite> is only returned if it was used for the\ninput."
"### RemoveNulledSubcarriers\n\n`class` `sionna.ofdm.``RemoveNulledSubcarriers`(*`resource_grid`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/resource_grid.html#RemoveNulledSubcarriers)\n\nRemoves nulled guard and/or DC subcarriers from a resource grid.\nParameters\n\n**resource_grid** ()  An instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n\nInput\n\n*[batch_size, num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.complex64*  Full resource grid.\n\nOutput\n\n*[batch_size, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex64*  Resource grid without nulled subcarriers."
"### OFDMModulator\n\n`class` `sionna.ofdm.``OFDMModulator`(*`cyclic_prefix_length`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/modulator.html#OFDMModulator)\n\nComputes the time-domain representation of an OFDM resource grid\nwith (optional) cyclic prefix.\nParameters\n\n**cyclic_prefix_length** (*int*)  Integer indicating the length of the\ncyclic prefix that it prepended to each OFDM symbol. It cannot\nbe longer than the FFT size.\n\nInput\n\n*[,num_ofdm_symbols,fft_size], tf.complex*  A resource grid in the frequency domain.\n\nOutput\n\n*[,num_ofdm_symbols*(fft_size+cyclic_prefix_length)], tf.complex*  Time-domain OFDM signal."
"### OFDMDemodulator\n\n`class` `sionna.ofdm.``OFDMDemodulator`(*`fft_size`*, *`l_min`*, *`cyclic_prefix_length`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/demodulator.html#OFDMDemodulator)\n\nComputes the frequency-domain representation of an OFDM waveform\nwith cyclic prefix removal.\n\nThe demodulator assumes that the input sequence is generated by the\n[`TimeChannel`](channel.wireless.html#sionna.channel.TimeChannel). For a single pair of antennas,\nthe received signal sequence is given as:\n\n$$\ny_b = \\sum_{\\ell =L_\\text{min}}^{L_\\text{max}} \\bar{h}_\\ell x_{b-\\ell} + w_b, \\quad b \\in[L_\\text{min}, N_B+L_\\text{max}-1]\n$$\n\nwhere $\\bar{h}_\\ell$ are the discrete-time channel taps,\n$x_{b}$ is the the transmitted signal,\nand $w_\\ell$ Gaussian noise.\n\nStarting from the first symbol, the demodulator cuts the input\nsequence into pieces of size `cyclic_prefix_length` `+` `fft_size`,\nand throws away any trailing symbols. For each piece, the cyclic\nprefix is removed and the `fft_size`-point discrete Fourier\ntransform is computed.\n\nSince the input sequence starts at time $L_\\text{min}$,\nthe FFT-window has a timing offset of $L_\\text{min}$ symbols,\nwhich leads to a subcarrier-dependent phase shift of\n$e^{\\frac{j2\\pi k L_\\text{min}}{N}}$, where $k$\nis the subcarrier index, $N$ is the FFT size,\nand $L_\\text{min} \\le 0$ is the largest negative time lag of\nthe discrete-time channel impulse response. This phase shift\nis removed in this layer, by explicitly multiplying\neach subcarrier by  $e^{\\frac{-j2\\pi k L_\\text{min}}{N}}$.\nThis is a very important step to enable channel estimation with\nsparse pilot patterns that needs to interpolate the channel frequency\nresponse accross subcarriers. It also ensures that the\nchannel frequency response <cite>seen</cite> by the time-domain channel\nis close to the [`OFDMChannel`](channel.wireless.html#sionna.channel.OFDMChannel).\nParameters\n\n- **fft_size** (*int*)  FFT size (, i.e., the number of subcarriers).\n- **l_min** (*int*)  The largest negative time lag of the discrete-time channel\nimpulse response. It should be the same value as that used by the\n<cite>cir_to_time_channel</cite> function.\n- **cyclic_prefix_length** (*int*)  Integer indicating the length of the cyclic prefix that\nis prepended to each OFDM symbol.\n\n\nInput\n\n*[,num_ofdm_symbols*(fft_size+cyclic_prefix_length)+n], tf.complex*  Tensor containing the time-domain signal along the last dimension.\n<cite>n</cite> is a nonnegative integer.\n\nOutput\n\n*[,num_ofdm_symbols,fft_size], tf.complex*  Tensor containing the OFDM resource grid along the last\ntwo dimension."
"## Pilot Pattern\n\nA [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern) defines how transmitters send pilot\nsequences for each of their antennas or streams over an OFDM resource grid.\nIt consists of two components,\na `mask` and `pilots`. The `mask` indicates which resource elements are\nreserved for pilot transmissions by each transmitter and its respective\nstreams. In some cases, the number of streams is equal to the number of\ntransmit antennas, but this does not need to be the case, e.g., for precoded\ntransmissions. The `pilots` contains the pilot symbols that are transmitted\nat the positions indicated by the `mask`. Separating a pilot pattern into\n`mask` and `pilots` enables the implementation of a wide range of pilot\nconfigurations, including trainable pilot sequences.\n\nThe following code snippet shows how to define a simple custom\n[`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern) for single transmitter, sending two streams\nNote that `num_effective_subcarriers` is the number of subcarriers that\ncan be used for data or pilot transmissions. Due to guard\ncarriers or a nulled DC carrier, this number can be smaller than the\n`fft_size` of the [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n```python\nnum_tx = 1\nnum_streams_per_tx = 2\nnum_ofdm_symbols = 14\nnum_effective_subcarriers = 12\n# Create a pilot mask\nmask = np.zeros([num_tx,\n                 num_streams_per_tx,\n                 num_ofdm_symbols,\n                 num_effective_subcarriers])\nmask[0, :, [2,11], :] = 1\nnum_pilot_symbols = int(np.sum(mask[0,0]))\n# Define pilot sequences\npilots = np.zeros([num_tx,\n                   num_streams_per_tx,\n                   num_pilot_symbols], np.complex64)\npilots[0, 0, 0:num_pilot_symbols:2] = (1+1j)/np.sqrt(2)\npilots[0, 1, 1:num_pilot_symbols:2] = (1+1j)/np.sqrt(2)\n# Create a PilotPattern instance\npp = PilotPattern(mask, pilots)\n# Visualize non-zero elements of the pilot sequence\npp.show(show_pilot_ind=True);\n```"
"As shown in the figures above, the pilots are mapped onto the mask from\nthe smallest effective subcarrier and OFDM symbol index to the highest\neffective subcarrier and OFDM symbol index. Here, boths stream have 24\npilot symbols, out of which only 12 are nonzero. It is important to keep\nthis order of mapping in mind when designing more complex pilot sequences."
"### PilotPattern\n\n`class` `sionna.ofdm.``PilotPattern`(*`mask`*, *`pilots`*, *`trainable``=``False`*, *`normalize``=``False`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/ofdm/pilot_pattern.html#PilotPattern)\n\nClass defining a pilot pattern for an OFDM ResourceGrid.\n\nThis class defines a pilot pattern object that is used to configure\nan OFDM [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\nParameters\n\n- **mask** (*[**num_tx**, **num_streams_per_tx**, **num_ofdm_symbols**, **num_effective_subcarriers**]**, **bool*)  Tensor indicating resource elements that are reserved for pilot transmissions.\n- **pilots** (*[**num_tx**, **num_streams_per_tx**, **num_pilots**]**, **tf.complex*)  The pilot symbols to be mapped onto the `mask`.\n- **trainable** (*bool*)  Indicates if `pilots` is a trainable <cite>Variable</cite>.\nDefaults to <cite>False</cite>.\n- **normalize** (*bool*)  Indicates if the `pilots` should be normalized to an average\nenergy of one across the last dimension. This can be useful to\nensure that trainable `pilots` have a finite energy.\nDefaults to <cite>False</cite>.\n- **dtype** (*tf.Dtype*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\n`property` `mask`\n\nMask of the pilot pattern\n\n\n`property` `normalize`\n\nReturns or sets the flag indicating if the pilots\nare normalized or not\n\n\n`property` `num_data_symbols`\n\nNumber of data symbols per transmit stream.\n\n\n`property` `num_effective_subcarriers`\n\nNumber of effectvie subcarriers\n\n\n`property` `num_ofdm_symbols`\n\nNumber of OFDM symbols\n\n\n`property` `num_pilot_symbols`\n\nNumber of pilot symbols per transmit stream.\n\n\n`property` `num_streams_per_tx`\n\nNumber of streams per transmitter\n\n\n`property` `num_tx`\n\nNumber of transmitters\n\n\n`property` `pilots`\n\nReturns or sets the possibly normalized tensor of pilot symbols.\nIf pilots are normalized, the normalization will be applied\nafter new values for pilots have been set. If this is\nnot the desired behavior, turn normalization off.\n\n\n`show`(*`tx_ind``=``None`*, *`stream_ind``=``None`*, *`show_pilot_ind``=``False`*)[`[source]`](../_modules/sionna/ofdm/pilot_pattern.html#PilotPattern.show)\n\nVisualizes the pilot patterns for some transmitters and streams.\nInput\n\n- **tx_ind** (*list, int*)  Indicates the indices of transmitters to be included.\nDefaults to <cite>None</cite>, i.e., all transmitters included.\n- **stream_ind** (*list, int*)  Indicates the indices of streams to be included.\nDefaults to <cite>None</cite>, i.e., all streams included.\n- **show_pilot_ind** (*bool*)  Indicates if the indices of the pilot symbols should be shown.\n\n\nOutput\n\n**list** (*matplotlib.figure.Figure*)  List of matplot figure objects showing each the pilot pattern\nfrom a specific transmitter and stream.\n\n\n`property` `trainable`\n\nReturns if pilots are trainable or not"
"### EmptyPilotPattern\n\n`class` `sionna.ofdm.``EmptyPilotPattern`(*`num_tx`*, *`num_streams_per_tx`*, *`num_ofdm_symbols`*, *`num_effective_subcarriers`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/ofdm/pilot_pattern.html#EmptyPilotPattern)\n\nCreates an empty pilot pattern.\n\nGenerates a instance of [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern) with\nan empty `mask` and `pilots`.\nParameters\n\n- **num_tx** (*int*)  Number of transmitters.\n- **num_streams_per_tx** (*int*)  Number of streams per transmitter.\n- **num_ofdm_symbols** (*int*)  Number of OFDM symbols.\n- **num_effective_subcarriers** (*int*)  Number of effective subcarriers\nthat are available for the transmission of data and pilots.\nNote that this number is generally smaller than the `fft_size`\ndue to nulled subcarriers.\n- **dtype** (*tf.Dtype*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>."
"### KroneckerPilotPattern\n\n`class` `sionna.ofdm.``KroneckerPilotPattern`(*`resource_grid`*, *`pilot_ofdm_symbol_indices`*, *`normalize``=``True`*, *`seed``=``0`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/ofdm/pilot_pattern.html#KroneckerPilotPattern)\n\nSimple orthogonal pilot pattern with Kronecker structure.\n\nThis function generates an instance of [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern)\nthat allocates non-overlapping pilot sequences for all transmitters and\nstreams on specified OFDM symbols. As the same pilot sequences are reused\nacross those OFDM symbols, the resulting pilot pattern has a frequency-time\nKronecker structure. This structure enables a very efficient implementation\nof the LMMSE channel estimator. Each pilot sequence is constructed from\nrandomly drawn QPSK constellation points.\nParameters\n\n- **resource_grid** ()  An instance of a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n- **pilot_ofdm_symbol_indices** (*list**, **int*)  List of integers defining the OFDM symbol indices that are reserved\nfor pilots.\n- **normalize** (*bool*)  Indicates if the `pilots` should be normalized to an average\nenergy of one across the last dimension.\nDefaults to <cite>True</cite>.\n- **seed** (*int*)  Seed for the generation of the pilot sequence. Different seed values\nlead to different sequences. Defaults to 0.\n- **dtype** (*tf.Dtype*)  Defines the datatype for internal calculations and the output\ndtype. Defaults to <cite>tf.complex64</cite>.\n\n\n**Note**\n\nIt is required that the `resource_grid`s property\n`num_effective_subcarriers` is an\ninteger multiple of `num_tx` `*` `num_streams_per_tx`. This condition is\nrequired to ensure that all transmitters and streams get\nnon-overlapping pilot sequences. For a large number of streams and/or\ntransmitters, the pilot pattern becomes very sparse in the frequency\ndomain.\n xamples\n```python\n>>> rg = ResourceGrid(num_ofdm_symbols=14,\n...                   fft_size=64,\n...                   subcarrier_spacing = 30e3,\n...                   num_tx=4,\n...                   num_streams_per_tx=2,\n...                   pilot_pattern = \"kronecker\",\n...                   pilot_ofdm_symbol_indices = [2, 11])\n>>> rg.pilot_pattern.show();\n```"
"### BaseChannelEstimator\n\n`class` `sionna.ofdm.``BaseChannelEstimator`(*`resource_grid`*, *`interpolation_type``=``'nn'`*, *`interpolator``=``None`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#BaseChannelEstimator)\n\nAbstract layer for implementing an OFDM channel estimator.\n\nAny layer that implements an OFDM channel estimator must implement this\nclass and its\n[`estimate_at_pilot_locations()`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.BaseChannelEstimator.estimate_at_pilot_locations)\nabstract method.\n\nThis class extracts the pilots from the received resource grid `y`, calls\nthe [`estimate_at_pilot_locations()`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.BaseChannelEstimator.estimate_at_pilot_locations)\nmethod to estimate the channel for the pilot-carrying resource elements,\nand then interpolates the channel to compute channel estimates for the\ndata-carrying resouce elements using the interpolation method specified by\n`interpolation_type` or the `interpolator` object.\nParameters\n\n- **resource_grid** ()  An instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n- **interpolation_type** (*One of** [**\"nn\"**, **\"lin\"**, **\"lin_time_avg\"**]**, **string*)  The interpolation method to be used.\nIt is ignored if `interpolator` is not <cite>None</cite>.\nAvailable options are [`NearestNeighborInterpolator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.NearestNeighborInterpolator) (<cite>nn</cite>)\nor [`LinearInterpolator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.LinearInterpolator) without (<cite>lin</cite>) or with\naveraging across OFDM symbols (<cite>lin_time_avg</cite>).\nDefaults to nn.\n- **interpolator** ()  An instance of [`BaseChannelInterpolator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.BaseChannelInterpolator),\nsuch as [`LMMSEInterpolator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.LMMSEInterpolator),\nor <cite>None</cite>. In the latter case, the interpolator specfied\nby `interpolation_type` is used.\nOtherwise, the `interpolator` is used and `interpolation_type`\nis ignored.\nDefaults to <cite>None</cite>.\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(y, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols,fft_size], tf.complex*)  Observed resource grid\n- **no** (*[batch_size, num_rx, num_rx_ant] or only the first n>=0 dims, tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols,fft_size], tf.complex*)  Channel estimates accross the entire resource grid for all\ntransmitters and streams\n- **err_var** (Same shape as `h_hat`, tf.float)  Channel estimation error variance accross the entire resource grid\nfor all transmitters and streams\n\n\n`abstract` `estimate_at_pilot_locations`(*`y_pilots`*, *`no`*)[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#BaseChannelEstimator.estimate_at_pilot_locations)\n\nEstimates the channel for the pilot-carrying resource elements.\n\nThis is an abstract method that must be implemented by a concrete\nOFDM channel estimator that implement this class.\nInput\n\n- **y_pilots** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams, num_pilot_symbols], tf.complex*)  Observed signals for the pilot-carrying resource elements\n- **no** (*[batch_size, num_rx, num_rx_ant] or only the first n>=0 dims, tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams, num_pilot_symbols], tf.complex*)  Channel estimates for the pilot-carrying resource elements\n- **err_var** (Same shape as `h_hat`, tf.float)  Channel estimation error variance for the pilot-carrying\nresource elements"
"### BaseChannelInterpolator\n\n`class` `sionna.ofdm.``BaseChannelInterpolator`[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#BaseChannelInterpolator)\n\nAbstract layer for implementing an OFDM channel interpolator.\n\nAny layer that implements an OFDM channel interpolator must implement this\ncallable class.\n\nA channel interpolator is used by an OFDM channel estimator\n([`BaseChannelEstimator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.BaseChannelEstimator)) to compute channel estimates\nfor the data-carrying resource elements from the channel estimates for the\npilot-carrying resource elements.\nInput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_pilot_symbols], tf.complex*)  Channel estimates for the pilot-carrying resource elements\n- **err_var** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_pilot_symbols], tf.complex*)  Channel estimation error variances for the pilot-carrying resource elements\n\n\nOutput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.complex*)  Channel estimates accross the entire resource grid for all\ntransmitters and streams\n- **err_var** (Same shape as `h_hat`, tf.float)  Channel estimation error variance accross the entire resource grid\nfor all transmitters and streams"
"### LSChannelEstimator\n\n`class` `sionna.ofdm.``LSChannelEstimator`(*`resource_grid`*, *`interpolation_type``=``'nn'`*, *`interpolator``=``None`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#LSChannelEstimator)\n\nLayer implementing least-squares (LS) channel estimation for OFDM MIMO systems.\n\nAfter LS channel estimation at the pilot positions, the channel estimates\nand error variances are interpolated accross the entire resource grid using\na specified interpolation function.\n\nFor simplicity, the underlying algorithm is described for a vectorized observation,\nwhere we have a nonzero pilot for all elements to be estimated.\nThe actual implementation works on a full OFDM resource grid with sparse\npilot patterns. The following model is assumed:\n\n$$\n\\mathbf{y} = \\mathbf{h}\\odot\\mathbf{p} + \\mathbf{n}\n$$\n\nwhere $\\mathbf{y}\\in\\mathbb{C}^{M}$ is the received signal vector,\n$\\mathbf{p}\\in\\mathbb{C}^M$ is the vector of pilot symbols,\n$\\mathbf{h}\\in\\mathbb{C}^{M}$ is the channel vector to be estimated,\nand $\\mathbf{n}\\in\\mathbb{C}^M$ is a zero-mean noise vector whose\nelements have variance $N_0$. The operator $\\odot$ denotes\nelement-wise multiplication.\n\nThe channel estimate $\\hat{\\mathbf{h}}$ and error variances\n$\\sigma^2_i$, $i=0,\\dots,M-1$, are computed as\n\n$$\n\\begin{split}\\hat{\\mathbf{h}} &= \\mathbf{y} \\odot\n                   \\frac{\\mathbf{p}^\\star}{\\left|\\mathbf{p}\\right|^2}\n                 = \\mathbf{h} + \\tilde{\\mathbf{h}}\\\\\n     \\sigma^2_i &= \\mathbb{E}\\left[\\tilde{h}_i \\tilde{h}_i^\\star \\right]\n                 = \\frac{N_0}{\\left|p_i\\right|^2}.\\end{split}\n$$\n\nThe channel estimates and error variances are then interpolated accross\nthe entire resource grid.\nParameters\n\n- **resource_grid** ()  An instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n- **interpolation_type** (*One of** [**\"nn\"**, **\"lin\"**, **\"lin_time_avg\"**]**, **string*)  The interpolation method to be used.\nIt is ignored if `interpolator` is not <cite>None</cite>.\nAvailable options are [`NearestNeighborInterpolator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.NearestNeighborInterpolator) (<cite>nn</cite>)\nor [`LinearInterpolator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.LinearInterpolator) without (<cite>lin</cite>) or with\naveraging across OFDM symbols (<cite>lin_time_avg</cite>).\nDefaults to nn.\n- **interpolator** ()  An instance of [`BaseChannelInterpolator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.BaseChannelInterpolator),\nsuch as [`LMMSEInterpolator`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.LMMSEInterpolator),\nor <cite>None</cite>. In the latter case, the interpolator specfied\nby `interpolation_type` is used.\nOtherwise, the `interpolator` is used and `interpolation_type`\nis ignored.\nDefaults to <cite>None</cite>.\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(y, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols,fft_size], tf.complex*)  Observed resource grid\n- **no** (*[batch_size, num_rx, num_rx_ant] or only the first n>=0 dims, tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **h_ls** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols,fft_size], tf.complex*)  Channel estimates accross the entire resource grid for all\ntransmitters and streams\n- **err_var** (Same shape as `h_ls`, tf.float)  Channel estimation error variance accross the entire resource grid\nfor all transmitters and streams"
"### LinearInterpolator\n\n`class` `sionna.ofdm.``LinearInterpolator`(*`pilot_pattern`*, *`time_avg``=``False`*)[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#LinearInterpolator)\n\nLinear channel estimate interpolation on a resource grid.\n\nThis class computes for each element of an OFDM resource grid\na channel estimate based on `num_pilots` provided channel estimates and\nerror variances through linear interpolation.\nIt is assumed that the measurements were taken at the nonzero positions\nof a [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern).\n\nThe interpolation is done first across sub-carriers and then\nacross OFDM symbols.\nParameters\n\n- **pilot_pattern** ()  An instance of [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern)\n- **time_avg** (*bool*)  If enabled, measurements will be averaged across OFDM symbols\n(i.e., time). This is useful for channels that do not vary\nsubstantially over the duration of an OFDM frame. Defaults to <cite>False</cite>.\n\n\nInput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_pilot_symbols], tf.complex*)  Channel estimates for the pilot-carrying resource elements\n- **err_var** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_pilot_symbols], tf.complex*)  Channel estimation error variances for the pilot-carrying resource elements\n\n\nOutput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.complex*)  Channel estimates accross the entire resource grid for all\ntransmitters and streams\n- **err_var** (Same shape as `h_hat`, tf.float)  Channel estimation error variances accross the entire resource grid\nfor all transmitters and streams"
"### LMMSEInterpolator\n\n`class` `sionna.ofdm.``LMMSEInterpolator`(*`pilot_pattern`*, *`cov_mat_time`*, *`cov_mat_freq`*, *`cov_mat_space``=``None`*, *`order``=``'t-f'`*)[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#LMMSEInterpolator)\n\nLMMSE interpolation on a resource grid with optional spatial smoothing.\n\nThis class computes for each element of an OFDM resource grid\na channel estimate and error variance\nthrough linear minimum mean square error (LMMSE) interpolation/smoothing.\nIt is assumed that the measurements were taken at the nonzero positions\nof a [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern).\n\nDepending on the value of `order`, the interpolation is carried out\naccross time (t), i.e., OFDM symbols, frequency (f), i.e., subcarriers,\nand optionally space (s), i.e., receive antennas, in any desired order.\n\nFor simplicity, we describe the underlying algorithm assuming that interpolation\nacross the sub-carriers is performed first, followed by interpolation across\nOFDM symbols, and finally by spatial smoothing across receive\nantennas.\nThe algorithm is similar if interpolation and/or smoothing are performed in\na different order.\nFor clarity, antenna indices are omitted when describing frequency and time\ninterpolation, as the same process is applied to all the antennas.\n\nThe input `h_hat` is first reshaped to a resource grid\n$\\hat{\\mathbf{H}} \\in \\mathbb{C}^{N \\times M}$, by scattering the channel\nestimates at pilot locations according to the `pilot_pattern`. $N$\ndenotes the number of OFDM symbols and $M$ the number of sub-carriers.\n\nThe first pass consists in interpolating across the sub-carriers:\n\n$$\n\\hat{\\mathbf{h}}_n^{(1)} = \\mathbf{A}_n \\hat{\\mathbf{h}}_n\n$$\n\nwhere $1 \\leq n \\leq N$ is the OFDM symbol index and $\\hat{\\mathbf{h}}_n$ is\nthe $n^{\\text{th}}$ (transposed) row of $\\hat{\\mathbf{H}}$.\n$\\mathbf{A}_n$ is the $M \\times M$ matrix such that:\n\n$$\n\\mathbf{A}_n = \\bar{\\mathbf{A}}_n \\mathbf{\\Pi}_n^\\intercal\n$$\n\nwhere\n\n$$\n\\bar{\\mathbf{A}}_n = \\underset{\\mathbf{Z} \\in \\mathbb{C}^{M \\times K_n}}{\\text{argmin}} \\left\\lVert \\mathbf{Z}\\left( \\mathbf{\\Pi}_n^\\intercal \\mathbf{R^{(f)}} \\mathbf{\\Pi}_n + \\mathbf{\\Sigma}_n \\right) - \\mathbf{R^{(f)}} \\mathbf{\\Pi}_n \\right\\rVert_{\\text{F}}^2\n$$\n\nand $\\mathbf{R^{(f)}}$ is the $M \\times M$ channel frequency covariance matrix,\n$\\mathbf{\\Pi}_n$ the $M \\times K_n$ matrix that spreads $K_n$\nvalues to a vector of size $M$ according to the `pilot_pattern` for the $n^{\\text{th}}$ OFDM symbol,\nand $\\mathbf{\\Sigma}_n \\in \\mathbb{R}^{K_n \\times K_n}$ is the channel estimation error covariance built from\n`err_var` and assumed to be diagonal.\nComputation of $\\bar{\\mathbf{A}}_n$ is done using an algorithm based on complete orthogonal decomposition.\nThis is done to avoid matrix inversion for badly conditioned covariance matrices.\n\nThe channel estimation error variances after the first interpolation pass are computed as\n\n$$\n\\mathbf{\\Sigma}^{(1)}_n = \\text{diag} \\left( \\mathbf{R^{(f)}} - \\mathbf{A}_n \\mathbf{\\Xi}_n \\mathbf{R^{(f)}} \\right)\n$$\n\nwhere $\\mathbf{\\Xi}_n$ is the diagonal matrix of size $M \\times M$ that zeros the\ncolumns corresponding to sub-carriers not carrying any pilots.\nNote that interpolation is not performed for OFDM symbols which do not carry pilots.\n\n**Remark**: The interpolation matrix differs across OFDM symbols as different\nOFDM symbols may carry pilots on different sub-carriers and/or have different\nestimation error variances.\n\nScaling of the estimates is then performed to ensure that their\nvariances match the ones expected by the next interpolation step, and the error variances are updated accordingly:\n\n$$\n\\begin{split}\\begin{align}\n    \\left[\\hat{\\mathbf{h}}_n^{(2)}\\right]_m &= s_{n,m} \\left[\\hat{\\mathbf{h}}_n^{(1)}\\right]_m\\\\\n    \\left[\\mathbf{\\Sigma}^{(2)}_n\\right]_{m,m}  &= s_{n,m}\\left( s_{n,m}-1 \\right) \\left[\\hat{\\mathbf{\\Sigma}}^{(1)}_n\\right]_{m,m} + \\left( 1 - s_{n,m} \\right) \\left[\\mathbf{R^{(f)}}\\right]_{m,m} + s_{n,m} \\left[\\mathbf{\\Sigma}^{(1)}_n\\right]_{m,m}\n\\end{align}\\end{split}\n$$\n\nwhere the scaling factor $s_{n,m}$ is such that:\n\n$$\n\\mathbb{E} \\left\\{ \\left\\lvert s_{n,m} \\left[\\hat{\\mathbf{h}}_n^{(1)}\\right]_m \\right\\rvert^2 \\right\\} = \\left[\\mathbf{R^{(f)}}\\right]_{m,m} +  \\mathbb{E} \\left\\{ \\left\\lvert s_{n,m} \\left[\\hat{\\mathbf{h}}^{(1)}_n\\right]_m - \\left[\\mathbf{h}_n\\right]_m \\right\\rvert^2 \\right\\}\n$$\n\nwhich leads to:\n\n$$\n\\begin{split}\\begin{align}\n    s_{n,m} &= \\frac{2 \\left[\\mathbf{R^{(f)}}\\right]_{m,m}}{\\left[\\mathbf{R^{(f)}}\\right]_{m,m} - \\left[\\mathbf{\\Sigma}^{(1)}_n\\right]_{m,m} + \\left[\\hat{\\mathbf{\\Sigma}}^{(1)}_n\\right]_{m,m}}\\\\\n    \\hat{\\mathbf{\\Sigma}}^{(1)}_n &= \\mathbf{A}_n \\mathbf{R^{(f)}} \\mathbf{A}_n^{\\mathrm{H}}.\n\\end{align}\\end{split}\n$$\n\nThe second pass consists in interpolating across the OFDM symbols:\n\n$$\n\\hat{\\mathbf{h}}_m^{(3)} = \\mathbf{B}_m \\tilde{\\mathbf{h}}^{(2)}_m\n$$\n\nwhere $1 \\leq m \\leq M$ is the sub-carrier index and $\\tilde{\\mathbf{h}}^{(2)}_m$ is\nthe $m^{\\text{th}}$ column of\n\n$$\n\\begin{split}\\hat{\\mathbf{H}}^{(2)} = \\begin{bmatrix}\n                            {\\hat{\\mathbf{h}}_1^{(2)}}^\\intercal\\\\\n                            \\vdots\\\\\n                            {\\hat{\\mathbf{h}}_N^{(2)}}^\\intercal\n                         \\end{bmatrix}\\end{split}\n$$\n\nand $\\mathbf{B}_m$ is the $N \\times N$ interpolation LMMSE matrix:\n\n$$\n\\mathbf{B}_m = \\bar{\\mathbf{B}}_m \\tilde{\\mathbf{\\Pi}}_m^\\intercal\n$$\n\nwhere\n\n$$\n\\bar{\\mathbf{B}}_m = \\underset{\\mathbf{Z} \\in \\mathbb{C}^{N \\times L_m}}{\\text{argmin}} \\left\\lVert \\mathbf{Z} \\left( \\tilde{\\mathbf{\\Pi}}_m^\\intercal \\mathbf{R^{(t)}}\\tilde{\\mathbf{\\Pi}}_m + \\tilde{\\mathbf{\\Sigma}}^{(2)}_m \\right) -  \\mathbf{R^{(t)}}\\tilde{\\mathbf{\\Pi}}_m \\right\\rVert_{\\text{F}}^2\n$$\n\nwhere $\\mathbf{R^{(t)}}$ is the $N \\times N$ channel time covariance matrix,\n$\\tilde{\\mathbf{\\Pi}}_m$ the $N \\times L_m$ matrix that spreads $L_m$\nvalues to a vector of size $N$ according to the `pilot_pattern` for the $m^{\\text{th}}$ sub-carrier,\nand $\\tilde{\\mathbf{\\Sigma}}^{(2)}_m \\in \\mathbb{R}^{L_m \\times L_m}$ is the diagonal matrix of channel estimation error variances\nbuilt by gathering the error variances from ($\\mathbf{\\Sigma}^{(2)}_1,\\dots,\\mathbf{\\Sigma}^{(2)}_N$) corresponding\nto resource elements carried by the $m^{\\text{th}}$ sub-carrier.\nComputation of $\\bar{\\mathbf{B}}_m$ is done using an algorithm based on complete orthogonal decomposition.\nThis is done to avoid matrix inversion for badly conditioned covariance matrices.\n\nThe resulting channel estimate for the resource grid is\n\n$$\n\\hat{\\mathbf{H}}^{(3)} = \\left[ \\hat{\\mathbf{h}}_1^{(3)} \\dots \\hat{\\mathbf{h}}_M^{(3)} \\right]\n$$\n\nThe resulting channel estimation error variances are the diagonal coefficients of the matrices\n\n$$\n\\mathbf{\\Sigma}^{(3)}_m = \\mathbf{R^{(t)}} - \\mathbf{B}_m \\tilde{\\mathbf{\\Xi}}_m \\mathbf{R^{(t)}}, 1 \\leq m \\leq M\n$$\n\nwhere $\\tilde{\\mathbf{\\Xi}}_m$ is the diagonal matrix of size $N \\times N$ that zeros the\ncolumns corresponding to OFDM symbols not carrying any pilots.\n\n**Remark**: The interpolation matrix differs across sub-carriers as different\nsub-carriers may have different estimation error variances computed by the first\npass.\nHowever, all sub-carriers carry at least one channel estimate as a result of\nthe first pass, ensuring that a channel estimate is computed for all the resource\nelements after the second pass.\n\n**Remark:** LMMSE interpolation requires knowledge of the time and frequency\ncovariance matrices of the channel. The notebook [OFDM MIMO Channel Estimation and Detection](../examples/OFDM_MIMO_Detection.html) shows how to estimate\nsuch matrices for arbitrary channel models.\nMoreover, the functions [`tdl_time_cov_mat()`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.tdl_time_cov_mat)\nand [`tdl_freq_cov_mat()`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.tdl_freq_cov_mat) compute the expected time and frequency\ncovariance matrices, respectively, for the [`TDL`](channel.wireless.html#sionna.channel.tr38901.TDL) channel models.\n\nScaling of the estimates is then performed to ensure that their\nvariances match the ones expected by the next smoothing step, and the\nerror variances are updated accordingly:\n\n$$\n\\begin{split}\\begin{align}\n    \\left[\\hat{\\mathbf{h}}_m^{(4)}\\right]_n &= \\gamma_{m,n} \\left[\\hat{\\mathbf{h}}_m^{(3)}\\right]_n\\\\\n    \\left[\\mathbf{\\Sigma}^{(4)}_m\\right]_{n,n}  &= \\gamma_{m,n}\\left( \\gamma_{m,n}-1 \\right) \\left[\\hat{\\mathbf{\\Sigma}}^{(3)}_m\\right]_{n,n} + \\left( 1 - \\gamma_{m,n} \\right) \\left[\\mathbf{R^{(t)}}\\right]_{n,n} + \\gamma_{m,n} \\left[\\mathbf{\\Sigma}^{(3)}_n\\right]_{m,m}\n\\end{align}\\end{split}\n$$\n\nwhere:\n\n$$\n\\begin{split}\\begin{align}\n    \\gamma_{m,n} &= \\frac{2 \\left[\\mathbf{R^{(t)}}\\right]_{n,n}}{\\left[\\mathbf{R^{(t)}}\\right]_{n,n} - \\left[\\mathbf{\\Sigma}^{(3)}_m\\right]_{n,n} + \\left[\\hat{\\mathbf{\\Sigma}}^{(3)}_n\\right]_{m,m}}\\\\\n    \\hat{\\mathbf{\\Sigma}}^{(3)}_m &= \\mathbf{B}_m \\mathbf{R^{(t)}} \\mathbf{B}_m^{\\mathrm{H}}\n\\end{align}\\end{split}\n$$\n\nFinally, a spatial smoothing step is applied to every resource element carrying\na channel estimate.\nFor clarity, we drop the resource element indexing $(n,m)$.\nWe denote by $L$ the number of receive antennas, and by\n$\\mathbf{R^{(s)}}\\in\\mathbb{C}^{L \\times L}$ the spatial covariance matrix.\n\nLMMSE spatial smoothing consists in the following computations:\n\n$$\n\\hat{\\mathbf{h}}^{(5)} = \\mathbf{C} \\hat{\\mathbf{h}}^{(4)}\n$$\n\nwhere\n\n$$\n\\mathbf{C} = \\mathbf{R^{(s)}} \\left( \\mathbf{R^{(s)}} + \\mathbf{\\Sigma}^{(4)} \\right)^{-1}.\n$$\n\nThe estimation error variances are the digonal coefficients of\n\n$$\n\\mathbf{\\Sigma}^{(5)} = \\mathbf{R^{(s)}} - \\mathbf{C}\\mathbf{R^{(s)}}\n$$\n\nThe smoothed channel estimate $\\hat{\\mathbf{h}}^{(5)}$ and corresponding\nerror variances $\\text{diag}\\left( \\mathbf{\\Sigma}^{(5)} \\right)$ are\nreturned for every resource element $(m,n)$.\n\n**Remark:** No scaling is performed after the last interpolation or smoothing\nstep.\n\n**Remark:** All passes assume that the estimation error covariance matrix\n($\\mathbf{\\Sigma}$, $\\tilde{\\mathbf{\\Sigma}}^{(2)}$, or $\\tilde{\\mathbf{\\Sigma}}^{(4)}$) is diagonal, which\nmay not be accurate. When this assumption does not hold, this interpolator is only\nan approximation of LMMSE interpolation.\n\n**Remark:** The order in which frequency interpolation, temporal\ninterpolation, and, optionally, spatial smoothing are applied, is controlled using the\n`order` parameter.\n\n**Note**\n\nThis layer does not support graph mode with XLA.\n\nParameters\n\n- **pilot_pattern** ()  An instance of [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern)\n- **cov_mat_time** (*[**num_ofdm_symbols**, **num_ofdm_symbols**]**, **tf.complex*)  Time covariance matrix of the channel\n- **cov_mat_freq** (*[**fft_size**, **fft_size**]**, **tf.complex*)  Frequency covariance matrix of the channel\n- **cov_time_space** (*[**num_rx_ant**, **num_rx_ant**]**, **tf.complex*)  Spatial covariance matrix of the channel.\nDefaults to <cite>None</cite>.\nOnly required if spatial smoothing is requested (see `order`).\n- **order** (*str*)  Order in which to perform interpolation and optional smoothing.\nFor example, `\"t-f-s\"` means that interpolation across the OFDM symbols\nis performed first (`\"t\"`: time), followed by interpolation across the\nsub-carriers (`\"f\"`: frequency), and finally smoothing across the\nreceive antennas (`\"s\"`: space).\nSimilarly, `\"f-t\"` means interpolation across the sub-carriers followed\nby interpolation across the OFDM symbols and no spatial smoothing.\nThe spatial covariance matrix (`cov_time_space`) is only required when\nspatial smoothing is requested.\nTime and frequency interpolation are not optional to ensure that a channel\nestimate is computed for all resource elements.\n\n\nInput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_pilot_symbols], tf.complex*)  Channel estimates for the pilot-carrying resource elements\n- **err_var** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_pilot_symbols], tf.complex*)  Channel estimation error variances for the pilot-carrying resource elements\n\n\nOutput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.complex*)  Channel estimates accross the entire resource grid for all\ntransmitters and streams\n- **err_var** (Same shape as `h_hat`, tf.float)  Channel estimation error variances accross the entire resource grid\nfor all transmitters and streams"
"### NearestNeighborInterpolator\n\n`class` `sionna.ofdm.``NearestNeighborInterpolator`(*`pilot_pattern`*)[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#NearestNeighborInterpolator)\n\nNearest-neighbor channel estimate interpolation on a resource grid.\n\nThis class assigns to each element of an OFDM resource grid one of\n`num_pilots` provided channel estimates and error\nvariances according to the nearest neighbor method. It is assumed\nthat the measurements were taken at the nonzero positions of a\n[`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern).\n\nThe figure below shows how four channel estimates are interpolated\naccross a resource grid. Grey fields indicate measurement positions\nwhile the colored regions show which resource elements are assigned\nto the same measurement value.\nParameters\n\n**pilot_pattern** ()  An instance of [`PilotPattern`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.PilotPattern)\n\nInput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_pilot_symbols], tf.complex*)  Channel estimates for the pilot-carrying resource elements\n- **err_var** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_pilot_symbols], tf.complex*)  Channel estimation error variances for the pilot-carrying resource elements\n\n\nOutput\n\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.complex*)  Channel estimates accross the entire resource grid for all\ntransmitters and streams\n- **err_var** (Same shape as `h_hat`, tf.float)  Channel estimation error variances accross the entire resource grid\nfor all transmitters and streams"
"### tdl_time_cov_mat\n\n`sionna.ofdm.``tdl_time_cov_mat`(*`model`*, *`speed`*, *`carrier_frequency`*, *`ofdm_symbol_duration`*, *`num_ofdm_symbols`*, *`los_angle_of_arrival``=``0.7853981633974483`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#tdl_time_cov_mat)\n\nComputes the time covariance matrix of a\n[`TDL`](channel.wireless.html#sionna.channel.tr38901.TDL) channel model.\n\nFor non-line-of-sight (NLoS) model, the channel time covariance matrix\n$\\mathbf{R^{(t)}}$ of a TDL channel model is\n\n$$\n\\mathbf{R^{(t)}}_{u,v} = J_0 \\left( \\nu \\Delta_t \\left( u-v \\right) \\right)\n$$\n\nwhere $J_0$ is the zero-order Bessel function of the first kind,\n$\\Delta_t$ the duration of an OFDM symbol, and $\\nu$ the Doppler\nspread defined by\n\n$$\n\\nu = 2 \\pi \\frac{v}{c} f_c\n$$\n\nwhere $v$ is the movement speed, $c$ the speed of light, and\n$f_c$ the carrier frequency.\n\nFor line-of-sight (LoS) channel models, the channel time covariance matrix\nis\n\n$$\n\\mathbf{R^{(t)}}_{u,v} = P_{\\text{NLoS}} J_0 \\left( \\nu \\Delta_t \\left( u-v \\right) \\right) + P_{\\text{LoS}}e^{j \\nu \\Delta_t \\left( u-v \\right) \\cos{\\alpha_{\\text{LoS}}}}\n$$\n\nwhere $\\alpha_{\\text{LoS}}$ is the angle-of-arrival for the LoS path,\n$P_{\\text{NLoS}}$ the total power of NLoS paths, and\n$P_{\\text{LoS}}$ the power of the LoS path. The power delay profile\nis assumed to have unit power, i.e., $P_{\\text{NLoS}} + P_{\\text{LoS}} = 1$.\nInput\n\n- **model** (*str*)  TDL model for which to return the covariance matrix.\nShould be one of A, B, C, D, or E.\n- **speed** (*float*)  Speed [m/s]\n- **carrier_frequency** (*float*)  Carrier frequency [Hz]\n- **ofdm_symbol_duration** (*float*)  Duration of an OFDM symbol [s]\n- **num_ofdm_symbols** (*int*)  Number of OFDM symbols\n- **los_angle_of_arrival** (*float*)  Angle-of-arrival for LoS path [radian]. Only used with LoS models.\nDefaults to $\\pi/4$.\n- **dtype** (*tf.DType*)  Datatype to use for the output.\nShould be one of <cite>tf.complex64</cite> or <cite>tf.complex128</cite>.\nDefaults to <cite>tf.complex64</cite>.\n\n\nOutput\n\n**cov_mat** (*[num_ofdm_symbols, num_ofdm_symbols], tf.complex*)  Channel time covariance matrix"
"### tdl_freq_cov_mat\n\n`sionna.ofdm.``tdl_freq_cov_mat`(*`model`*, *`subcarrier_spacing`*, *`fft_size`*, *`delay_spread`*, *`dtype``=``tf.complex64`*)[`[source]`](../_modules/sionna/ofdm/channel_estimation.html#tdl_freq_cov_mat)\n\nComputes the frequency covariance matrix of a\n[`TDL`](channel.wireless.html#sionna.channel.tr38901.TDL) channel model.\n\nThe channel frequency covariance matrix $\\mathbf{R}^{(f)}$ of a TDL channel model is\n\n$$\n\\mathbf{R}^{(f)}_{u,v} = \\sum_{\\ell=1}^L P_\\ell e^{-j 2 \\pi \\tau_\\ell \\Delta_f (u-v)}, 1 \\leq u,v \\leq M\n$$\n\nwhere $M$ is the FFT size, $L$ is the number of paths for the selected TDL model,\n$P_\\ell$ and $\\tau_\\ell$ are the average power and delay for the\n$\\ell^{\\text{th}}$ path, respectively, and $\\Delta_f$ is the sub-carrier spacing.\nInput\n\n- **model** (*str*)  TDL model for which to return the covariance matrix.\nShould be one of A, B, C, D, or E.\n- **subcarrier_spacing** (*float*)  Sub-carrier spacing [Hz]\n- **fft_size** (*float*)  FFT size\n- **delay_spread** (*float*)  Delay spread [s]\n- **dtype** (*tf.DType*)  Datatype to use for the output.\nShould be one of <cite>tf.complex64</cite> or <cite>tf.complex128</cite>.\nDefaults to <cite>tf.complex64</cite>.\n\n\nOutput\n\n**cov_mat** (*[fft_size, fft_size], tf.complex*)  Channel frequency covariance matrix"
"### ZFPrecoder\n\n`class` `sionna.ofdm.``ZFPrecoder`(*`resource_grid`*, *`stream_management`*, *`return_effective_channel``=``False`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/precoding.html#ZFPrecoder)\n\nZero-forcing precoding for multi-antenna transmissions.\n\nThis layer precodes a tensor containing OFDM resource grids using\nthe [`zero_forcing_precoder()`](mimo.html#sionna.mimo.zero_forcing_precoder). For every\ntransmitter, the channels to all intended receivers are gathered\ninto a channel matrix, based on the which the precoding matrix\nis computed and the input tensor is precoded. The layer also outputs\noptionally the effective channel after precoding for each stream.\nParameters\n\n- **resource_grid** ()  An instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n- **stream_management** ()  An instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement).\n- **return_effective_channel** (*bool*)  Indicates if the effective channel after precoding should be returned.\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(x, h)**  Tuple:\n- **x** (*[batch_size, num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.complex*)  Tensor containing the resource grid to be precoded.\n- **h** (*[batch_size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_ofdm, fft_size], tf.complex*)  Tensor containing the channel knowledge based on which the precoding\nis computed.\n\n\nOutput\n\n- **x_precoded** (*[batch_size, num_tx, num_tx_ant, num_ofdm_symbols, fft_size], tf.complex*)  The precoded resource grids.\n- **h_eff** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm, num_effective_subcarriers], tf.complex*)  Only returned if `return_effective_channel=True`.\nThe effectice channels for all streams after precoding. Can be used to\nsimulate perfect channel state information (CSI) at the receivers.\nNulled subcarriers are automatically removed to be compliant with the\nbehavior of a channel estimator.\n\n\n**Note**\n\nIf you want to use this layer in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### OFDMEqualizer\n\n`class` `sionna.ofdm.``OFDMEqualizer`(*`equalizer`*, *`resource_grid`*, *`stream_management`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/equalization.html#OFDMEqualizer)\n\nLayer that wraps a MIMO equalizer for use with the OFDM waveform.\n\nThe parameter `equalizer` is a callable (e.g., a function) that\nimplements a MIMO equalization algorithm for arbitrary batch dimensions.\n\nThis class pre-processes the received resource grid `y` and channel\nestimate `h_hat`, and computes for each receiver the\nnoise-plus-interference covariance matrix according to the OFDM and stream\nconfiguration provided by the `resource_grid` and\n`stream_management`, which also accounts for the channel\nestimation error variance `err_var`. These quantities serve as input\nto the equalization algorithm that is implemented by the callable `equalizer`.\nThis layer computes soft-symbol estimates together with effective noise\nvariances for all streams which can, e.g., be used by a\n[`Demapper`](mapping.html#sionna.mapping.Demapper) to obtain LLRs.\n\n**Note**\n\nThe callable `equalizer` must take three inputs:\n\n- **y** ([,num_rx_ant], tf.complex)  1+D tensor containing the received signals.\n- **h** ([,num_rx_ant,num_streams_per_rx], tf.complex)  2+D tensor containing the channel matrices.\n- **s** ([,num_rx_ant,num_rx_ant], tf.complex)  2+D tensor containing the noise-plus-interference covariance matrices.\n\n\nIt must generate two outputs:\n\n- **x_hat** ([,num_streams_per_rx], tf.complex)  1+D tensor representing the estimated symbol vectors.\n- **no_eff** (tf.float)  Tensor of the same shape as `x_hat` containing the effective noise variance estimates.\nParameters\n\n- **equalizer** (*Callable*)  Callable object (e.g., a function) that implements a MIMO equalization\nalgorithm for arbitrary batch dimensions\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **x_hat** (*[batch_size, num_tx, num_streams, num_data_symbols], tf.complex*)  Estimated symbols\n- **no_eff** (*[batch_size, num_tx, num_streams, num_data_symbols], tf.float*)  Effective noise variance for each estimated symbol"
"### LMMSEEqualizer\n\n`class` `sionna.ofdm.``LMMSEEqualizer`(*`resource_grid`*, *`stream_management`*, *`whiten_interference``=``True`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/equalization.html#LMMSEEqualizer)\n\nLMMSE equalization for OFDM MIMO transmissions.\n\nThis layer computes linear minimum mean squared error (LMMSE) equalization\nfor OFDM MIMO transmissions. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\ndetection algorithm is the [`lmmse_equalizer()`](mimo.html#sionna.mimo.lmmse_equalizer). The layer\ncomputes soft-symbol estimates together with effective noise variances\nfor all streams which can, e.g., be used by a\n[`Demapper`](mapping.html#sionna.mapping.Demapper) to obtain LLRs.\nParameters\n\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **whiten_interference** (*bool*)  If <cite>True</cite> (default), the interference is first whitened before equalization.\nIn this case, an alternative expression for the receive filter is used which\ncan be numerically more stable.\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **x_hat** (*[batch_size, num_tx, num_streams, num_data_symbols], tf.complex*)  Estimated symbols\n- **no_eff** (*[batch_size, num_tx, num_streams, num_data_symbols], tf.float*)  Effective noise variance for each estimated symbol\n\n\n**Note**\n\nIf you want to use this layer in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### MFEqualizer\n\n`class` `sionna.ofdm.``MFEqualizer`(*`resource_grid`*, *`stream_management`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/equalization.html#MFEqualizer)\n\nMF equalization for OFDM MIMO transmissions.\n\nThis layer computes matched filter (MF) equalization\nfor OFDM MIMO transmissions. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\ndetection algorithm is the [`mf_equalizer()`](mimo.html#sionna.mimo.mf_equalizer). The layer\ncomputes soft-symbol estimates together with effective noise variances\nfor all streams which can, e.g., be used by a\n[`Demapper`](mapping.html#sionna.mapping.Demapper) to obtain LLRs.\nParameters\n\n- **resource_grid** ()  An instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n- **stream_management** ()  An instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement).\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **x_hat** (*[batch_size, num_tx, num_streams, num_data_symbols], tf.complex*)  Estimated symbols\n- **no_eff** (*[batch_size, num_tx, num_streams, num_data_symbols], tf.float*)  Effective noise variance for each estimated symbol\n\n\n**Note**\n\nIf you want to use this layer in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### ZFEqualizer\n\n`class` `sionna.ofdm.``ZFEqualizer`(*`resource_grid`*, *`stream_management`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/equalization.html#ZFEqualizer)\n\nZF equalization for OFDM MIMO transmissions.\n\nThis layer computes zero-forcing (ZF) equalization\nfor OFDM MIMO transmissions. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\ndetection algorithm is the [`zf_equalizer()`](mimo.html#sionna.mimo.zf_equalizer). The layer\ncomputes soft-symbol estimates together with effective noise variances\nfor all streams which can, e.g., be used by a\n[`Demapper`](mapping.html#sionna.mapping.Demapper) to obtain LLRs.\nParameters\n\n- **resource_grid** ()  An instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid).\n- **stream_management** ()  An instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement).\n- **dtype** (*tf.Dtype*)  Datatype for internal calculations and the output dtype.\nDefaults to <cite>tf.complex64</cite>.\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **x_hat** (*[batch_size, num_tx, num_streams, num_data_symbols], tf.complex*)  Estimated symbols\n- **no_eff** (*[batch_size, num_tx, num_streams, num_data_symbols], tf.float*)  Effective noise variance for each estimated symbol\n\n\n**Note**\n\nIf you want to use this layer in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### OFDMDetector\n\n`class` `sionna.ofdm.``OFDMDetector`(*`detector`*, *`output`*, *`resource_grid`*, *`stream_management`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/detection.html#OFDMDetector)\n\nLayer that wraps a MIMO detector for use with the OFDM waveform.\n\nThe parameter `detector` is a callable (e.g., a function) that\nimplements a MIMO detection algorithm for arbitrary batch dimensions.\n\nThis class pre-processes the received resource grid `y` and channel\nestimate `h_hat`, and computes for each receiver the\nnoise-plus-interference covariance matrix according to the OFDM and stream\nconfiguration provided by the `resource_grid` and\n`stream_management`, which also accounts for the channel\nestimation error variance `err_var`. These quantities serve as input to the detection\nalgorithm that is implemented by `detector`.\nBoth detection of symbols or bits with either soft- or hard-decisions are supported.\n\n**Note**\n\nThe callable `detector` must take as input a tuple $(\\mathbf{y}, \\mathbf{h}, \\mathbf{s})$ such that:\n\n- **y** ([,num_rx_ant], tf.complex)  1+D tensor containing the received signals.\n- **h** ([,num_rx_ant,num_streams_per_rx], tf.complex)  2+D tensor containing the channel matrices.\n- **s** ([,num_rx_ant,num_rx_ant], tf.complex)  2+D tensor containing the noise-plus-interference covariance matrices.\n\n\nIt must generate one of following outputs depending on the value of `output`:\n\n- **b_hat** ([, num_streams_per_rx, num_bits_per_symbol], tf.float)  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- **x_hat** ([, num_streams_per_rx, num_points], tf.float) or ([, num_streams_per_rx], tf.int)  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>. Hard-decisions correspond to the symbol indices.\nParameters\n\n- **detector** (*Callable*)  Callable object (e.g., a function) that implements a MIMO detection\nalgorithm for arbitrary batch dimensions. Either one of the existing detectors, e.g.,\n[`LinearDetector`](mimo.html#sionna.mimo.LinearDetector), [`MaximumLikelihoodDetector`](mimo.html#sionna.mimo.MaximumLikelihoodDetector), or\n[`KBestDetector`](mimo.html#sionna.mimo.KBestDetector) can be used, or a custom detector\ncallable provided that has the same input/output specification.\n- **output** (*One of** [**\"bit\"**, **\"symbol\"**]**, **str*)  Type of output, either bits or symbols\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **dtype** (*One of** [**tf.complex64**, **tf.complex128**] **tf.DType** (**dtype**)*)  The dtype of <cite>y</cite>. Defaults to tf.complex64.\nThe output dtype is the corresponding real dtype (tf.float32 or tf.float64).\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **One of**\n- *[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float*  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>\n- *[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int*  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>.\nHard-decisions correspond to the symbol indices."
"### OFDMDetectorWithPrior\n\n`class` `sionna.ofdm.``OFDMDetectorWithPrior`(*`detector`*, *`output`*, *`resource_grid`*, *`stream_management`*, *`constellation_type`*, *`num_bits_per_symbol`*, *`constellation`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/detection.html#OFDMDetectorWithPrior)\n\nLayer that wraps a MIMO detector that assumes prior knowledge of the bits or\nconstellation points is available, for use with the OFDM waveform.\n\nThe parameter `detector` is a callable (e.g., a function) that\nimplements a MIMO detection algorithm with prior for arbitrary batch\ndimensions.\n\nThis class pre-processes the received resource grid `y`, channel\nestimate `h_hat`, and the prior information `prior`, and computes for each receiver the\nnoise-plus-interference covariance matrix according to the OFDM and stream\nconfiguration provided by the `resource_grid` and\n`stream_management`, which also accounts for the channel\nestimation error variance `err_var`. These quantities serve as input to the detection\nalgorithm that is implemented by `detector`.\nBoth detection of symbols or bits with either soft- or hard-decisions are supported.\n\n**Note**\n\nThe callable `detector` must take as input a tuple $(\\mathbf{y}, \\mathbf{h}, \\mathbf{prior}, \\mathbf{s})$ such that:\n\n- **y** ([,num_rx_ant], tf.complex)  1+D tensor containing the received signals.\n- **h** ([,num_rx_ant,num_streams_per_rx], tf.complex)  2+D tensor containing the channel matrices.\n- **prior** ([,num_streams_per_rx,num_bits_per_symbol] or [,num_streams_per_rx,num_points], tf.float)  Prior for the transmitted signals. If `output` equals bit, then LLRs for the transmitted bits are expected. If `output` equals symbol, then logits for the transmitted constellation points are expected.\n- **s** ([,num_rx_ant,num_rx_ant], tf.complex)  2+D tensor containing the noise-plus-interference covariance matrices.\n\n\nIt must generate one of the following outputs depending on the value of `output`:\n\n- **b_hat** ([, num_streams_per_rx, num_bits_per_symbol], tf.float)  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- **x_hat** ([, num_streams_per_rx, num_points], tf.float) or ([, num_streams_per_rx], tf.int)  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>. Hard-decisions correspond to the symbol indices.\nParameters\n\n- **detector** (*Callable*)  Callable object (e.g., a function) that implements a MIMO detection\nalgorithm with prior for arbitrary batch dimensions. Either the existing detector\n[`MaximumLikelihoodDetectorWithPrior`](mimo.html#sionna.mimo.MaximumLikelihoodDetectorWithPrior) can be used, or a custom detector\ncallable provided that has the same input/output specification.\n- **output** (*One of** [**\"bit\"**, **\"symbol\"**]**, **str*)  Type of output, either bits or symbols\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **constellation_type** (*One of** [**\"qam\"**, **\"pam\"**, **\"custom\"**]**, **str*)  For custom, an instance of [`Constellation`](mapping.html#sionna.mapping.Constellation)\nmust be provided.\n- **num_bits_per_symbol** (*int*)  Number of bits per constellation symbol, e.g., 4 for QAM16.\nOnly required for `constellation_type` in [qam, pam].\n- **constellation** ()  Instance of [`Constellation`](mapping.html#sionna.mapping.Constellation) or <cite>None</cite>.\nIn the latter case, `constellation_type`\nand `num_bits_per_symbol` must be provided.\n- **dtype** (*One of** [**tf.complex64**, **tf.complex128**] **tf.DType** (**dtype**)*)  The dtype of <cite>y</cite>. Defaults to tf.complex64.\nThe output dtype is the corresponding real dtype (tf.float32 or tf.float64).\n\n\nInput\n\n- **(y, h_hat, prior, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **prior** (*[batch_size, num_tx, num_streams, num_data_symbols x num_bits_per_symbol] or [batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float*)  Prior of the transmitted signals.\nIf `output` equals bit, LLRs of the transmitted bits are expected.\nIf `output` equals symbol, logits of the transmitted constellation points are expected.\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **One of**\n- *[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float*  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- *[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int*  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>.\nHard-decisions correspond to the symbol indices."
"### EPDetector\n\n`class` `sionna.ofdm.``EPDetector`(*`output`*, *`resource_grid`*, *`stream_management`*, *`num_bits_per_symbol`*, *`hard_out``=``False`*, *`l``=``10`*, *`beta``=``0.9`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/detection.html#EPDetector)\n\nThis layer wraps the MIMO EP detector for use with the OFDM waveform.\n\nBoth detection of symbols or bits with either\nsoft- or hard-decisions are supported. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\nactual detector is an instance of [`EPDetector`](mimo.html#sionna.mimo.EPDetector).\nParameters\n\n- **output** (*One of** [**\"bit\"**, **\"symbol\"**]**, **str*)  Type of output, either bits or symbols. Whether soft- or\nhard-decisions are returned can be configured with the\n`hard_out` flag.\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **num_bits_per_symbol** (*int*)  Number of bits per constellation symbol, e.g., 4 for QAM16.\nOnly required for `constellation_type` in [qam, pam].\n- **hard_out** (*bool*)  If <cite>True</cite>, the detector computes hard-decided bit values or\nconstellation point indices instead of soft-values.\nDefaults to <cite>False</cite>.\n- **l** (*int*)  Number of iterations. Defaults to 10.\n- **beta** (*float*)  Parameter $\\beta\\in[0,1]$ for update smoothing.\nDefaults to 0.9.\n- **dtype** (*One of** [**tf.complex64**, **tf.complex128**] **tf.DType** (**dtype**)*)  Precision used for internal computations. Defaults to `tf.complex64`.\nEspecially for large MIMO setups, the precision can make a significant\nperformance difference.\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **One of**\n- *[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float*  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- *[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int*  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>.\nHard-decisions correspond to the symbol indices.\n\n\n**Note**\n\nFor numerical stability, we do not recommend to use this function in Graph\nmode with XLA, i.e., within a function that is decorated with\n`@tf.function(jit_compile=True)`.\nHowever, it is possible to do so by setting\n`sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### KBestDetector\n\n`class` `sionna.ofdm.``KBestDetector`(*`output`*, *`num_streams`*, *`k`*, *`resource_grid`*, *`stream_management`*, *`constellation_type``=``None`*, *`num_bits_per_symbol``=``None`*, *`constellation``=``None`*, *`hard_out``=``False`*, *`use_real_rep``=``False`*, *`list2llr``=``None`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/detection.html#KBestDetector)\n\nThis layer wraps the MIMO K-Best detector for use with the OFDM waveform.\n\nBoth detection of symbols or bits with either\nsoft- or hard-decisions are supported. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\nactual detector is an instance of [`KBestDetector`](mimo.html#sionna.mimo.KBestDetector).\nParameters\n\n- **output** (*One of** [**\"bit\"**, **\"symbol\"**]**, **str*)  Type of output, either bits or symbols. Whether soft- or\nhard-decisions are returned can be configured with the\n`hard_out` flag.\n- **num_streams** (*tf.int*)  Number of transmitted streams\n- **k** (*tf.int*)  Number of paths to keep. Cannot be larger than the\nnumber of constellation points to the power of the number of\nstreams.\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **constellation_type** (*One of** [**\"qam\"**, **\"pam\"**, **\"custom\"**]**, **str*)  For custom, an instance of [`Constellation`](mapping.html#sionna.mapping.Constellation)\nmust be provided.\n- **num_bits_per_symbol** (*int*)  Number of bits per constellation symbol, e.g., 4 for QAM16.\nOnly required for `constellation_type` in [qam, pam].\n- **constellation** ()  Instance of [`Constellation`](mapping.html#sionna.mapping.Constellation) or <cite>None</cite>.\nIn the latter case, `constellation_type`\nand `num_bits_per_symbol` must be provided.\n- **hard_out** (*bool*)  If <cite>True</cite>, the detector computes hard-decided bit values or\nconstellation point indices instead of soft-values.\nDefaults to <cite>False</cite>.\n- **use_real_rep** (*bool*)  If <cite>True</cite>, the detector use the real-valued equivalent representation\nof the channel. Note that this only works with a QAM constellation.\nDefaults to <cite>False</cite>.\n- **list2llr** (<cite>None</cite> or instance of [`List2LLR`](mimo.html#sionna.mimo.List2LLR))  The function to be used to compute LLRs from a list of candidate solutions.\nIf <cite>None</cite>, the default solution [`List2LLRSimple`](mimo.html#sionna.mimo.List2LLRSimple)\nis used.\n- **dtype** (*One of** [**tf.complex64**, **tf.complex128**] **tf.DType** (**dtype**)*)  The dtype of <cite>y</cite>. Defaults to tf.complex64.\nThe output dtype is the corresponding real dtype (tf.float32 or tf.float64).\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **One of**\n- *[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float*  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- *[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int*  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>.\nHard-decisions correspond to the symbol indices.\n\n\n**Note**\n\nIf you want to use this layer in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### LinearDetector\n\n`class` `sionna.ofdm.``LinearDetector`(*`equalizer`*, *`output`*, *`demapping_method`*, *`resource_grid`*, *`stream_management`*, *`constellation_type``=``None`*, *`num_bits_per_symbol``=``None`*, *`constellation``=``None`*, *`hard_out``=``False`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/detection.html#LinearDetector)\n\nThis layer wraps a MIMO linear equalizer and a [`Demapper`](mapping.html#sionna.mapping.Demapper)\nfor use with the OFDM waveform.\n\nBoth detection of symbols or bits with either\nsoft- or hard-decisions are supported. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\nactual detector is an instance of [`LinearDetector`](mimo.html#sionna.mimo.LinearDetector).\nParameters\n\n- **equalizer** (*str**, **one of** [**\"lmmse\"**, **\"zf\"**, **\"mf\"**]**, or **an equalizer function*)  Equalizer to be used. Either one of the existing equalizers, e.g.,\n[`lmmse_equalizer()`](mimo.html#sionna.mimo.lmmse_equalizer), [`zf_equalizer()`](mimo.html#sionna.mimo.zf_equalizer), or\n[`mf_equalizer()`](mimo.html#sionna.mimo.mf_equalizer) can be used, or a custom equalizer\nfunction provided that has the same input/output specification.\n- **output** (*One of** [**\"bit\"**, **\"symbol\"**]**, **str*)  Type of output, either bits or symbols. Whether soft- or\nhard-decisions are returned can be configured with the\n`hard_out` flag.\n- **demapping_method** (*One of** [**\"app\"**, **\"maxlog\"**]**, **str*)  Demapping method used\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **constellation_type** (*One of** [**\"qam\"**, **\"pam\"**, **\"custom\"**]**, **str*)  For custom, an instance of [`Constellation`](mapping.html#sionna.mapping.Constellation)\nmust be provided.\n- **num_bits_per_symbol** (*int*)  Number of bits per constellation symbol, e.g., 4 for QAM16.\nOnly required for `constellation_type` in [qam, pam].\n- **constellation** ()  Instance of [`Constellation`](mapping.html#sionna.mapping.Constellation) or <cite>None</cite>.\nIn the latter case, `constellation_type`\nand `num_bits_per_symbol` must be provided.\n- **hard_out** (*bool*)  If <cite>True</cite>, the detector computes hard-decided bit values or\nconstellation point indices instead of soft-values.\nDefaults to <cite>False</cite>.\n- **dtype** (*One of** [**tf.complex64**, **tf.complex128**] **tf.DType** (**dtype**)*)  The dtype of <cite>y</cite>. Defaults to tf.complex64.\nThe output dtype is the corresponding real dtype (tf.float32 or tf.float64).\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **One of**\n- *[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float*  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- *[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int*  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>.\nHard-decisions correspond to the symbol indices.\n\n\n**Note**\n\nIf you want to use this layer in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### MaximumLikelihoodDetector\n\n`class` `sionna.ofdm.``MaximumLikelihoodDetector`(*`output`*, *`demapping_method`*, *`resource_grid`*, *`stream_management`*, *`constellation_type``=``None`*, *`num_bits_per_symbol``=``None`*, *`constellation``=``None`*, *`hard_out``=``False`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/detection.html#MaximumLikelihoodDetector)\n\nMaximum-likelihood (ML) detection for OFDM MIMO transmissions.\n\nThis layer implements maximum-likelihood (ML) detection\nfor OFDM MIMO transmissions. Both ML detection of symbols or bits with either\nsoft- or hard-decisions are supported. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\nactual detector is an instance of [`MaximumLikelihoodDetector`](mimo.html#sionna.mimo.MaximumLikelihoodDetector).\nParameters\n\n- **output** (*One of** [**\"bit\"**, **\"symbol\"**]**, **str*)  Type of output, either bits or symbols. Whether soft- or\nhard-decisions are returned can be configured with the\n`hard_out` flag.\n- **demapping_method** (*One of** [**\"app\"**, **\"maxlog\"**]**, **str*)  Demapping method used\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **constellation_type** (*One of** [**\"qam\"**, **\"pam\"**, **\"custom\"**]**, **str*)  For custom, an instance of [`Constellation`](mapping.html#sionna.mapping.Constellation)\nmust be provided.\n- **num_bits_per_symbol** (*int*)  Number of bits per constellation symbol, e.g., 4 for QAM16.\nOnly required for `constellation_type` in [qam, pam].\n- **constellation** ()  Instance of [`Constellation`](mapping.html#sionna.mapping.Constellation) or <cite>None</cite>.\nIn the latter case, `constellation_type`\nand `num_bits_per_symbol` must be provided.\n- **hard_out** (*bool*)  If <cite>True</cite>, the detector computes hard-decided bit values or\nconstellation point indices instead of soft-values.\nDefaults to <cite>False</cite>.\n- **dtype** (*One of** [**tf.complex64**, **tf.complex128**] **tf.DType** (**dtype**)*)  The dtype of <cite>y</cite>. Defaults to tf.complex64.\nThe output dtype is the corresponding real dtype (tf.float32 or tf.float64).\n\n\nInput\n\n- **(y, h_hat, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN noise\n\n\nOutput\n\n- **One of**\n- *[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float*  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- *[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int*  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>.\nHard-decisions correspond to the symbol indices.\n\n\n**Note**\n\nIf you want to use this layer in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### MaximumLikelihoodDetectorWithPrior\n\n`class` `sionna.ofdm.``MaximumLikelihoodDetectorWithPrior`(*`output`*, *`demapping_method`*, *`resource_grid`*, *`stream_management`*, *`constellation_type``=``None`*, *`num_bits_per_symbol``=``None`*, *`constellation``=``None`*, *`hard_out``=``False`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/detection.html#MaximumLikelihoodDetectorWithPrior)\n\nMaximum-likelihood (ML) detection for OFDM MIMO transmissions, assuming prior\nknowledge of the bits or constellation points is available.\n\nThis layer implements maximum-likelihood (ML) detection\nfor OFDM MIMO transmissions assuming prior knowledge on the transmitted data is available.\nBoth ML detection of symbols or bits with either\nsoft- or hard-decisions are supported. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\nactual detector is an instance of [`MaximumLikelihoodDetectorWithPrior`](mimo.html#sionna.mimo.MaximumLikelihoodDetectorWithPrior).\nParameters\n\n- **output** (*One of** [**\"bit\"**, **\"symbol\"**]**, **str*)  Type of output, either bits or symbols. Whether soft- or\nhard-decisions are returned can be configured with the\n`hard_out` flag.\n- **demapping_method** (*One of** [**\"app\"**, **\"maxlog\"**]**, **str*)  Demapping method used\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **constellation_type** (*One of** [**\"qam\"**, **\"pam\"**, **\"custom\"**]**, **str*)  For custom, an instance of [`Constellation`](mapping.html#sionna.mapping.Constellation)\nmust be provided.\n- **num_bits_per_symbol** (*int*)  Number of bits per constellation symbol, e.g., 4 for QAM16.\nOnly required for `constellation_type` in [qam, pam].\n- **constellation** ()  Instance of [`Constellation`](mapping.html#sionna.mapping.Constellation) or <cite>None</cite>.\nIn the latter case, `constellation_type`\nand `num_bits_per_symbol` must be provided.\n- **hard_out** (*bool*)  If <cite>True</cite>, the detector computes hard-decided bit values or\nconstellation point indices instead of soft-values.\nDefaults to <cite>False</cite>.\n- **dtype** (*One of** [**tf.complex64**, **tf.complex128**] **tf.DType** (**dtype**)*)  The dtype of <cite>y</cite>. Defaults to tf.complex64.\nThe output dtype is the corresponding real dtype (tf.float32 or tf.float64).\n\n\nInput\n\n- **(y, h_hat, prior, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **prior** (*[batch_size, num_tx, num_streams, num_data_symbols x num_bits_per_symbol] or [batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float*)  Prior of the transmitted signals.\nIf `output` equals bit, LLRs of the transmitted bits are expected.\nIf `output` equals symbol, logits of the transmitted constellation points are expected.\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN noise\n\n\nOutput\n\n- **One of**\n- *[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float*  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- *[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int*  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>.\nHard-decisions correspond to the symbol indices.\n\n\n**Note**\n\nIf you want to use this layer in Graph mode with XLA, i.e., within\na function that is decorated with `@tf.function(jit_compile=True)`,\nyou must set `sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."
"### MMSEPICDetector\n\n`class` `sionna.ofdm.``MMSEPICDetector`(*`output`*, *`resource_grid`*, *`stream_management`*, *`demapping_method``=``'maxlog'`*, *`num_iter``=``1`*, *`constellation_type``=``None`*, *`num_bits_per_symbol``=``None`*, *`constellation``=``None`*, *`hard_out``=``False`*, *`dtype``=``tf.complex64`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/ofdm/detection.html#MMSEPICDetector)\n\nThis layer wraps the MIMO MMSE PIC detector for use with the OFDM waveform.\n\nBoth detection of symbols or bits with either\nsoft- or hard-decisions are supported. The OFDM and stream configuration are provided\nby a [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid) and\n[`StreamManagement`](mimo.html#sionna.mimo.StreamManagement) instance, respectively. The\nactual detector is an instance of [`MMSEPICDetector`](mimo.html#sionna.mimo.MMSEPICDetector).\nParameters\n\n- **output** (*One of** [**\"bit\"**, **\"symbol\"**]**, **str*)  Type of output, either bits or symbols. Whether soft- or\nhard-decisions are returned can be configured with the\n`hard_out` flag.\n- **resource_grid** ()  Instance of [`ResourceGrid`](https://nvlabs.github.io/sionna/api/ofdm.html#sionna.ofdm.ResourceGrid)\n- **stream_management** ()  Instance of [`StreamManagement`](mimo.html#sionna.mimo.StreamManagement)\n- **demapping_method** (*One of** [**\"app\"**, **\"maxlog\"**]**, **str*)  The demapping method used.\nDefaults to maxlog.\n- **num_iter** (*int*)  Number of MMSE PIC iterations.\nDefaults to 1.\n- **constellation_type** (*One of** [**\"qam\"**, **\"pam\"**, **\"custom\"**]**, **str*)  For custom, an instance of [`Constellation`](mapping.html#sionna.mapping.Constellation)\nmust be provided.\n- **num_bits_per_symbol** (*int*)  The number of bits per constellation symbol, e.g., 4 for QAM16.\nOnly required for `constellation_type` in [qam, pam].\n- **constellation** ()  An instance of [`Constellation`](mapping.html#sionna.mapping.Constellation) or <cite>None</cite>.\nIn the latter case, `constellation_type`\nand `num_bits_per_symbol` must be provided.\n- **hard_out** (*bool*)  If <cite>True</cite>, the detector computes hard-decided bit values or\nconstellation point indices instead of soft-values.\nDefaults to <cite>False</cite>.\n- **dtype** (*One of** [**tf.complex64**, **tf.complex128**] **tf.DType** (**dtype**)*)  Precision used for internal computations. Defaults to `tf.complex64`.\nEspecially for large MIMO setups, the precision can make a significant\nperformance difference.\n\n\nInput\n\n- **(y, h_hat, prior, err_var, no)**  Tuple:\n- **y** (*[batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex*)  Received OFDM resource grid after cyclic prefix removal and FFT\n- **h_hat** (*[batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex*)  Channel estimates for all streams from all transmitters\n- **prior** (*[batch_size, num_tx, num_streams, num_data_symbols x num_bits_per_symbol] or [batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float*)  Prior of the transmitted signals.\nIf `output` equals bit, LLRs of the transmitted bits are expected.\nIf `output` equals symbol, logits of the transmitted constellation points are expected.\n- **err_var** ([Broadcastable to shape of `h_hat`], tf.float)  Variance of the channel estimation error\n- **no** (*[batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float*)  Variance of the AWGN\n\n\nOutput\n\n- **One of**\n- *[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float*  LLRs or hard-decisions for every bit of every stream, if `output` equals <cite>bit</cite>.\n- *[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int*  Logits or hard-decisions for constellation symbols for every stream, if `output` equals <cite>symbol</cite>.\nHard-decisions correspond to the symbol indices.\n\n\n**Note**\n\nFor numerical stability, we do not recommend to use this function in Graph\nmode with XLA, i.e., within a function that is decorated with\n`@tf.function(jit_compile=True)`.\nHowever, it is possible to do so by setting\n`sionna.Config.xla_compat=true`.\nSee [`xla_compat`](config.html#sionna.Config.xla_compat).\nSee [`xla_compat`](config.html#sionna.Config.xla_compat).\nSee [`xla_compat`](config.html#sionna.Config.xla_compat)."

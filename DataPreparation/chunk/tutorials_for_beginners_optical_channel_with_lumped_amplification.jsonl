"# Optical Channel with Lumped Amplification\n\nIn this notebook, you will learn how to simulate the transmission of a single Gaussian impulse over a lumped amplification channel model consisting of multiple fiber spans and optical amplifiers, so-called Erbium Doped Fiber Amplifiers (EDFA), as shown in the Figure below. We assume a *standard single mode fiber* (S-SMF) and denote the fiber length between two amplifiers by $\\ell_\\text{span}$.\n\n\nLet $G$ denote the amplifier gain and $F$ the noise figure of each EDFA.\n\nAs we focus on the optical channel and not the corresponding signal processing, the transmitter directly generates the optical signal. Hence, all components that, in practice, are required to generate the optical signal given an electrical control voltage (e.g., the Mach-Zehnder-Modulator (MZM)) are assumed to be ideal or are neglected. The same holds on the receiver side, where the photodiode that would add shot noise is neglected.\n\nTo provide a better understanding of the implemented channel impairments (attenuation, noise, dispersion, nonlinearity) introduced during propagation, those are successively enabled, starting with attenuation."
"## Setup\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Import Sionna\ntry:\n    import sionna\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna\nfrom sionna.channel import utils\n```\n\n```python\nimport tensorflow as tf\n# Configure the notebook to use only a single GPU and allocate only as much memory as needed\n# For more details, see https://www.tensorflow.org/guide/gpu\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\n```\n\n```python\nimport numpy as np\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom sionna.channel import utils\n```"
"## Impulse Generation\n\nBefore diving into the first channel model, the simulation shall be parametrized and the initial Gaussian impulse\n\n$$\ng(t)=\\sqrt{P_0\\cdot 2^{\\left(-\\left(\\frac{2t}{T_0}\\right)^2\\right)}}\n$$\n\nis generated. The impulse shall have peak power $P_0$ and a pulse duration of $T_0$. Note that the Gaussian filter is infinitely long, such that $T_0$ is the full width at half-maximum (FWHM) pulse duration.\n\nFurther, the simulation window is set to $T_\\mathrm{sim}=1000\\,\\mathrm{ps}$ and the sample duration is set to $\\Delta_t=1\\,\\mathrm{ps}$.\n\n\n```python\n# Simulation parameters\ndtype = tf.complex128  # Simulation accuracy (double)\nt_sim = int(1e4)  # (ps) Simulation time window\nn_sim = int(1e4)  # Number of simulation samples\n# Channel parameters\nn_span = 3\n# Impulse parameters\np_0 = 3e-2  # (W) Peak power of the Gaussian pulse\nt_0 = 50  # (ps) Norm. temporal scaling of the Gaussian pulse\n# Support\ndt = t_sim / n_sim  # (s) sample duration\nt, f = utils.time_frequency_vector(\n    n_sim, dt, dtype=dtype.real_dtype)  # (ps), (THz) Time and frequency vector\n# Generate Gaussian impulse\ng_0 = np.sqrt(p_0 * 2**(-((2.0*t / t_0) ** 2.0)))\ng_0 = tf.cast(g_0, dtype=dtype)\nG_0 = tf.signal.fftshift(\n        tf.abs(\n            tf.cast(dt, dtype) *\n            tf.signal.fft(g_0) /\n            tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n        ) ** 2\n)\n```\n\n```python\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.plot(t.numpy().flatten(), np.abs(g_0.numpy().flatten())**2, '-')\nax1.set_xlim(-150, 150)\nax1.set_xlabel(r\"$t$ in (ps)\")\nax1.set_ylabel(r\"$|g(t)|^2$ in (W)\")\nax1.grid()\nax2.plot(\n    f.numpy().flatten(),\n    (G_0.numpy().flatten())/np.max(G_0.numpy().flatten()),\n    '-')\nax2.set_xlim(-0.015, 0.015)\nax2.set_xlabel(r\"$f-f_c$ in (THz)\")\nax2.set_ylabel(r\"$\\frac{|G(f-f_c)|^2}{|G_\\mathrm{max}|^2}$\")\nax2.grid()\nax1.legend(['transmitted'])\nplt.tight_layout()\nplt.show()\n```"
"## Attenuation\n\nAttenuation is present in all media including optical fibers. A typical value of $\\alpha=0.046\\,\\mathrm{km}^{-1}$ is used in this notebook. To compensate for this, Erbium doped fiber amplifiers (EDFAs) are required, as shown in the figure at the beginning of this notebook."
"## Amplified Spontaneous Emission Noise\n\nAn optical channel model contains several sources of noise, e.g., amplified spontaneous emission (ASE) and Rayleigh scattering. However, for this experiment, only ASE noise is implemented. It was shown in [1] that this is the most dominant source of noise.\n\nAs we assume a discrete lumped amplification, ASE noise is introduced only due to the amplification by the EDFAs. The noise power is given as\n\n$$\nP_\\mathrm{ASE}=\\rho_\\mathrm{ASE}\\cdot f_\\text{sim}=\\frac{1}{2}G F h f_\\text{c}\\cdot f_\\mathrm{sim}\n$$\n\nand, hence, depends on the gain $G$, the (linear) noise figure $F$, the carrier frequency $f_\\text{c}$, and the simulation bandwidth $f_\\mathrm{sim}$. The intermediate quantitiy $\\rho_\\mathrm{ASE}$ denotes the noise spectral density of the EDFAs and $h$ is Plancks constant. Usually, not the simulation bandwidth but the captured bandwidth $W$ of the receiver is used. Here, for demonstration purpose, our receiver has an infinite bandwidth that is only\nlimited by the simulation $W=f_\\mathrm{sim}$.\n\n**Note** that Sionna also provides ideally distributed Raman amplification, where the noise is introduced in a fiber span. This can be enabled by setting `with_amplification` to `True` when instantiating the `SSFM` layer."
"### Channel Configuration\n\nThe fiber (i.e., *SSFM*) is implemented using normalized units for distance and time. Hence, it is required that the units of the same kind (time, distance, power) for all parameters ($\\alpha$, $\\beta_2$, ) have to be given with the same unit prefix, e.g., for time use always $\\mathrm{ps}$. This does not only simplify the usage of the SSFM but also prevents from dealing with different orders of magnitude within the SSFM.\n\nFor our first experiment only ASE noise is considered and, thus, nonlinearity and chromatic dispersion (CD) are disabled. Attenuation is kept enabled such that the amplifiers are required and introduce the noise. The gain is chosen such that the link becomes transparent (input power equals output power).\n\n\n```python\n# Normalization\nt_norm = 1e-12  # (s) -> (ps) Time normalization\nz_norm = 1e3  # (m) -> (km) Distance normalization\n# Fiber parameters\nf_c = 193.55e12  # (Hz) Abs. Carrier frequency\nlength_sp = 80.0  # (km) Norm. fiber span length\nalpha = 0.046  # (1/km) Norm. fiber attenuation\n# EDFA parameters\ng_edfa = tf.exp(alpha * length_sp)\nf_edfa = 10**(5/10)  # (1) Noise figure\n```\n\n```python\nspan = sionna.channel.optical.SSFM(\n            alpha=alpha,\n            f_c=f_c,\n            length=length_sp,\n            sample_duration=dt,\n            with_amplification=False,\n            with_attenuation=True,\n            with_dispersion=False,\n            with_nonlinearity=False,\n            dtype=dtype,\n            t_norm=t_norm)\namplifier = sionna.channel.optical.EDFA(\n            g=g_edfa,\n            f=f_edfa,\n            f_c=f_c,\n            dt=dt * t_norm,  # t_norm is in absolute (not normalized) units\n            dtype=dtype)\ndef lumped_amplification_channel(inputs):\n    (u_0) = inputs\n    u = u_0\n    for _ in range(n_span):\n        u = span(u)\n        u = amplifier(u)\n    return u\n```"
"### Transmission\n\nNext, the impulse is transmitted over the channel and the output is visualized.\n\n\n```python\nx = g_0\ny = lumped_amplification_channel(x)\nX = tf.signal.fftshift(\n    tf.abs(\n        tf.cast(dt, dtype) *\n        tf.signal.fft(x) /\n        tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n    ) ** 2\n)\nY = tf.signal.fftshift(\n    tf.abs(\n        tf.cast(dt, dtype) *\n        tf.signal.fft(y) /\n        tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n    ) ** 2\n)\n```\n\n```python\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.plot(t.numpy().flatten(), np.abs(x.numpy().flatten())**2, '-')\nax1.plot(t.numpy().flatten(), np.abs(y.numpy().flatten())**2, '--')\nax1.set_xlim(-150, 150)\nax1.set_xlabel(r\"$t$ in (ps)\")\nax1.set_ylabel(r\"$|g(t)|^2$ in (W)\")\nax1.grid()\nax2.plot(\n    f.numpy().flatten(),\n    (X.numpy().flatten())/np.max(X.numpy().flatten()),\n    '-')\nax2.plot(\n    f.numpy().flatten(),\n    (Y.numpy().flatten())/np.max(Y.numpy().flatten()),\n    '--')\nax2.set_xlim(-0.015, 0.015)\nax2.set_xlabel(r\"$f-f_c$ in (THz)\")\nax2.set_ylabel(r\"$\\frac{|G(f-f_c)|^2}{|G_\\mathrm{max}|^2}$\")\nax2.grid()\nax1.legend(['transmitted', 'received'])\nplt.tight_layout()\nplt.show()\n```\n\n\nAs can be seen, attenuation is completely compensated by the EDFAs. However, they introduce significant noise."
"## Chromatic Dispersion\n\nAfter having seen how the noise distorts the original Gaussian impulse, we can now enable the next linear effect, which is chromatic dispersion (CD). Regarding the nonlinear Schrdinger equation that describes the propagation of an optical signal, the impact of CD is parametrized by the group velocity dispersion (GVD) parameter $\\beta_2$, where $\\beta_2=-21.67\\,\\mathrm{ps}^2\\mathrm{km}^{-1}$ is a typical choice."
"### Channel Configuration\n\nBesides the present parameters we now set $\\beta_2$. For a better understanding of CD we disable the noise (`EDFA.f` `=` `0`) from the previous section.\n\n\n```python\nbeta_2 = -21.67  # (ps^2/km) Norm. group velocity dispersion\n```\n\n```python\nspan_cd = sionna.channel.optical.SSFM(\n            alpha=alpha,\n            beta_2=beta_2,\n            f_c=f_c,\n            length=length_sp,\n            sample_duration=dt,\n            with_amplification=False,\n            with_attenuation=True,\n            with_dispersion=True,\n            with_nonlinearity=False,\n            dtype=dtype,\n            t_norm=t_norm)\namplifier_cd = sionna.channel.optical.EDFA(\n            g=g_edfa,\n            f=0,\n            f_c=f_c,\n            dt=dt * t_norm,\n            dtype=dtype)\n\ndef lumped_amplification_channel_cd(inputs):\n    (u_0) = inputs\n    u = u_0\n    for _ in range(n_span):\n        u = span_cd(u)\n        u = amplifier_cd(u)\n    return u\n```"
"### Transmission\n\nWe now transmit the previously generated Gaussian impulse over the optical fiber and compare the received signal with the transmitted impulse.\n\n\n```python\nx = g_0  # previously generated Gaussian impulse\ny = lumped_amplification_channel_cd(x)\nX = tf.signal.fftshift(\n    tf.abs(\n        tf.cast(dt, dtype) *\n        tf.signal.fft(x) /\n        tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n    ) ** 2\n)\nY = tf.signal.fftshift(\n    tf.abs(\n        tf.cast(dt, dtype) *\n        tf.signal.fft(y) /\n        tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n    ) ** 2\n)\nX_angle = tf.math.angle(tf.signal.fftshift(tf.signal.fft(x)))\nY_angle = tf.math.angle(tf.signal.fftshift(tf.signal.fft(y)))\n```\n\n```python\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.plot(t.numpy().flatten(), np.abs(x.numpy().flatten())**2, '-')\nax1.plot(t.numpy().flatten(), np.abs(y.numpy().flatten())**2, '--')\nax1.set_xlim(-250, 250)\nax1.set_xlabel(r\"$t$ in (ps)\")\nax1.set_ylabel(r\"$|g(t)|^2$ in (W)\")\nax1.grid()\nax2.plot(\n    f.numpy().flatten(),\n    (X.numpy().flatten())/np.max(X.numpy().flatten()),\n    '-')\nax2.plot(\n    f.numpy().flatten(),\n    (Y.numpy().flatten())/np.max(Y.numpy().flatten()),\n    '--')\nax2.set_xlim(-0.015, 0.015)\nax2.set_xlabel(r\"$f-f_c$ in (THz)\")\nax2.set_ylabel(r\"$\\frac{|G(f-f_c)|^2}{|G_\\mathrm{max}|^2}$\")\nax2.grid()\nax1.legend(['transmitted', 'received'])\nplt.tight_layout()\nplt.show()\n```\n\n\nCompared to the transmit impulse the received one has significantly broadened in time. The absolute value of the spectrum, nevertheless, stayed the same. By plotting the phase of the received signal one can see the typical parabolic shift.\n\n\n```python\nfig, (ax1) = plt.subplots(1, 1, tight_layout=True)\nax1.plot(t.numpy().flatten(), np.angle(x.numpy().flatten()), '-')\nax1.plot(t.numpy().flatten(), np.angle(y.numpy().flatten()), '--')\nax1.set_xlim(-750, 750)\nax1.set_xlabel(r\"$t$ in (ps)\")\nax1.set_ylabel(\"$\\u2220 x(t), \\u2220 y(t)$\")\nax1.grid()\nax1.legend(['transmitted', 'received'])\nplt.tight_layout()\nplt.show()\n```"
"## Kerr Nonlinearity\n\nLast, we depict the Kerr nonlinearity and, for a better understanding, disable all previous impairments. This nonlinear effect applies a phase shift to the transmitted signal depending on its instantaneous power. Hence, we should see a phase that, in contrast to the phase of the original signal which is zero, follows the (inverse) absolute value of the impulse.\n\n**Note:** Only the interaction between Kerr nonlinearity and CD requires an SSFM for fiber simulation. Otherwise (as done so far), the transfer function of the individual effect is just a single multiplication (in time- or Fourier-domain, respectively)."
"### Channel configuration\n\nSimilarly to the definition of CD, we specify a typical value for $\\gamma=1.27\\,\\mathrm{\\frac{1}{km W}}$.\n\n\n```python\ngamma = 1.27  # (1/W/km) Nonlinearity coefficient\n```\n\n```python\nspan_nl = sionna.channel.optical.SSFM(\n            alpha=alpha,\n            beta_2=beta_2,\n            f_c=f_c,\n            length=length_sp,\n            sample_duration=dt,\n            with_amplification=False,\n            with_attenuation=True,\n            with_dispersion=False,\n            with_nonlinearity=True,\n            dtype=dtype, t_norm=t_norm)\namplifier_nl = sionna.channel.optical.EDFA(\n            g=g_edfa,\n            f=0,\n            f_c=f_c,\n            dt=dt * t_norm,\n            dtype=dtype)\n\ndef lumped_amplification_channel_nl(inputs):\n    (u_0) = inputs\n    u = u_0\n    for _ in range(n_span):\n        u = span_nl(u)\n        u = amplifier_nl(u)\n    return u\n```"
"### Transmission\n\nWe now transmit the same Gaussian impulse again over the optical fiber where only Kerr nonlinearity is activated.\n\n\n```python\nx = g_0\ny = lumped_amplification_channel_nl(x)\nX = tf.signal.fftshift(\n    tf.abs(\n        tf.cast(dt, dtype) *\n        tf.signal.fft(x) /\n        tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n    ) ** 2\n)\nY = tf.signal.fftshift(\n    tf.abs(\n        tf.cast(dt, dtype) *\n        tf.signal.fft(y) /\n        tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n    ) ** 2\n)\nX_angle = tf.math.angle(tf.signal.fftshift(tf.signal.fft(x)))\nY_angle = tf.math.angle(tf.signal.fftshift(tf.signal.fft(y)))\n```\n\n```python\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.plot(t.numpy().flatten(), np.abs(x.numpy().flatten())**2, '-')\nax1.plot(t.numpy().flatten(), np.abs(y.numpy().flatten())**2, '--')\nax1.set_xlim(-150, 150)\nax1.set_xlabel(r\"$t$ in (ps)\")\nax1.set_ylabel(\"$\\u2220 x(t), \\u2220 y(t)$\")\nax1.grid()\nax2.plot(\n    f.numpy().flatten(),\n    (X.numpy().flatten())/np.max(X.numpy().flatten()),\n    '-')\nax2.plot(\n    f.numpy().flatten(),\n    (Y.numpy().flatten())/np.max(Y.numpy().flatten()),\n    '--')\nax2.set_xlim(-0.015, 0.015)\nax2.set_xlabel(r\"$f-f_c$ in (THz)\")\nax2.set_ylabel(r\"$\\frac{|G(f-f_c)|^2}{|G_\\mathrm{max}|^2}$\")\nax2.grid()\nax1.legend(['transmitted', 'received'])\nplt.tight_layout()\n\nplt.show()\n```\n\n\nAs shown in the previous plot the (isolated) Kerr nonlinearity does not affect the absolute value of the signals amplitude but only shifts the phase (see below).\n\nFurther, the bandwidth of the transmit signal was slightly increased.\n\n**Hint**: Increasing the peak power $p_0$ of the transmitted impuls increases the impact of the Kerr nonlinearity.\n\n\n```python\nfig, (ax1) = plt.subplots(1, 1, tight_layout=True)\nax1.plot(t.numpy().flatten(), np.angle(x.numpy().flatten()), '-')\nax1.plot(t.numpy().flatten(), np.angle(y.numpy().flatten()), '--')\nax1.set_xlim(-750, 750)\nax1.set_xlabel(\"$t$ in (ps)\")\nax1.set_ylabel(\"$\\u2220 x(t), \\u2220 y(t)$\")\nax1.grid()\nax1.legend(['transmitted', 'received'])\nplt.tight_layout()\nplt.show()\n```"
"## Split-Step Fourier Method\n\nLast, we perform the true SSFM to simulate the impairments (ASE noise, CD, and Kerr nonlinearity) jointly. As this is computationally complex, we compile the channel model before its execution by adding the `tf.function` decorator."
"### Channel Configuration\n\nKeeping the former configuration, we only have to increase the number of SSFM simulation steps.\n\n\n```python\nn_ssfm = 160  # number of SSFM simulation steps\n```\n\n```python\nspan_ssfm = sionna.channel.optical.SSFM(\n            alpha=alpha,\n            beta_2=beta_2,\n            gamma=gamma,\n            f_c=f_c,\n            length=length_sp,\n            sample_duration=dt,\n            n_ssfm=n_ssfm,\n            with_amplification=False,\n            with_attenuation=True,\n            with_dispersion=True,\n            with_nonlinearity=True,\n            dtype=dtype,\n            t_norm=t_norm)\namplifier_ssfm = sionna.channel.optical.EDFA(\n            g=g_edfa,\n            f=0,\n            f_c=f_c,\n            dt=dt * t_norm,\n            dtype=dtype)\n@tf.function\ndef lumped_amplification_channel_ssfm(inputs):\n    (u_0) = inputs\n    u = u_0\n    for _ in range(1):\n        u = span_ssfm(u)\n        u = amplifier_ssfm(u)\n    return u\n```"
"### Transmission\n\nWe transmit the Gaussian impulse over the optical fiber. However, we have now enabled ASE noise, CD, and Kerr nonlinearity.\n\n\n```python\nx = g_0\ny = lumped_amplification_channel_ssfm(x)\nX = tf.signal.fftshift(\n    tf.abs(\n        tf.cast(dt, dtype) *\n        tf.signal.fft(x) /\n        tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n    ) ** 2\n)\nY = tf.signal.fftshift(\n    tf.abs(\n        tf.cast(dt, dtype) *\n        tf.signal.fft(y) /\n        tf.cast(tf.math.sqrt(2 * np.pi), dtype)\n    ) ** 2\n)\nX_angle = tf.math.angle(tf.signal.fftshift(tf.signal.fft(x)))\nY_angle = tf.math.angle(tf.signal.fftshift(tf.signal.fft(y)))\n```\n\n```python\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.plot(t.numpy().flatten(), np.abs(x.numpy().flatten())**2, '-')\nax1.plot(t.numpy().flatten(), np.abs(y.numpy().flatten())**2, '--')\nax1.set_xlim(-150, 150)\nax1.set_xlabel(r\"$t$ in (ps)\")\nax1.set_ylabel(r\"$|g(t)|^2$ in (W)\")\nax1.grid()\nax2.plot(\n    f.numpy().flatten(),\n    (X.numpy().flatten()/np.max(X.numpy().flatten())),\n    '-')\nax2.plot(\n    f.numpy().flatten(),\n    (Y.numpy().flatten()/np.max(Y.numpy().flatten())),\n    '--')\nax2.set_xlim(-0.015, 0.015)\nax2.set_xlabel(r\"$f-f_c$ in (THz)\")\nax2.set_ylabel(r\"$\\frac{|G(f-f_c)|^2}{|G_\\mathrm{max}|^2}$\")\nax2.grid()\nax1.legend(['transmitted', 'received'])\nplt.tight_layout()\nplt.show()\n```\n\n\n```python\nfig, (ax1) = plt.subplots(1, 1, tight_layout=True)\nax1.plot(t.numpy().flatten(), np.angle(x.numpy().flatten()), '-')\nax1.plot(t.numpy().flatten(), np.angle(y.numpy().flatten()), '--')\nax1.set_xlim(-500, 500)\nax1.set_xlabel(\"$t$ in (ps)\")\nax1.set_ylabel(\"$\\u2220 x(t), \\u2220 y(t)$\")\nax1.grid()\nax1.legend(['transmitted', 'received'])\nplt.tight_layout()\nplt.show()\n```"
"The most interesting observation that one can make here is that the spectrum of the received signal is compressed. This is in contrast to the expected Kerr nonlinearity-induced spectral broadening, and shows that joint application of the fiber effects may result in completely different observations compared to the isolated investigation.\n\nWhat we can see here, however, is that the Gaussian input impulse is transformed to a higher-order Soliton during propagation. Those require a joint CD and Kerr nonlinearity to exist."
"## References\n\n[1] Ren-Jean Essiambre, Gerhard Kramer, Peter J. Winzer, Gerard J. Foschini, and Bernhard Goebel. Capacity Limits of Optical Fiber Networks. Journal of Lightwave Technology 28, Nr. 4, pp 662701, February 2010.[1] Ren-Jean Essiambre, Gerhard Kramer, Peter J. Winzer, Gerard J. Foschini, and Bernhard Goebel. Capacity Limits of Optical Fiber Networks. Journal of Lightwave Technology 28, Nr. 4, pp 662701, February 2010.[1] Ren-Jean Essiambre, Gerhard Kramer, Peter J. Winzer, Gerard J. Foschini, and Bernhard Goebel. Capacity Limits of Optical Fiber Networks. Journal of Lightwave Technology 28, Nr. 4, pp 662701, February 2010.[1] Ren-Jean Essiambre, Gerhard Kramer, Peter J. Winzer, Gerard J. Foschini, and Bernhard Goebel. Capacity Limits of Optical Fiber Networks. Journal of Lightwave Technology 28, Nr. 4, pp 662701, February 2010."

"# Pulse-shaping Basics\n\nIn this tutorial notebook, you will learn about various components of Sionnas signal module, such as pulse-shaping filters, windowing functions, as well as layers for up- and down-sampling.\n\nBelow is a schematic diagram of the used components and how they connect. For simplicity, we have not added any channel between the pulse-shaping filter and the matched filter.\n\n\nYou will learn how to:\n\n- Use filters for pulse-shaping and matched filtering\n- Visualize impulse and magnitude responses\n- Compute the empirical power spectral density (PSD) and adjacent channel leakage power ratio (ACLR)\n- Apply the Upsampling and Downsampling layers\n- Add windowing to filters for improved spectral characteristics"
"## GPU Configuration and Imports\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Import Sionna\ntry:\n    import sionna\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna\n# Configure the notebook to use only a single GPU and allocate only as much memory as needed\n# For more details, see https://www.tensorflow.org/guide/gpu\nimport tensorflow as tf\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\n```\n\n```python\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sionna.utils import QAMSource\nfrom sionna.signal import Upsampling, Downsampling, RootRaisedCosineFilter, empirical_psd, empirical_aclr\n```"
"## Pulse-shaping of a sequence of QAM symbols\n\nWe start by creating a root-raised-cosine filter with a roll-off factor of 0.22, spanning 32 symbols, with an oversampling factor of four.\n\n\n```python\nbeta = 0.22 # Roll-off factor\nspan_in_symbols = 32 # Filter span in symbold\nsamples_per_symbol = 4 # Number of samples per symbol, i.e., the oversampling factor\nrrcf = RootRaisedCosineFilter(span_in_symbols, samples_per_symbol, beta)\n```\n\n\nAll filters have a function to visualize their impulse response $h(t)$ and magnitude response $H(f)$, i.e., the absolute value of the Fourier transform of $h(t)$. The symbol duration is denoted $T$ and the bandwidth $W$. The *normalized time* and *normalized frequency* are then defined as $t/T$ and $f/W$, respectively.\n\n\n```python\nrrcf.show(\"impulse\")\nrrcf.show(\"magnitude\", \"db\") # Logarithmic scale\nrrcf.show(\"magnitude\", \"lin\") # Linear scale\n```\n\n\nIn Sionna, filters have always an odd number of samples. This is despite the fact that the product *span_in_symbols* $\\times$ *samples_per_symbol* can be even. Let us verify the length property of our root-raised-cosine filter:\n\n\n```python\nprint(\"Filter length:\", rrcf.length)\n```\n\n\n```python\nFilter length: 129\n```\n\n\nNext, we will use this filter to pulse shape a sequence of QAM symbols. This requires upsampling of the sequence to the desired sampling rate. The sampling rate is defined as the number of samples per symbol $k$, and upsampling simply means that $k-1$ zeros are inserted after every QAM symbol.\n\n\n```python\n# Configure QAM source\nnum_bits_per_symbol = 4 # The modulation order of the QAM constellation, i.e., 16QAM\nqam = QAMSource(num_bits_per_symbol) # Layer to generate batches of QAM symbols\n# Generate batch of QAM symbol sequences\nbatch_size = 128\nnum_symbols = 1000\nx = qam([batch_size, num_symbols])\nprint(\"Shape of x\", x.shape)\n# Create instance of the Upsampling layer\nus = Upsampling(samples_per_symbol)\n# Upsample the QAM symbol sequence\nx_us = us(x)\nprint(\"Shape of x_us\", x_us.shape)\n# Inspect the first few elements of one row of x_us\nplt.stem(np.abs(x_us)[0,:20]);\nplt.xlabel(r\"Sample index $i$\")\nplt.ylabel(r\"|$x_{us}[i]$|\");\n```"
"```python\nShape of x (128, 1000)\nShape of x_us (128, 4000)\n```\n\n\nAfter upsampling, we can apply the filter:\n\n\n```python\n# Filter the upsampled sequence\nx_rrcf = rrcf(x_us)\n```"
"## Recovering the QAM symbols through matched filtering and downsampling\n\nIn order to recover the QAM symbols from this waveform, we need to apply a matched filter, i.e., the same filter in our case, and downsample the result, starting from the correct index. This index can be obtained as follows. The transmit filter has its peak value after $(L-1)/2$ samples, where $L$ is the filter length. If we apply the same filter for reception, the peak will be delayed by a total of $L-1$ samples. The code in the following cell creates a Downsampling layer that\nallows us to recover the transmitted symbol sequence.\n\n\n```python\n# Apply the matched filter\nx_mf = rrcf(x_rrcf)\n# Instantiate a downsampling layer\nds = Downsampling(samples_per_symbol, rrcf.length-1, num_symbols)\n# Recover the transmitted symbol sequence\nx_hat = ds(x_mf)\n# Visualize the different signals\nplt.figure(figsize=(12, 8))\nplt.plot(np.real(x_us[0]), \"x\")\nplt.plot(np.real(x_rrcf[0, rrcf.length//2:]))\nplt.plot(np.real(x_mf[0, rrcf.length-1:]));\nplt.xlim(0,100)\nplt.legend([r\"Oversampled sequence of QAM symbols $x_{us}$\",\n            r\"Transmitted sequence after pulse shaping $x_{rrcf}$\",\n            r\"Received sequence after matched filtering $x_{mf}$\"]);\n```\n\n\nWe can see nicely from the above figure that the signal after matched filtering overlaps almost perfectly with the oversampled sequence of QAM symbols at the symbol times. As further verification, we will next show a scatter plot of the transmitted and recovered symbols and compute the mean-squared error (MSE) between them. As one can see, the MSE is not zero, which is due to truncation of the filter to finite length. The MSE can be reduced by making the filter longer or by increasing the\nroll-off factor.\n\nGive it a try and change *span_in_symbols* above to a larger number, e.g., 100. This will reduce the MSE by around 26dB.\n\n\n```python\nplt.figure()\nplt.scatter(np.real(x_hat), np.imag(x_hat));\nplt.scatter(np.real(x), np.imag(x));\nplt.legend([\"Transmitted\", \"Received\"]);\nplt.title(\"Scatter plot of the transmitted and received QAM symbols\")\nprint(\"MSE between x and x_hat (dB)\", 10*np.log10(np.var(x-x_hat)))\n```"
"## Investigating the ACLR\n\nAn important metric of waveforms is the so-called adjacent channel leakage power ratio, or short ACLR. It is defined as the ratio of the out-of-band power and the in-band power. One can get a first idea of the ACLR by looking at the power spectral density (PSD) of a transmitted signal.\n\n\n```python\nempirical_psd(x_rrcf, oversampling=samples_per_symbol, ylim=[-100, 3]);\n```\n\n\nThe in-band is defined by the interval from [-0.5, 0.5] in normalized frequency. Due to the non-zero roll-of factor, a significant amount of energy is located out of this band. The resulting ACLR can be computed with the following convenience function:\n\n\n```python\naclr_db = 10*np.log10(empirical_aclr(x_rrcf, oversampling=samples_per_symbol))\nprint(\"Empirical ACLR (db):\", aclr_db)\n```\n\n\n```python\nEmpirical ACLR (db): -13.801279067993164\n```\n\n\nWe can now verify that this empirical ACLR is well aligned with the theoretical ACLR that can be computed based on the magnitude response of the pulse-shaping filter. Every filter provides this value as the property *Filter.aclr*.\n\n\n```python\nprint(\"Filter ACLR (dB)\", 10*np.log10(rrcf.aclr))\n```\n\n\n```python\nFilter ACLR (dB) -13.805673122406006\n```\n\n\nWe can improve the ACLR by decreasing the roll-off factor $\\beta$ from 0.22 to 0.1:\n\n\n```python\nprint(\"Filter ACLR (dB)\", 10*np.log10(RootRaisedCosineFilter(span_in_symbols, samples_per_symbol, 0.1).aclr))\n```\n\n\n```python\nFilter ACLR (dB) -17.342106103897095\n```"
"## Windowing\n\nWindowing can be used to improve the spectral properties of a truncated filter. For a filter of length $L$, a window is a real-valued vector of the same length that is multiplied element-wise with the filter coefficients. This is equivalent to a convolution of the filter and the window in the frequency domain.\n\nLet us now create a slightly shorter root-raised-cosine filter and compare its properties with and without windowing. One can see that windowing leads to a much reduced out-of-band attenuation. However, the passband of the filter is also broadened which leads to an even slightly increased ACLR.\n\n\n```python\nspan_in_symbols = 8 # Filter span in symbols\nsamples_per_symbol = 8 # Number of samples per symbol, i.e., the oversampling factor\nrrcf_short = RootRaisedCosineFilter(span_in_symbols, samples_per_symbol, beta)\nrrcf_short_blackman = RootRaisedCosineFilter(span_in_symbols, samples_per_symbol, beta, window=\"blackman\")\nrrcf_short_blackman.window.show(samples_per_symbol)\nrrcf_short_blackman.window.show(samples_per_symbol, domain=\"frequency\", scale=\"db\")\nrrcf_short.show()\nplt.title(\"Impulse response without windowing\")\nrrcf_short_blackman.show()\nplt.title(\"Impulse response with windowing\")\nrrcf_short.show(\"magnitude\", \"db\")\nplt.title(\"Magnitude response without windowing\")\nrrcf_short_blackman.show(\"magnitude\", \"db\")\nplt.title(\"Magnitude response with windowing\")\nprint(\"ACLR (db) without window\", 10*np.log10(rrcf_short.aclr))\nprint(\"ACLR (db) with window\", 10*np.log10(rrcf_short_blackman.aclr))\n```\n\n\n```python\nACLR (db) without window -13.982985019683838\nACLR (db) with window -12.624131441116333\n```"

"# Tutorial on Diffraction\n\nIn this notebook, you will\n\n- Learn what diffraction is and why it is important\n- Make various ray tracing experiments to validate some theoretical results\n- Familiarize yourself with the Sionna RT API\n- Visualize the impact of diffraction on channel impulse responses and coverage maps"
"## GPU Configuration and Imports\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Colab does currently not support the latest version of ipython.\n# Thus, the preview does not work in Colab. However, whenever possible we\n# strongly recommend to use the scene preview mode.\ntry: # detect if the notebook runs in Colab\n    import google.colab\n    colab_compat = True # deactivate preview\nexcept:\n    colab_compat = False\nresolution = [480,320] # increase for higher quality of renderings\n# Allows to exit cell execution in Jupyter\nclass ExitCell(Exception):\n    def _render_traceback_(self):\n        pass\n# Import Sionna\ntry:\n    import sionna\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna\n# Configure the notebook to use only a single GPU and allocate only as much memory as needed\n# For more details, see https://www.tensorflow.org/guide/gpu\nimport tensorflow as tf\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\ntf.random.set_seed(1) # Set global random seed for reproducibility\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sys\nfrom sionna.rt import load_scene, PlanarArray, Transmitter, Receiver, RadioMaterial, Camera\nfrom sionna.rt.utils import r_hat\nfrom sionna.constants import PI, SPEED_OF_LIGHT\nfrom sionna.utils import expand_to_rank\n```"
"## Background Information\n\n\nLets consider an infinitely long wedge as shown in the figure above. To better visualize this, think of an endless slice of pie. The edge vector is pointed straight out of your screen and the wedge has an opening angle of $n\\pi$, where $n$ is a real number between 1 and 2.\n\nThe wedge has two faces, the 0- and the n-face. They are labeled this way to indicate from which surface the angle $\\phi'\\in[0,n]$ of an incoming locally planar electromagnetic wave is measured. Both faces are made from possibly different materials, each with their own unique properties. These properties are represented by a term known as complex relative permittivity, denoted by $\\eta_0$ and $\\eta_n$, respectively. Without diving too deep into the specifics, permittivity\nmeasures how a material reacts to an applied electric field.\n\nWe can define three distinct regions in this figure: Region $I$, in which the incident field as well as the reflected field from the 0-face are present, Region $II$, in which the reflected field vanishes, and Region $III$, in which the incident field is shadowed by the wedge. The three regions are separated by the reflection shadow boundary (RSB) and the incident shadow boundary (ISB). The former is determined by the angle of specular reflection $\\pi-\\phi'$, while the\nlatter is simply the prolongation of the direction of the incoming wave through the edge, i.e., $\\pi+\\phi'$.\n\nUsing geometrical optics (GO) alone, the electromagnetic field would abruptly change at each boundary as the reflected and incident field components suddenly disappear. As this is physically not plausible, the geometrical theory of diffraction (GTD) [1], as developed by Joseph B. Keller in the 1960s, introduces a so-called diffracted field which ensures that the total field is continuous. The diffracted field is hence especially important in the transition regions between the different regions\nand then rapidly decays to zero. Most importantly, without diffraction, there would be no field beyond the ISB in Region $III$.\n\nDiffraction is hence a very important phenomenon which enables wireless coverage behind buildings at positions without a line-of-sight of strong reflected path. As you will see later in this tutorial, the diffracted field is generally much weaker than the incident or reflected field. Moreover, the higher the frequency, the faster the diffracted field decays when moving away from the RSB and ISB.\n\n\nAccording to the GTD, when a ray hits a point on the edge, its energy gets spread over a continuum of rays lying on the Keller cone. All rays on this cone make equal angles with the edge of diffraction at the point of diffraction, i.e., $\\beta_0'=\\beta_0$. One can think of this phenomenon as an extension of the law of reflection at planar surfaces. The figures above illustrates this concept.\n\nThe GTD was later extended to the uniform theory of diffraction (UTD) [2,3] which overcomes some of its shortcomings.\n\nWe will explore in this notebook these effects in detail and also validate the UTD implementation in Sionna RT as a by-product.\n\n**Wedge vs Edge**\n\nFirst, it is important to know the difference between a *wedge* and an *edge*, and why we distinguish between them.\n\nSionna defines a *wedge* as the line segment between two primitives, i.e., the common segment of two triangles. For example, a cubic building would have 12 wedges.\n\nFor primitives that have one or more line segments that are not shared with another primitive, Sionna refers to such line segments as *edges*. See [sionna.rt.scene.floor_wall](https://nvlabs.github.io/sionna/api/rt.html#sionna.rt.scene.floor_wall) for an example scene.\n\nBy default, Sionna does not simulate diffraction on edges (`edge_diffraction=False`), to avoid problems such as diffraction on the exterior edges of the ground surface (modelled as a rectangular plane)."
"## Experiments with a Simple Wedge\n\nWe start by loading a pre-made scene from Sionna RT that contains a simple wedge:\n\n\n```python\nscene = load_scene(sionna.rt.scene.simple_wedge)\n# Create new camera with different configuration\nmy_cam = Camera(\"my_cam\", position=[10,-100,100], look_at=[10,0,0])\nscene.add(my_cam)\n# Render scene\nscene.render(my_cam);\n# You can also preview the scene with the following command\n# scene.preview()\n```\n\n\nThe wedge has an opening angle of $\\frac{3}{2}\\pi=270^\\circ$, i.e., $n=1.5$. The 0-face is aligned with the x axis and the n-face aligned with the negative y axis.\n\nFor the following experiments, we will configure the wedge to be made of metal, an almost perfect conductor, and set the frequency to 1GHz.\n\n\n```python\nscene.frequency = 1e9 # 1GHz\nscene.objects[\"wedge\"].radio_material = \"itu_metal\" # Almost perfect reflector\n```\n\n\nWith our scene being set-up, we now need to configure a transmitter and place multiple receivers to measure the field. We assume that the transmitter and all receivers have a single vertically polarized isotropic antenna.\n\n\n```python\n# Configure the antenna arrays used by the transmitters and receivers\nscene.tx_array = PlanarArray(num_rows=1,\n                             num_cols=1,\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"iso\",\n                             polarization=\"V\")\nscene.rx_array = scene.tx_array\n```\n\n```python\n# Transmitter\ntx_angle = 30/180*PI # Angle phi from the 0-face\ntx_dist = 50 # Distance from the edge\ntx_pos = 50*r_hat(PI/2, tx_angle)\nref_boundary = (PI - tx_angle)/PI*180\nlos_boundary = (PI + tx_angle)/PI*180\nscene.add(Transmitter(name=\"tx\",\n                      position=tx_pos,\n                      orientation=[0,0,0]))\n# Receivers\n# We place num_rx receivers uniformly spaced on the segment of a circle around the wedge\nnum_rx = 1000 # Number of receivers\nrx_dist = 5 # Distance from the edge\nphi = tf.linspace(1e-2, 3/2*PI-1e-2, num=num_rx)\ntheta = PI/2*tf.ones_like(phi)\nrx_pos = rx_dist*r_hat(theta, phi)\nfor i, pos in enumerate(rx_pos):\n    scene.add(Receiver(name=f\"rx-{i}\",\n                       position=pos,\n                       orientation=[0,0,0]))\n```"
"```python\n# Render scene\nmy_cam.position = [-30,100,100]\nmy_cam.look_at([10,0,0])\nscene.render(my_cam);\n```\n\n\nIn the above figure, the blue ball is the transmitter and the green circle corresponds to 1000 receivers uniformly distributed over a segment of a circle around the edge.\n\nNext, we compute the channel impulse response between the transmitter and all of the receivers. We deactivate scattering in this notebook as it would require a prohibitive amount of memory with such a large number of receivers.\n\n\n```python\n# Compute paths between the transmitter and all receivers\npaths = scene.compute_paths(num_samples=1e6,\n                            los=True,\n                            reflection=True,\n                            diffraction=True,\n                            scattering=False)\n# Obtain channel impulse responses\n# We squeeze irrelevant dimensions\n# [num_rx, max_num_paths]\na, tau = [np.squeeze(t) for t in paths.cir()]\n```\n\n```python\ndef compute_gain(a, tau):\n        \"\"\"Compute $|H(f)|^2 at f = 0 where H(f) is the baseband channel frequency response\"\"\"\n        a = tf.squeeze(a, axis=-1)\n        h_f_2 = tf.math.abs(tf.reduce_sum(a, axis=-1))**2\n        h_f_2 = tf.where(h_f_2==0, 1e-24, h_f_2)\n        g_db = 10*np.log10(h_f_2)\n        return tf.squeeze(g_db)\n```\n\n\nLets have a look at the channel impulse response of one of the receivers:\n\n\n```python\nn = 400\nplt.figure()\nplt.stem(tau[n]/1e-9, 10*np.log10(np.abs(a[n])**2))\nplt.title(f\"Angle of receiver $\\phi: {int(phi[n]/PI*180)}^\\circ$\");\nplt.xlabel(\"Delay (ns)\");\nplt.ylabel(\"$|a|^2$ (dB)\");\n```\n\n\nFor an angle of around 108 degrees, the receiver is located within Region I, where all propagation effects should be visible. As expected, we can observe three path: line-of-sight, reflected, and diffracted. While the first two have roughly the same strength (as metal is an almost perfect reflector), the diffracted path has significantly lower energy.\n\nNext, let us compute the channel frequency response $H(f)$ as the sum of all paths multiplied with their complex phase factors:\n\n$$\nH(f) = \\sum_{i=1}^N a_i e^{-j2\\pi\\tau_i f}\n$$"
"```python\nh_f_tot = np.sum(a, axis=-1)\n```\n\n\nWe can now visualize the path gain $|H(f)|^2$ for all receivers, i.e., as a function of the angle $\\phi$:\n\n\n```python\nfig = plt.figure()\nplt.plot(phi/PI*180, 20*np.log10(np.abs(h_f_tot)))\nplt.xlabel(\"Diffraction angle $\\phi$ (deg)\");\nplt.ylabel(r\"Path gain $|H(f)|^2$ (dB)\");\nplt.ylim([-100, -59]);\nplt.xlim([0, phi[-1]/PI*180]);\n```\n\n\nThe most important observation from the figure above is that $H(f)$ remains continous over the entire range of $\\phi$, especially at the RSB and ISB boundaries at around $\\phi=150^\\circ$ and $\\phi=209^\\circ$, respectively.\n\nTo get some more insight, the convenience function in the next cell, computes and visualizes the different components of $H(f)$ by their type.\n\n\n```python\ndef plot(frequency, material):\n    \"\"\"Plots the path gain $|H(f)|^2 versus $phi$ for a given\n       frequency and RadioMaterial of the wedge.\n    \"\"\"\n    # Set carrier frequency and material of the wedge\n    # You can see a list of available materials by executing\n    # scene.radio_materials\n    scene.frequency = frequency\n    scene.objects[\"wedge\"].radio_material = material\n    # Recompute paths with the updated material and frequency\n    paths = scene.compute_paths(num_samples=1e6,\n                                los=True,\n                                reflection=True,\n                                diffraction=True,\n                                scattering=False)\n    def compute_gain(a, tau):\n        \"\"\"Compute $|H(f)|^2 are f = 0 where H(f) is the baseband channel frequency response\"\"\"\n        a = tf.squeeze(a, axis=-1)\n        h_f_2 = tf.math.abs(tf.reduce_sum(a, axis=-1))**2\n        h_f_2 = tf.where(h_f_2==0, 1e-24, h_f_2)\n        g_db = 10*np.log10(h_f_2)\n        return tf.squeeze(g_db)\n    # Compute gain for all path types\n    g_tot_db = compute_gain(*paths.cir())\n    g_los_db = compute_gain(*paths.cir(reflection=False, diffraction=False, scattering=False))\n    g_ref_db = compute_gain(*paths.cir(los=False, diffraction=False, scattering=False))\n    g_dif_db = compute_gain(*paths.cir(los=False, reflection=False, scattering=False))\n    # Make a nice plot\n    fig = plt.figure()\n    phi_deg = phi/PI*180\n    ymax = np.max(g_tot_db)+5\n    ymin = ymax - 45\n    plt.plot(phi_deg, g_tot_db)\n    plt.plot(phi_deg, g_los_db)\n    plt.plot(phi_deg, g_ref_db)\n    plt.plot(phi_deg, g_dif_db)\n    plt.ylim([ymin, ymax])\n    plt.xlim([phi_deg[0], phi_deg[-1]]);\n    plt.legend([\"Total\", \"LoS\", \"Reflected\", \"Diffracted\"], loc=\"lower left\")\n    plt.xlabel(\"Diffraction angle $\\phi$ (deg)\")\n    plt.ylabel(\"Path gain $|H(f)|^2$ (dB)\")\n    ax = fig.axes[0]\n    ax.axvline(x=ref_boundary, ymin=0, ymax=1, color=\"black\", linestyle=\"--\")\n    ax.axvline(x=los_boundary, ymin=0, ymax=1, color=\"black\", linestyle=\"--\")\n    ax.text(ref_boundary-10,ymin+5,'RSB',rotation=90,va='top')\n    ax.text(los_boundary-10,ymin+5,'ISB',rotation=90,va='top')\n    ax.text(ref_boundary/2,ymax-2.5,'Region I', ha='center', va='center',\n            bbox=dict(facecolor='none', edgecolor='black', pad=4.0))\n    ax.text(los_boundary-(los_boundary-ref_boundary)/2,ymax-2.5,'Region II', ha='center', va='center',\n            bbox=dict(facecolor='none', edgecolor='black', pad=4.0))\n    ax.text(phi_deg[-1]-(phi_deg[-1]-los_boundary)/2,ymax-2.5,'Region III', ha='center', va='center',\n            bbox=dict(facecolor='none', edgecolor='black', pad=4.0))\n    plt.title('$f={}$ GHz (\"{}\")'.format(frequency/1e9, material))\n    plt.tight_layout()\n    return fig\n```"
"```python\nplot(1e9, \"itu_metal\");\n```\n\n\nThe figure above shows the path gain for the total field as well as that for the different path types. In Region $I$, the line-of-sight and reflected paths dominate the total field. While their contributions are almost constant over the range of $\\phi\\in[0,150^\\circ]$, their combined field exhibits large fluctutations due to constructive and destructive interference. As we approach the RSB, the diffracted field increases to ensure continuity at $\\phi=150^\\circ$, where the\nreflected field immediately drops to zero. A similar observation can be made close to the ISB, where the incident (or line-of-sight) component suddenly vanishes. In Region $III$, the only field contribution comes from the diffracted field.\n\nLet us now have a look at what happens when we change the frequency to $10\\,$GHz.\n\n\n```python\nplot(10e9, \"itu_metal\");\n```\n\n\nThe first observation we can make is that the overall path gain has dropped by around $20\\,$dB. This is expected as it is proportional to the square of the wavelength $\\lambda$.\n\nThe second noticeable difference is that the path gain fluctuates far more rapidly. This is simply due to the shorter wavelength.\n\nThe third observation we can make is that the diffracted field decays far more radpily when moving away from the boundaries as compared to a frequency of $1\\,$GHz. Thus, diffraction is less important at high frequencies.\n\nWe can verify that the same trends continue by plotting the result for a frequency of $100\\,$GHz, which is the upper limit for which the ITU Metal material is defined (see the [Sionna RT Documentation](https://nvlabs.github.io/sionna/api/rt.html#radio-materials)).\n\n\n```python\nplot(100e9, \"itu_metal\");\n```\n\n\nIt is also interesting to change the material of the wedge. The preconfigured materials in Sionna RT can be inspected with the following command:\n\n\n```python\nlist(scene.radio_materials.keys())\n```\n\n```python\n['vacuum',\n 'itu_concrete',\n 'itu_brick',\n 'itu_plasterboard',\n 'itu_wood',\n 'itu_glass',\n 'itu_ceiling_board',\n 'itu_chipboard',\n 'itu_plywood',\n 'itu_marble',\n 'itu_floorboard',\n 'itu_metal',\n 'itu_very_dry_ground',\n 'itu_medium_dry_ground',\n 'itu_wet_ground']\n```"
"Lets see what happens when we change the material of the wedge to wood and the frequency back to $1\\,$GHz.\n\n\n```python\nplot(1e9, \"itu_wood\");\n```\n\n\nWe immediately notice that wood is a bad reflector since the strength of the reflected path has dropped by $10\\,$dB compared to the metal. Thanks to the heuristic extension of the diffracted field equations in [2] to non-perfect conductors in [4] (which are implemented in Sionna RT), the total field remains continuous.\n\nYou might now want to try different materials and frequencies for yourself."
"## Coverage Maps with Diffraction\n\nSo far, we have obtained a solid microscopic understanding of the effect of scattering. Let us now turn to the macroscopic effects that can be nicely observed through coverage maps.\n\nA coverage map describes the average received power from a specific transmitter at every point on a plane. The effects of fast fading, i.e., constructive/destructive interference between different paths, are averaged out by summing the squared amplitudes of all paths. As we cannot compute coverage maps with infinitely fine resolution, they are approximated by small rectangular tiles for which average values are computed. For a detailed explanation, have a look at the <a class=\"reference external\" href=\"https://nvlabs.github.io/sionna/api/rt.html#coverage-map\">API\nDocumentation</a>.\n\nLet us now load a slightly more interesting scene containing a couple of rectangular buildings and add a transmitter. Note that we do not need to add any receivers to compute a coverage map.\n\n\n```python\nscene = load_scene(sionna.rt.scene.simple_street_canyon)\n# Set the carrier frequency to 1GHz\nscene.frequency = 1e9\nscene.tx_array = PlanarArray(num_rows=1,\n                             num_cols=1,\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"iso\",\n                             polarization=\"V\")\nscene.rx_array = scene.tx_array\nscene.add(Transmitter(name=\"tx\",\n                      position=[-33,11,32],\n                      orientation=[0,0,0]))\n# Render the scene from one of its cameras\n# The blue dot represents the transmitter\nscene.render('scene-cam-1');\n```\n\n\nComputing a coverage map is as simple as running the following command:\n\n\n```python\ncm = scene.coverage_map(cm_cell_size=[1,1], num_samples=10e6)\n```\n\n\nWe can visualizes the coverage map in the scene as follows:\n\n\n```python\n# Add a camera looking at the scene from the top\nmy_cam = Camera(\"my_cam\", position=[10,0,300], look_at=[0,0,0])\nmy_cam.look_at([0,0,0])\nscene.add(my_cam)\n# Render scene with the new camera and overlay the coverage map\nscene.render(my_cam, coverage_map=cm);\n```\n\n\nFrom the figure above, we can see that many regions behind buildings do not receive any signal. The reason for this is that diffraction is by default deactivated. Let us now generate a new coverage map with diffraction enabled:"
"```python\ncm_diff = scene.coverage_map(cm_cell_size=[1,1], num_samples=10e6, diffraction=True)\nscene.render(my_cam, coverage_map=cm_diff);\n```\n\n\nAs expected from our experiements above, there is not a single point in the scene that is left blank. In some areas, however, the signal is still very weak and will not enable any form of communication.\n\nLets do the same experiments at a higher carrier frequency (30 GHz):\n\n\n```python\nscene = load_scene(sionna.rt.scene.simple_street_canyon)\nscene.frequency = 30e9\nscene.tx_array = PlanarArray(num_rows=1,\n                             num_cols=1,\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"iso\",\n                             polarization=\"V\")\nscene.rx_array = scene.tx_array\nscene.add(Transmitter(name=\"tx\",\n                      position=[-33,11,32],\n                      orientation=[0,0,0]))\nscene.add(my_cam)\ncm = scene.coverage_map(cm_cell_size=[1,1], num_samples=10e6)\ncm_diff = scene.coverage_map(cm_cell_size=[1,1], num_samples=10e6, diffraction=True)\nscene.render(my_cam, coverage_map=cm);\nscene.render(my_cam, coverage_map=cm_diff);\n```\n\n\nWhile the 1 GHz and 30 GHz carrier frequency coverage maps appear similar, key differences exist. The dynamic range for 30 GHz has grown by around 16dB due to the reduced diffracted field in deep shadow areas, such as behind buildings. The diffracted field at this frequency is considerably smaller compared to the incident field than it is at 1 GHz, leading to a significant increase in dynamic range.\n\nIn conclusion, diffraction plays a vital role in maintaining the consistency of the electric field across both reflection and incident shadow boundaries. It generates diffracted rays that form a Keller cone around an edge. As we move away from these boundaries, the diffracted field diminishes rapidly. Importantly, the contributions of the diffracted field become less significant as the carrier frequency increases.\n\nWe hope you enjoyed our dive into diffraction with this Sionna RT tutorial. We really encourage you to get hands-on, conduct your own experiments and deepen your understanding of ray tracing. Theres always more to learn, so do explore our other [tutorials](https://nvlabs.github.io/sionna/tutorials.html) as well."
"## References\n\n[1] J.B. Keller, [Geometrical Theory of Diffraction](https://opg.optica.org/josa/abstract.cfm?uri=josa-52-2-116), Journal of the Optical Society of America, vol.52, no. 2, Feb.1962.\n\n[2] R.G. Kouyoumjian, [A uniform geometrical theory of diffraction for an edge in a perfectly conducting surface](https://ieeexplore.ieee.org/abstract/document/1451581/authors#authors), Proc. of the IEEE, vol.62, no. 11, Nov.1974.\n\n[3] D.A. McNamara, C.W.I. Pistorius, J.A.G. Malherbe, [Introduction to the Uniform Geometrical Theory of Diffraction](https://us.artechhouse.com/Introduction-to-the-Uniform-Geometrical-Theory-of-Diffraction-P288.aspx), Artech House, 1990.\n\n[4] R. Luebbers, [Finite conductivity uniform GTD versus knife edge diffraction in prediction of propagation path loss](https://ieeexplore.ieee.org/abstract/document/1143189), IEEE Trans. Antennas and Propagation, vol.32, no. 1, Jan.1984.[4] R. Luebbers, [Finite conductivity uniform GTD versus knife edge diffraction in prediction of propagation path loss](https://ieeexplore.ieee.org/abstract/document/1143189), IEEE Trans. Antennas and Propagation, vol.32, no. 1, Jan.1984.[4] R. Luebbers, [Finite conductivity uniform GTD versus knife edge diffraction in prediction of propagation path loss](https://ieeexplore.ieee.org/abstract/document/1143189), IEEE Trans. Antennas and Propagation, vol.32, no. 1, Jan.1984.[4] R. Luebbers, [Finite conductivity uniform GTD versus knife edge diffraction in prediction of propagation path loss](https://ieeexplore.ieee.org/abstract/document/1143189), IEEE Trans. Antennas and Propagation, vol.32, no. 1, Jan.1984."

"# Tutorial on Scattering\n\nIn this notebook, you will\n\n- Learn what scattering is and why it is important\n- Make various ray tracing experiments to validate some theoretical results\n- Familiarize yourself with the Sionna RT API\n- Visualize the impact of scattering on channel impulse responses and coverage maps"
"## GPU Configuration and Imports\n\n\n```python\nimport os # Configure which GPU\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Colab does currently not support the latest version of ipython.\n# Thus, the preview does not work in Colab. However, whenever possible we\n# strongly recommend to use the scene preview mode.\ntry: # detect if the notebook runs in Colab\n    import google.colab\n    colab_compat = True # deactivate preview\nexcept:\n    colab_compat = False\nresolution = [480,320] # increase for higher quality of renderings\n# Allows to exit cell execution in Jupyter\nclass ExitCell(Exception):\n    def _render_traceback_(self):\n        pass\n# Import Sionna\ntry:\n    import sionna\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna\n# Configure the notebook to use only a single GPU and allocate only as much memory as needed\n# For more details, see https://www.tensorflow.org/guide/gpu\nimport tensorflow as tf\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\ntf.random.set_seed(1) # Set global random seed for reproducibility\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sys\nfrom sionna.channel import cir_to_time_channel\nfrom sionna.rt import load_scene, PlanarArray, Transmitter, Receiver, RadioMaterial, Camera, LambertianPattern, DirectivePattern, BackscatteringPattern\nfrom sionna.rt.utils import r_hat\nfrom sionna.constants import PI, SPEED_OF_LIGHT\nfrom sionna.utils import expand_to_rank\n```"
"## Scattering Basics\n\n\nWhen an electromagnetic wave impinges on a surface, one part of the energy gets reflected while the other part gets refracted, i.e., it propagates into the surface. We distinguish between two types of reflection, specular and diffuse. The latter type is also called diffuse scattering. When a rays hits a diffuse reflection surface, it is not reflected into a single (specular) direction but rather scattered toward many different directions.\n\nOne way to think about scattering is that every infinitesimally small surface element $dA$ (as shown in the figure above) reradiates a part of the energy impinging on it. It essentially behaves like a point source that radiates electromagnetic waves into the hemisphere defined by the surface normal [1]. Similar to the far-field of an antenna which is determined by the antenna pattern, the scattered field is determined by the scattering pattern of the surface element, denoted\n$f_\\text{s}(\\hat{\\mathbf{k}}_\\text{i}, \\hat{\\mathbf{k}}_\\text{s})$, where $\\hat{\\mathbf{k}}_\\text{i}$ and $\\hat{\\mathbf{k}}_\\text{s}$ are the incomning and scattered directions, respectively. In other words, the scattered field can be stronger in certain directions than others.\n\nThe most important difference between diffuse and specular reflections for ray tracing is that an incoming ray essentially spawns infinitely many scattered rays while there is only a single specular path. In order to computed the scattered field at a particular position, one needs to integrate the scattered field over the entire surface.\n\nLet us have a look at some common scattering patterns that are implemented in Sionna:\n\n\n```python\nLambertianPattern().visualize();\n```\n\n\n```python\nDirectivePattern(alpha_r=10).visualize(); # The stronger alpha_r, the more the pattern\n                                          # is concentrated around the specular direction.\n```\n\n\nIn order to develop a feeling for the difference between specular and diffuse reflections, let us load a very simple scene with a single quadratic reflector and place a transmitter and receiver.\n\n\n```python\nscene = load_scene(sionna.rt.scene.simple_reflector)\n# Configure the transmitter and receiver arrays\nscene.tx_array = PlanarArray(num_rows=1,\n                             num_cols=1,\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"iso\",\n                             polarization=\"V\")\nscene.rx_array = scene.tx_array\n# Add a transmitter and receiver with equal distance from the center of the surface\n# at an angle of 45 degrees.\ndist = 5\nd = dist/np.sqrt(2)\nscene.add(Transmitter(name=\"tx\", position=[-d,0,d]))\nscene.add(Receiver(name=\"rx\", position=[d,0,d]))\n# Add a camera for visualization\nscene.add(Camera(\"my_cam\", position=[0, -30, 20], look_at=[0,0,3]))\n# Open 3D preview (only works in Jupyter notebook)\nif colab_compat:\n    scene.render(\"my_cam\");\n    raise ExitCell\nscene.preview()\n```"
"Next, let us compute the specularly reflected path:\n\n\n```python\npaths = scene.compute_paths(los=False, reflection=True)\n# Open 3D preview (only works in Jupyter notebook)\nif colab_compat:\n    scene.render(\"my_cam\", paths=paths);\n    raise ExitCell\nscene.preview(paths=paths)\n```\n\n\nAs expected from geometrical optics (GO), the specular path goes through the center of the reflector and has indentical incomning and outgoing angles with the surface normal.\n\nWe can compute the scattered paths in a similar way:\n\n\n```python\npaths = scene.compute_paths(los=False, reflection=False, scattering=True, scat_keep_prob=1.0)\n# Open 3D preview (only works in Jupyter notebook)\nif colab_compat:\n    scene.render(\"my_cam\", paths=paths);\n    raise ExitCell\nscene.preview(paths=paths)\n```\n\n\n```python\nprint(f\"There are {tf.size(paths.a).numpy()} scattered paths\")\n```\n\n\n```python\nThere are 2247 scattered paths\n```\n\n\nWe can see that there is a very large number paths. Actually, any ray that hits the surface will be scattered toward the receiver. Thus, the more rays we shoot, the more scattered paths there are. You can see this through the following experiment:\n\n\n```python\npaths = scene.compute_paths(num_samples=2e6, los=False, reflection=False, scattering=True, scat_keep_prob=1.0)\nprint(f\"There are {tf.size(paths.a).numpy()} scattered paths.\")\npaths = scene.compute_paths(num_samples=10e6, los=False, reflection=False, scattering=True, scat_keep_prob=1.0)\nprint(f\"There are {tf.size(paths.a).numpy()} scattered paths.\")\n```\n\n\n```python\nThere are 4400 scattered paths.\nThere are 22572 scattered paths.\n```\n\n\nThe number of rays hitting the surface is proportional to the total number of rays shot and the squared distance between the transmitter and the surface. However, the total received energy across the surface is constant as the transmitted energy is equally divided between all rays.\n\nIf you closely inspect the code in the above cells, you might have noticed the keyword argument `scat_keep_prob`. This determines the fraction of scattered paths that will be randomly dropped in the ray tracing process. The importance of the remaining paths is increased proportionally. Setting this argument to small values prevents obtaining channel impulse responses with an excessive number of scattered paths."
"```python\npaths = scene.compute_paths(num_samples=10e6, los=False, reflection=False, scattering=True, scat_keep_prob=0.001)\nprint(f\"There are {tf.size(paths.a).numpy()} scattered paths.\")\n```\n\n\n```python\nThere are 16 scattered paths.\n```\n\n\nIn our example scene, each ray hitting the surfaces spawns exactly one new ray which connects to the receiver. Each ray has a random phase and energy that is determined by the scattering pattern and the so-called scattering coefficient $S\\in[0,1]$. The squared scattering coefficient $S^2$ determines which portion of the totally reflected energy (specular and diffuse combined) is diffusely reflected. For details on the precise modeling of the scattered field, we refer to the <a class=\"reference external\" href=\"https://nvlabs.github.io/sionna/em_primer.html#scattering\">EM\nPrimer</a>.\n\nBy default, all materials in Sionna have a scattering coefficient equal to zero. For this reason, we would expect that all of the scattered paths carry zero energy. Lets verify that this is indeed the case:\n\n\n```python\nprint(\"All scattered paths have zero energy:\", np.all(np.abs(paths.a)==0))\n```\n\n\n```python\nAll scattered paths have zero energy: True\n```\n\n\nLet us change the scattering coefficient of the radio material used by the reflector and run the path computations again:\n\n\n```python\nscene.get(\"reflector\").radio_material.scattering_coefficient = 0.5\npaths = scene.compute_paths(num_samples=1e6, los=False, reflection=False, scattering=True)\nprint(\"All scattered paths have positive energy:\", np.all(np.abs(paths.a)>0))\n```\n\n\n```python\nAll scattered paths have positive energy: True\n```"
"## Scattering Patterns\n\nIn order to study the impact of the scattering pattern, lets replace the perfectly diffuse Lambertian pattern (which all radio materials have by default) by the [DirectivePattern](https://nvlabs.github.io/sionna/api/rt.html#sionna.rt.DirectivePattern). The larger the integer parameter $\\alpha_r$, the more the scattered field is focused around the direction of the specular reflection.\n\n\n```python\nscattering_pattern = DirectivePattern(1)\nscene.get(\"reflector\").radio_material.scattering_pattern = scattering_pattern\nalpha_rs = np.array([1,2,3,5,10,30,50,100], np.int32)\nreceived_powers = np.zeros_like(alpha_rs, np.float32)\nfor i, alpha_r in enumerate(alpha_rs):\n    scattering_pattern.alpha_r = alpha_r\n    paths = scene.compute_paths(num_samples=1e6, los=False, reflection=False, scattering=True, scat_keep_prob=1.0)\n    received_powers[i] = 10*np.log10(tf.reduce_sum(tf.abs(paths.a)**2))\nplt.figure()\nplt.plot(alpha_rs, received_powers)\nplt.xlabel(r\"$\\alpha_r$\")\nplt.ylabel(\"Received power (dB)\");\nplt.title(\"Impact of the Directivity of the Scattering Pattern\");\n```\n\n\nWe can indeed observe that the received energy increases with $\\alpha_r$. This is because the scattered paths are almost parallel to the specular path directions in this scene. If we move the receiver away from the specular direction, this effect should be reversed.\n\n\n```python\n# Move the receiver closer to the surface, i.e., away from the specular angle theta=45deg\nscene.get(\"rx\").position = [d, 0, 1]\nreceived_powers = np.zeros_like(alpha_rs, np.float32)\nfor i, alpha_r in enumerate(alpha_rs):\n    scattering_pattern.alpha_r = alpha_r\n    paths = scene.compute_paths(num_samples=1e6, los=False, reflection=False, scattering=True, scat_keep_prob=1.0)\n    received_powers[i] = 10*np.log10(tf.reduce_sum(tf.abs(paths.a)**2))\nplt.figure()\nplt.plot(alpha_rs, received_powers)\nplt.xlabel(r\"$\\alpha_r$\")\nplt.ylabel(\"Received power (dB)\");\nplt.title(\"Impact of the Directivity of the Scattering Pattern\");\n```"
"## Validation Against the Far-Wall Approximation\n\nIf the scattering surface is small compared to the distance from its center to the transmitter and receiver, respectively, it can be approximated by a single scattering source that reradiates parts of the energy it has captured by the entire surface $A$. In other words, the scattered field is well approximated by a single ray originating from the barycenter of the surface [2]. The reason for this behavior is that the scattering angle is almost constant for any point on the surface. As\ndescribed in the [EM Primer](https://nvlabs.github.io/sionna/em_primer.html#scattering), the received power of the scattered path can be computed as\n\n$$\nP_r = \\left(\\frac{\\lambda S \\Gamma}{4\\pi r_i r_s}\\right)^2 f_\\text{s}(\\hat{\\mathbf{k}}_\\text{i}, \\hat{\\mathbf{k}}_\\text{s}) \\cos(\\theta_i) A\n$$\n\nwhich simplifies for a perfect reflector ($\\Gamma=1$) with Lambertian scattering pattern and unit surface area to\n\n$$\nP_r = \\left(\\frac{\\lambda S}{4\\pi r_i r_s}\\right)^2 \\frac{\\cos(\\theta_i)\\cos(\\theta_s)}{\\pi}\n$$\n\nwhere $r_i$ and $r_s$ are the distances between the surface center and the transmitter and receiver, respectively.\n\nWe have constructed our scene such that $r_i=r_s$ and $\\theta_i=\\theta_s=\\pi/4$, so that $\\cos(\\theta_i)=1/\\sqrt{2}$. Thus,\n\n$$\nP_r = \\left(\\frac{\\lambda S}{4\\pi r_i^2 }\\right)^2 \\frac{1}{2\\pi}\n$$\n\nLets validate for which distances $r_i$ this approximation holds.\n\n\n```python\ns = 0.7 # Scattering coefficient\n# Configure the radio material\nscene.get(\"reflector\").radio_material.scattering_pattern = LambertianPattern()\nscene.get(\"reflector\").radio_material.scattering_coefficient = s\n# Set the carrier frequency\nscene.frequency = 3.5e9\nwavelength = scene.wavelength\nr_is = np.array([0.1, 1, 2, 5, 10], np.float32) # Varying distances\nreceived_powers = np.zeros_like(r_is, np.float32)\ntheo_powers = np.zeros_like(received_powers)\nfor i, r_i in enumerate(r_is):\n    # Update the positions of TX and RX\n    d = r_i/np.sqrt(2)\n    scene.get(\"tx\").position = [-d, 0, d]\n    scene.get(\"rx\").position = [d, 0, d]\n    paths = scene.compute_paths(num_samples=1e6, los=False, reflection=False, scattering=True, scat_keep_prob=1.0)\n    received_powers[i] = 10*np.log10(tf.reduce_sum(tf.abs(paths.a)**2))\n    # Compute theoretically received power using the far-wall approximation\n    theo_powers[i] = 10*np.log10((wavelength*s/(4*np.pi*r_i**2))**2/(2*np.pi))\nplt.figure()\nplt.plot(r_is, received_powers)\nplt.plot(r_is, theo_powers, \"--\")\nplt.title(\"Validation of the Scattered Field Power\")\nplt.xlabel(r\"$r_i$ (m)\")\nplt.ylabel(\"Received power (dB)\");\nplt.legend([\"Ray tracing\", \"\\\"Far\\\"-wall approximation\"]);\n```"
"We can observe an almost perfect match between the results for ray-tracing and the far-wall approximation from a distance of $2\\,$m on. For smaller distances, there is a significant (but expected) difference. In general, none of both approaches is valid for very short propagation distances."
"## Coverage Maps With Scattering\n\nBy now, you have a gained a solid understanding of scattering from a single surface. Let us now make things a bit more interesting by looking at a complex scene with many scattering surfaces. This can be nicely observed with the help of coverage maps.\n\nA coverage map describes the average received power from a specific transmitter at every point on a plane. The effects of fast fading, i.e., constructive/destructive interference between different paths, are averaged out by summing the squared amplitudes of all paths. As we cannot compute coverage maps with infinitely fine resolution, they are approximated by small rectangular tiles for which average values are computed. For a detailed explanation, have a look at the <a class=\"reference external\" href=\"https://nvlabs.github.io/sionna/api/rt.html#coverage-map\">API\nDocumentation</a>.\n\nLet us now load a slightly more interesting scene containing a couple of rectangular buildings and add a transmitter. Note that we do not need to add any receivers to compute a coverage map (we will add one though as we need it later).\n\n\n```python\nscene = load_scene(sionna.rt.scene.simple_street_canyon)\nscene.frequency = 30e9\nscene.tx_array = PlanarArray(num_rows=1,\n                             num_cols=1,\n                             vertical_spacing=0.5,\n                             horizontal_spacing=0.5,\n                             pattern=\"iso\",\n                             polarization=\"V\")\nscene.rx_array = scene.tx_array\nscene.add(Transmitter(name=\"tx\",\n                      position=[-33,11,32],\n                      orientation=[0,0,0]))\n# We add a receiver for later path computations\nscene.add(Receiver(name=\"rx\",\n                      position=[27,-13,1.5],\n                      orientation=[0,0,0]))\nmy_cam = Camera(\"my_cam\", position=[10,0,300], look_at=[0,0,0])\nmy_cam.look_at([0,0,0])\nscene.add(my_cam)\n```\n\n\nComputing and visualizing a coverage map is as simple as running the following commands:\n\n\n```python\ncm = scene.coverage_map(cm_cell_size=[1,1], num_samples=20e6, max_depth=5)\nscene.render(my_cam, coverage_map=cm, cm_vmin=-200, cm_vmax=-90);\n```\n\n\nBy default, coverage maps are only computed for line-of-sight and specular reflections. The parameter `cm_cell_size` determines the resolution of the coverage map. However, the finer the resolution, the more rays (i.e., `num_samples`) must be shot. We can see from the above figure, that there are various regions which have no coverage as they cannot be reached by purely reflected paths.\n\nLets now enable diffuse reflections and see what happens."
"```python\n# Configure radio materials for scattering\n# By default the scattering coefficient is set to zero\nfor rm in scene.radio_materials.values():\n    rm.scattering_coefficient = 1/np.sqrt(3) # Try different values in [0,1]\n    rm.scattering_pattern = DirectivePattern(alpha_r=10) # Play around with different values of alpha_r\ncm_scat = scene.coverage_map(cm_cell_size=[1,1], num_samples=20e6, max_depth=5, scattering=True)\nscene.render(my_cam, coverage_map=cm_scat, cm_vmin=-200, cm_vmax=-90);\n```\n\n\nThanks to scattering, most regions in the scene have some coverage. However, the scattered field is weak compared to that of the LoS and reflected paths. Also note that the peak signal strength has slightly decreased. This is because the scattering coefficient takes away some of the specularly reflected energy."
"## Impact on Channel Impulse Response\n\nAs a last experiment in our tutorial on scattering, let us have a look at the discrete baseband-equivalent channel impulse responses we obtain with and without scattering. To this end, we will compute the channel impulse response of the single receiver we have configured for the current scene, and then transform it into the complex baseband representation using the convenience function [cir_to_time_channel](https://nvlabs.github.io/sionna/api/channel.wireless.html#cir-to-time-channel).\n\n\n```python\n# Change the scattering coefficient of all radio materials\nfor rm in scene.radio_materials.values():\n    rm.scattering_coefficient = 1/np.sqrt(3)\nbandwidth=200e6 # bandwidth of the receiver (= sampling frequency)\nplt.figure()\ntf.random.set_seed(20)\npaths = scene.compute_paths(max_depth=5,\n                            num_samples=20e6,\n                            scattering=True)\n# Compute time channel without scattering\nh = np.squeeze(cir_to_time_channel(bandwidth, *paths.cir(scattering=False), 0, 100, normalize=True))\ntau = np.arange(h.shape[0])/bandwidth*1e9\nplt.plot(tau, 20*np.log10(np.abs(h)));\n# Compute time channel with scattering\nh = np.squeeze(cir_to_time_channel(bandwidth, *paths.cir(), 0, 100, normalize=True))\nplt.plot(tau, 20*np.log10(np.abs(h)), \"--\");\nplt.xlabel(r\"Delay $\\tau$ (ns)\")\nplt.ylabel(r\"$|h|^2$ (dB)\");\nplt.title(\"Comparison of Channel Impulse Responses\")\nplt.legend([\"No Scattering\", \"With Scattering\"]);\n```\n\n\nThe discrete channel impulse response looks similar for small values of $\\tau$, where the field is dominated by strong LOS and reflected paths. However, in the middle and tail, there are differences of a few dB which can have a significant impact on the link-level performance."
"## Summary\n\nIn conclusion, scattering plays an important role for radio propagation modelling. In particular, the higher the carrier frequency, the rougher most surfaces appear compared to the wavelength. Thus, at THz-frequencies diffuse reflections might become the dominating form of radio wave propgation (apart from LoS).\n\nWe hope you enjoyed our dive into scattering with this Sionna RT tutorial. Please try out some experiments yourself and improve your grasp of ray tracing. Theres more to discover, so so dont forget to check out our other [tutorials](https://nvlabs.github.io/sionna/tutorials.html), too."
"## References\n\n[1] Vittorio Degli-Esposti et al., [Measurement and modelling of scattering from buildings](https://ieeexplore.ieee.org/abstract/document/4052607), IEEE Trans. Antennas Propag., vol.55, no. 1, pp.143-153, Jan.2007.\n\n[2] Vittorio Degli-Esposti et al., [An advanced field prediction model including diffuse scattering](https://ieeexplore.ieee.org/abstract/document/1310631), IEEE Trans. Antennas Propag., vol.52, no. 7, pp.1717-1728, Jul.2004.[2] Vittorio Degli-Esposti et al., [An advanced field prediction model including diffuse scattering](https://ieeexplore.ieee.org/abstract/document/1310631), IEEE Trans. Antennas Propag., vol.52, no. 7, pp.1717-1728, Jul.2004.[2] Vittorio Degli-Esposti et al., [An advanced field prediction model including diffuse scattering](https://ieeexplore.ieee.org/abstract/document/1310631), IEEE Trans. Antennas Propag., vol.52, no. 7, pp.1717-1728, Jul.2004.[2] Vittorio Degli-Esposti et al., [An advanced field prediction model including diffuse scattering](https://ieeexplore.ieee.org/abstract/document/1310631), IEEE Trans. Antennas Propag., vol.52, no. 7, pp.1717-1728, Jul.2004."

"# Cyclic Redundancy Check (CRC)\n\nA cyclic redundancy check adds parity bits to detect transmission errors.\nThe following code snippets show how to add CRC parity bits to a bit sequence\nand how to verify that the check is valid.\n\nFirst, we need to create instances of [`CRCEncoder`](https://nvlabs.github.io/sionna/api/fec.crc.html#sionna.fec.crc.CRCEncoder) and [`CRCDecoder`](https://nvlabs.github.io/sionna/api/fec.crc.html#sionna.fec.crc.CRCDecoder):\n```python\nencoder = CRCEncoder(crc_degree=\"CRC24A\") # the crc_degree denotes the number of added parity bits and is taken from the 3GPP 5G NR standard.\ndecoder = CRCDecoder(crc_encoder=encoder) # the decoder must be associated to a specific encoder\n```\n\n\nWe can now run the CRC encoder and test if the CRC holds:\n```python\n# u contains the information bits to be encoded and has shape [...,k].\n# c contains u and the CRC parity bits. It has shape [...,k+k_crc].\nc = encoder(u)\n# u_hat contains the information bits without parity bits and has shape [...,k].\n# crc_valid contains a boolean per codeword that indicates if the CRC validation was successful.\n# It has shape [...,1].\nu_hat, crc_valid = decoder(c)\n```"
"## CRCEncoder\n\n`class` `sionna.fec.crc.``CRCEncoder`(*`crc_degree`*, *`output_dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/crc.html#CRCEncoder)\n\nAdds cyclic redundancy check to input sequence.\n\nThe CRC polynomials from Sec. 5.1 in [[3GPPTS38212_CRC]](https://nvlabs.github.io/sionna/api/fec.crc.html#gppts38212-crc) are available:\n<cite>{CRC24A, CRC24B, CRC24C, CRC16, CRC11, CRC6}</cite>.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **crc_degree** (*str*)  Defining the CRC polynomial to be used. Can be any value from\n<cite>{CRC24A, CRC24B, CRC24C, CRC16, CRC11, CRC6}</cite>.\n- **dtype** (*tf.DType*)  Defaults to <cite>tf.float32</cite>. Defines the output dtype.\n\n\nInput\n\n**inputs** (*[,k], tf.float32*)  2+D tensor of arbitrary shape where the last dimension is\n<cite>[,k]</cite>. Must have at least rank two.\n\nOutput\n\n**x_crc** (*[,k+crc_degree], tf.float32*)  2+D tensor containing CRC encoded bits of same shape as\n`inputs` except the last dimension changes to\n<cite>[,k+crc_degree]</cite>.\n\nRaises\n\n- **AssertionError**  If `crc_degree` is not <cite>str</cite>.\n- **ValueError**  If requested CRC polynomial is not available in [[3GPPTS38212_CRC]](https://nvlabs.github.io/sionna/api/fec.crc.html#gppts38212-crc).\n- **InvalidArgumentError**  When rank(`inputs`)<2.\n\n\n**Note**\n\nFor performance enhancements, we implement a generator-matrix based\nimplementation for fixed <cite>k</cite> instead of the more common shift\nregister-based operations. Thus, the encoder need to trigger an\n(internal) rebuild if <cite>k</cite> changes.\n\n`property` `crc_degree`\n\nCRC degree as string.\n\n\n`property` `crc_length`\n\nLength of CRC. Equals number of CRC parity bits.\n\n\n`property` `crc_pol`\n\nCRC polynomial in binary representation.\n\n\n`property` `k`\n\nNumber of information bits per codeword.\n\n\n`property` `n`\n\nNumber of codeword bits."
"## CRCDecoder\n\n`class` `sionna.fec.crc.``CRCDecoder`(*`crc_encoder`*, *`dtype``=``None`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/crc.html#CRCDecoder)\n\nAllows cyclic redundancy check verification and removes parity-bits.\n\nThe CRC polynomials from Sec. 5.1 in [[3GPPTS38212_CRC]](https://nvlabs.github.io/sionna/api/fec.crc.html#gppts38212-crc) are available:\n<cite>{CRC24A, CRC24B, CRC24C, CRC16, CRC11, CRC6}</cite>.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **crc_encoder** ()  An instance of [`CRCEncoder`](https://nvlabs.github.io/sionna/api/fec.crc.html#sionna.fec.crc.CRCEncoder) to which the\nCRCDecoder is associated.\n- **dtype** (*tf.DType*)  Defaults to <cite>None</cite>. Defines the datatype for internal calculations\nand the output dtype. If no explicit dtype is provided the dtype\nfrom the associated interleaver is used.\n\n\nInput\n\n**inputs** (*[,k+crc_degree], tf.float32*)  2+D Tensor containing the CRC encoded bits (i.e., the last\n<cite>crc_degree</cite> bits are parity bits). Must have at least rank two.\n\nOutput\n\n- **(x, crc_valid)**  Tuple:\n- **x** (*[,k], tf.float32*)  2+D tensor containing the information bit sequence without CRC\nparity bits.\n- **crc_valid** (*[,1], tf.bool*)  2+D tensor containing the result of the CRC per codeword.\n\n\nRaises\n\n- **AssertionError**  If `crc_encoder` is not <cite>CRCEncoder</cite>.\n- **InvalidArgumentError**  When rank(`x`)<2.\n\n\n`property` `crc_degree`\n\nCRC degree as string.\n\n\n`property` `encoder`\n\nCRC Encoder used for internal validation.\n\n\nReferences:\n3GPPTS38212_CRC([1](https://nvlabs.github.io/sionna/api/fec.crc.html#id1),[2](https://nvlabs.github.io/sionna/api/fec.crc.html#id2),[3](https://nvlabs.github.io/sionna/api/fec.crc.html#id3))\n\nETSI 3GPP TS 38.212 5G NR Multiplexing and channel\ncoding, v.16.5.0, 2021-03."

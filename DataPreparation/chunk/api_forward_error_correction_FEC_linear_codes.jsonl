"# Linear Codes\n\nThis package provides generic support for binary linear block codes.\n\nFor encoding, a universal [`LinearEncoder`](https://nvlabs.github.io/sionna/api/fec.linear.html#sionna.fec.linear.LinearEncoder) is available and can be initialized with either a generator or parity-check matrix. The matrix must be binary and of full rank.\n\nFor decoding, [`OSDecoder`](https://nvlabs.github.io/sionna/api/fec.linear.html#sionna.fec.linear.OSDecoder) implements the\nordered-statistics decoding (OSD) algorithm [[Fossorier]](https://nvlabs.github.io/sionna/api/fec.linear.html#fossorier) which provides close to\nmaximum-likelihood (ML) estimates for a sufficiently large order of the decoder.\nPlease note that OSD is highly complex and not feasible for all code lengths.\n\n*Remark:* As this package provides support for generic encoding and decoding\n(including Polar and LDPC codes), it cannot rely on code specific\noptimizations. To benefit from an optimized decoder and keep the complexity as low as possible, please use the code specific enc-/decoders whenever available.\n\nThe encoder and decoder can be set up as follows:\n```python\npcm, k, n, coderate = load_parity_check_examples(pcm_id=1) # load example code\n# or directly import an external parity-check matrix in alist format\nal = load_alist(path=filename)\npcm, k, n, coderate = alist2mat(al)\n# encoder can be directly initialized with the parity-check matrix\nencoder = LinearEncoder(enc_mat=pcm, is_pcm=True)\n# decoder can be initialized with generator or parity-check matrix\ndecoder = OSDecoder(pcm, t=4, is_pcm=True) # t is the OSD order\n# or instantiated from a specific encoder\ndecoder = OSDecoder(encoder=encoder, t=4) # t is the OSD order\n```\n\n\nWe can now run the encoder and decoder:\n```python\n# u contains the information bits to be encoded and has shape [...,k].\n# c contains codeword bits and has shape [...,n]\nc = encoder(u)\n# after transmission LLRs must be calculated with a demapper\n# let's assume the resulting llr_ch has shape [...,n]\nc_hat = decoder(llr_ch)\n```"
"### LinearEncoder\n\n`class` `sionna.fec.linear.``LinearEncoder`(*`enc_mat`*, *`is_pcm``=``False`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/linear/encoding.html#LinearEncoder)\n\nLinear binary encoder for a given generator or parity-check matrix `enc_mat`.\n\nIf `is_pcm` is True, `enc_mat` is interpreted as parity-check\nmatrix and internally converted to a corresponding generator matrix.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **enc_mat** (*[**k**, **n**] or **[**n-k**, **n**]**, **ndarray*)  Binary generator matrix of shape <cite>[k, n]</cite>. If `is_pcm` is\nTrue, `enc_mat` is interpreted as parity-check matrix of shape\n<cite>[n-k, n]</cite>.\n- **dtype** (*tf.DType*)  Defaults to <cite>tf.float32</cite>. Defines the datatype for the output dtype.\n\n\nInput\n\n**inputs** (*[,k], tf.float32*)  2+D tensor containing information bits.\n\nOutput\n\n*[,n], tf.float32*  2+D tensor containing codewords with same shape as inputs, except the\nlast dimension changes to <cite>[,n]</cite>.\n\nRaises\n\n**AssertionError**  If the encoding matrix is not a valid binary 2-D matrix.\n\n\n**Note**\n\nIf `is_pcm` is True, this layer uses\n[`pcm2gm`](fec.utils.html#sionna.fec.utils.pcm2gm) to find the generator matrix for\nencoding. Please note that this imposes a few constraints on the\nprovided parity-check matrix such as full rank and it must be binary.\n\nNote that this encoder is generic for all binary linear block codes\nand, thus, cannot implement any code specific optimizations. As a\nresult, the encoding complexity is $O(k^2)$. Please consider code\nspecific encoders such as the\n[`Polar5GEncoder`](fec.polar.html#sionna.fec.polar.encoding.Polar5GEncoder) or\n[`LDPC5GEncoder`](fec.ldpc.html#sionna.fec.ldpc.encoding.LDPC5GEncoder) for an improved\nencoding performance.\n\n`property` `coderate`\n\nCoderate of the code.\n\n\n`property` `gm`\n\nGenerator matrix used for encoding.\n\n\n`property` `k`\n\nNumber of information bits per codeword.\n\n\n`property` `n`\n\nCodeword length."
"### AllZeroEncoder\n\n`class` `sionna.fec.linear.``AllZeroEncoder`(*`k`*, *`n`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/linear/encoding.html#AllZeroEncoder)\n\nDummy encoder that always outputs the all-zero codeword of length `n`.\n\nNote that this encoder is a dummy encoder and does NOT perform real\nencoding!\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **k** (*int*)  Defining the number of information bit per codeword.\n- **n** (*int*)  Defining the desired codeword length.\n- **dtype** (*tf.DType*)  Defaults to <cite>tf.float32</cite>. Defines the datatype for internal\ncalculations and the output dtype.\n\n\nInput\n\n**inputs** (*[,k], tf.float32*)  2+D tensor containing arbitrary values (not used!).\n\nOutput\n\n*[,n], tf.float32*  2+D tensor containing all-zero codewords.\n\nRaises\n\n**AssertionError**  `k` and `n` must be positive integers and `k` must be smaller\n    (or equal) than `n`.\n\n\n**Note**\n\nAs the all-zero codeword is part of any linear code, it is often used\nto simulate BER curves of arbitrary (LDPC) codes without the need of\nhaving access to the actual generator matrix. However, this <cite>all-zero\ncodeword trick</cite> requires symmetric channels (such as BPSK), otherwise\nscrambling is required (cf. [[Pfister]](fec.ldpc.html#pfister) for further details).\n\nThis encoder is a dummy encoder that is needed for some all-zero\ncodeword simulations independent of the input. It does NOT perform\nreal encoding although the information bits are taken as input.\nThis is just to ensure compatibility with other encoding layers.\n\n`property` `coderate`\n\nCoderate of the LDPC code.\n\n\n`property` `k`\n\nNumber of information bits per codeword.\n\n\n`property` `n`\n\nCodeword length."
"### OSDecoder\n\n`class` `sionna.fec.linear.``OSDecoder`(*`enc_mat``=``None`*, *`t``=``0`*, *`is_pcm``=``False`*, *`encoder``=``None`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/linear/decoding.html#OSDecoder)\n\nOrdered statistics decoding (OSD) for binary, linear block codes.\n\nThis layer implements the OSD algorithm as proposed in [[Fossorier]](https://nvlabs.github.io/sionna/api/fec.linear.html#fossorier) and,\nthereby, approximates maximum likelihood decoding for a sufficiently large\norder $t$. The algorithm works for arbitrary linear block codes, but\nhas a high computational complexity for long codes.\n\nThe algorithm consists of the following steps:\n<blockquote>\n<div>\n1. Sort LLRs according to their reliability and apply the same column\npermutation to the generator matrix.\n\n2. Bring the permuted generator matrix into its systematic form\n(so-called *most-reliable basis*).\n\n3. Hard-decide and re-encode the $k$ most reliable bits and\ndiscard the remaining $n-k$ received positions.\n\n4. Generate all possible error patterns up to $t$ errors in the\n$k$ most reliable positions find the most likely codeword within\nthese candidates.\n</blockquote>\n\nThis implementation of the OSD algorithm uses the LLR-based distance metric\nfrom [[Stimming_LLR_OSD]](https://nvlabs.github.io/sionna/api/fec.linear.html#stimming-llr-osd) which simplifies the handling of higher-order\nmodulation schemes.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **enc_mat** (*[**k**, **n**] or **[**n-k**, **n**]**, **ndarray*)  Binary generator matrix of shape <cite>[k, n]</cite>. If `is_pcm` is\nTrue, `enc_mat` is interpreted as parity-check matrix of shape\n<cite>[n-k, n]</cite>.\n- **t** (*int*)  Order of the OSD algorithm\n- **is_pcm** (*bool*)  Defaults to False. If True, `enc_mat` is interpreted as parity-check\nmatrix.\n- **encoder** (*Layer*)  Keras layer that implements a FEC encoder.\nIf not None, `enc_mat` will be ignored and the code as specified by he\nencoder is used to initialize OSD.\n- **dtype** (*tf.DType*)  Defaults to <cite>tf.float32</cite>. Defines the datatype for the output dtype.\n\n\nInput\n\n**llrs_ch** (*[,n], tf.float32*)  2+D tensor containing the channel logits/llr values.\n\nOutput\n\n*[,n], tf.float32*  2+D Tensor of same shape as `llrs_ch` containing\nbinary hard-decisions of all codeword bits.\n\n\n**Note**\n\nOS decoding is of high complexity and is only feasible for small values of\n$t$ as ${n \\choose t}$ patterns must be evaluated. The\nadvantage of OSD is that it works for arbitrary linear block codes and\nprovides an estimate of the expected ML performance for sufficiently large\n$t$. However, for some code families, more efficient decoding\nalgorithms with close to ML performance exist which can exploit certain\ncode specific properties. Examples of such decoders are the\n[`ViterbiDecoder`](fec.conv.html#sionna.fec.conv.ViterbiDecoder) algorithm for  convolutional codes\nor the [`PolarSCLDecoder`](fec.polar.html#sionna.fec.polar.decoding.PolarSCLDecoder) for Polar codes\n(for a sufficiently large list size).\n\nIt is recommended to run the decoder in XLA mode as it\nsignificantly reduces the memory complexity.\n\n`property` `gm`\n\nGenerator matrix of the code\n\n\n`property` `k`\n\nNumber of information bits per codeword\n\n\n`property` `n`\n\nCodeword length\n\n\n`property` `t`\n\nOrder of the OSD algorithm\n\n\nReferences:\nFossorier([1](https://nvlabs.github.io/sionna/api/fec.linear.html#id1),[2](https://nvlabs.github.io/sionna/api/fec.linear.html#id3))\n\nM. Fossorier, S. Lin, Soft-Decision Decoding of Linear\nBlock Codes Based on Ordered Statistics, IEEE Trans. Inf.\nTheory, vol. 41, no.5, 1995.\n\n[Stimming_LLR_OSD](https://nvlabs.github.io/sionna/api/fec.linear.html#id4)\n\nA.Balatsoukas-Stimming, M. Parizi, A. Burg,\nLLR-Based Successive Cancellation List Decoding\nof Polar Codes. IEEE Trans Signal Processing, 2015."

"# Introduction to Iterative Detection and Decoding\n\nIn this notebook, you will learn how to set-up an iterative detection and decoding (IDD) scheme (first presented in [1]) by combining multiple available components in Sionna.\n\nFor a gentle introduction to MIMO simulations, we refer to the notebooks [Simple MIMO Simulations](https://nvlabs.github.io/sionna/examples/Simple_MIMO_Simulation.html) and [MIMO OFDM Transmissions over CDL](https://nvlabs.github.io/sionna/examples/MIMO_OFDM_Transmissions_over_CDL.html).\n\nYou will evaluate the performance of IDD with OFDM MIMO detection and soft-input soft-output (SISO) LDPC decoding and compare it againts several non-iterative detectors, such as soft-output LMMSE, K-Best, and expectation propagation (EP), as well as iterative SISO MMSE-PIC detection [2].\n\nFor the non-IDD models, the signal processing pipeline looks as follows:"
"## Iterative Detection and Decoding\n\nThe IDD MIMO receiver iteratively exchanges soft-information between the data detector and the channel decoder, which works as follows:\n\n\nWe denote by $\\mathrm{L}^{D}$ the *a posteriori* information (represented by log-likelihood ratios, LLRs) and by $\\mathrm{L}^{E} = \\mathrm{L}^{D} - \\mathrm{L}^{A}$ the extrinsic information, which corresponds to the information gain in $\\mathrm{L}^{D}$ relative to the *a priori* information $\\mathrm{L}^{A}$. The *a priori* LLRs represent soft information, provided to either the input of the detector (i.e., $\\mathrm{L}^{A}_{Det}$) or the decoder (i.e.,\n$\\mathrm{L}^{A}_{Dec}$). While exchanging extrinsic information is standard for classical IDD, the SISO MMSE-PIC detector [2] turned out to work better when provided with the full *a posteriori* information from the decoder.\n\nOriginally, IDD was proposed with a resetting (Turbo) decoder [1]. However, state-of-the-art IDD with LDPC message passing decoding showed better performance with a non-resetting decoder [3], particularly for a low number of decoding iterations. Therefore, we will forward the decoder state (i.e., the check node to variable node messages) from each IDD iteration to the next."
"## Table of contents\n\n- [GPU Configuration and Imports](https://nvlabs.github.io/sionna/examples/Introduction_to_Iterative_Detection_and_Decoding.html#GPU-Configuration-and-Imports)\n- [Simulation Parameters](https://nvlabs.github.io/sionna/examples/Introduction_to_Iterative_Detection_and_Decoding.html#Simulation-Parameters)\n- [Setting-up the Keras Models](https://nvlabs.github.io/sionna/examples/Introduction_to_Iterative_Detection_and_Decoding.html#Setting-up-the-Keras-Models)\n- [Non-IDD versus IDD Benchmarks](https://nvlabs.github.io/sionna/examples/Introduction_to_Iterative_Detection_and_Decoding.html#Non-IDD-versus-IDD-Benchmarks)\n- [Discussion-Optimizing IDD with Machine Learning](https://nvlabs.github.io/sionna/examples/Introduction_to_Iterative_Detection_and_Decoding.html#Discussion-Optimizing-IDD-with-Machine-Learning)\n- [Comments](https://nvlabs.github.io/sionna/examples/Introduction_to_Iterative_Detection_and_Decoding.html#Comments)\n- [List of References](https://nvlabs.github.io/sionna/examples/Introduction_to_Iterative_Detection_and_Decoding.html#List-of-References)"
"## GPU Configuration and Imports\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Import Sionna\ntry:\n    import sionna\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sionna.mimo import StreamManagement\nfrom sionna.utils import QAMSource, BinarySource, sim_ber, ebnodb2no, QAMSource, expand_to_rank\nfrom sionna.mapping import Mapper, Constellation\nfrom sionna.ofdm import ResourceGrid, ResourceGridMapper, LSChannelEstimator, LinearDetector, KBestDetector, EPDetector, \\\n    RemoveNulledSubcarriers, MMSEPICDetector\nfrom sionna.channel import GenerateOFDMChannel, OFDMChannel, RayleighBlockFading, gen_single_sector_topology\nfrom sionna.channel.tr38901 import UMa, Antenna, PanelArray\nfrom sionna.fec.ldpc import LDPC5GEncoder\nfrom sionna.fec.ldpc import LDPC5GDecoder\n```\n\n```python\nimport tensorflow as tf\nfrom tensorflow.keras import Model\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\n```"
"## Simulation Parameters\n\nIn the following, we set the simulation parameters. Please modify at will; adapting the batch size to your hardware setup might be beneficial.\n\nThe standard configuration implements a coded 5G inspired MU-MIMO OFDM uplink transmission over 3GPP UMa channels, with 4 single-antenna UEs, 16-QAM modulation, and a 16 element dual-polarized uniform planar antenna array (UPA) at the gNB. We implement least squares channel estimation with linear interpolation. Alternatively, we implement iid Rayleigh fading channels and perfect channel state information (CSI), which can be controlled by the model parameter `perfect_csi_rayleigh`. As channel\ncode, we apply a rate-matched 5G LDPC code at rate 1/2.\n\n\n```python\nSIMPLE_SIM = False   # reduced simulation time for simple simulation if set to True\nif SIMPLE_SIM:\n    batch_size = int(1e1)  # number of OFDM frames to be analyzed per batch\n    num_iter = 5  # number of Monte Carlo Iterations (total number of Monte Carlo trials is num_iter*batch_size)\n    num_steps = 6\n    tf.config.run_functions_eagerly(True)   # run eagerly for better debugging\nelse:\n    batch_size = int(64)  # number of OFDM frames to be analyzed per batch\n    num_iter = 128  # number of Monte Carlo Iterations (total number of Monte Carlo trials is num_iter*batch_size)\n    num_steps = 11\nebno_db_min_perf_csi = -10  # min EbNo value in dB for perfect csi benchmarks\nebno_db_max_perf_csi = 0\nebno_db_min_cest = -10\nebno_db_max_cest = 10\n\nNUM_OFDM_SYMBOLS = 14\nFFT_SIZE = 12*4 # 4 PRBs\nSUBCARRIER_SPACING = 30e3 # Hz\nCARRIER_FREQUENCY = 3.5e9 # Hz\nSPEED = 3. # m/s\nnum_bits_per_symbol = 4 # 16 QAM\nn_ue = 4 # 4 UEs\nNUM_RX_ANT = 16 # 16 BS antennas\nnum_pilot_symbols = 2\n# The user terminals (UTs) are equipped with a single antenna\n# with vertial polarization.\nUT_ANTENNA = Antenna(polarization='single',\n                     polarization_type='V',\n                     antenna_pattern='omni', # Omnidirectional antenna pattern\n                     carrier_frequency=CARRIER_FREQUENCY)\n# The base station is equipped with an antenna\n# array of 8 cross-polarized antennas,\n# resulting in a total of 16 antenna elements.\nBS_ARRAY = PanelArray(num_rows_per_panel=2,\n                      num_cols_per_panel=4,\n                      polarization='dual',\n                      polarization_type='cross',\n                      antenna_pattern='38.901', # 3GPP 38.901 antenna pattern\n                      carrier_frequency=CARRIER_FREQUENCY)\n# 3GPP UMa channel model is considered\nchannel_model_uma = UMa(carrier_frequency=CARRIER_FREQUENCY,\n                    o2i_model='low',\n                    ut_array=UT_ANTENNA,\n                    bs_array=BS_ARRAY,\n                    direction='uplink',\n                    enable_shadow_fading=False,\n                    enable_pathloss=False)\nchannel_model_rayleigh = RayleighBlockFading(num_rx=1, num_rx_ant=NUM_RX_ANT, num_tx=n_ue, num_tx_ant=1)\nconstellation = Constellation(\"qam\", num_bits_per_symbol=num_bits_per_symbol)\nrx_tx_association = np.ones([1, n_ue])\nsm = StreamManagement(rx_tx_association, 1)\n# Parameterize the OFDM channel\nrg = ResourceGrid(num_ofdm_symbols=NUM_OFDM_SYMBOLS, pilot_ofdm_symbol_indices = [2, 11],\n                  fft_size=FFT_SIZE, num_tx=n_ue,\n                  pilot_pattern = \"kronecker\",\n                  subcarrier_spacing=SUBCARRIER_SPACING)\nrg.show()\nplt.show()\n# Parameterize the instruction_answer code\nR = 0.5  # rate 1/2\nN = int(FFT_SIZE * (NUM_OFDM_SYMBOLS - 2) * num_bits_per_symbol)\n# N = int((FFT_SIZE) * (NUM_OFDM_SYMBOLS - 2) * num_bits_per_symbol)\n# code length; - 12 because of 11 guard carriers and 1 DC carrier, - 2 becaues of 2 pilot symbols\nK = int(N * R)  # number of information bits per codeword\n\n```"
"## Setting-up the Keras Models\n\nNow, we define the baseline models for benchmarking. Let us start with the non-IDD models.\n\n\n```python\nclass NonIddModel(Model):\n    def __init__(self, num_bp_iter=12, detector='lmmse', cest_type=\"LS\", interp=\"lin\", perfect_csi_rayleigh=False):\n        super().__init__()\n        self._num_bp_iter = int(num_bp_iter)\n        ######################################\n        ## Transmitter\n        self._binary_source = BinarySource()\n        self._encoder = LDPC5GEncoder(K, N, num_bits_per_symbol=num_bits_per_symbol)\n        self._mapper = Mapper(constellation=constellation)\n        self._rg_mapper = ResourceGridMapper(rg)\n        # Channel\n        if perfect_csi_rayleigh:\n            self._channel_model = channel_model_rayleigh\n        else:\n            self._channel_model = channel_model_uma\n        self._channel = OFDMChannel(channel_model=self._channel_model,\n                                    resource_grid=rg,\n                                    add_awgn=True, normalize_channel=True, return_channel=True)\n        # Receiver\n        self._cest_type = cest_type\n        self._interp = interp\n        # Channel estimation\n        self._perfect_csi_rayleigh = perfect_csi_rayleigh\n        if self._perfect_csi_rayleigh:\n            self._removeNulledSc = RemoveNulledSubcarriers(rg)\n        elif cest_type == \"LS\":\n            self._ls_est = LSChannelEstimator(rg, interpolation_type=interp)\n        else:\n            raise NotImplementedError('Not implemented:' + cest_type)\n        # Detection\n        if detector == \"lmmse\":\n            self._detector = LinearDetector(\"lmmse\", 'bit', \"maxlog\", rg, sm, constellation_type=\"qam\",\n                                            num_bits_per_symbol=num_bits_per_symbol, hard_out=False)\n        elif detector == \"k-best\":\n            k = 64\n            self._detector = KBestDetector('bit', n_ue, k, rg, sm, constellation_type=\"qam\",\n                                           num_bits_per_symbol=num_bits_per_symbol, hard_out=False)\n        elif detector == \"ep\":\n            l = 10\n            self._detector = EPDetector('bit', rg, sm, num_bits_per_symbol, l=l, hard_out=False)\n        # Forward error correction (decoder)\n        self._decoder = LDPC5GDecoder(self._encoder, return_infobits=True, hard_out=True, num_iter=num_bp_iter, cn_type='minsum')\n    def new_topology(self, batch_size):\n        \"\"\"Set new topology\"\"\"\n        if isinstance(self._channel_model, UMa):\n            # sensible values according to 3GPP standard, no mobility by default\n            topology = gen_single_sector_topology(batch_size,\n                                                  n_ue, max_ut_velocity=SPEED,\n                                                  scenario=\"uma\")\n            self._channel_model.set_topology(*topology)\n    @tf.function  # We don't use jit_compile=True to ensure better numerical stability\n    def call(self, batch_size, ebno_db):\n        self.new_topology(batch_size)\n        if len(ebno_db.shape) == 0:\n            ebno_db = tf.fill([batch_size], ebno_db)\n        ######################################\n        ## Transmitter\n        no = ebnodb2no(ebno_db=ebno_db, num_bits_per_symbol=num_bits_per_symbol,\n                       coderate=R)  # normalize in OFDM freq. domain\n        b = self._binary_source([batch_size, n_ue, 1, K])\n        c = self._encoder(b)\n        # Modulation\n        x = self._mapper(c)\n        x_rg = self._rg_mapper(x)\n        ######################################\n        ## Channel\n        # A batch of new channel realizations is sampled and applied at every inference\n        no_ = expand_to_rank(no, tf.rank(x_rg))\n        y, h = self._channel([x_rg, no_])\n        ######################################\n        ## Receiver\n        if self._perfect_csi_rayleigh:\n            h_hat = self._removeNulledSc(h)\n            chan_est_var = tf.zeros(tf.shape(h_hat),\n                                    dtype=tf.float32)  # No channel estimation error when perfect CSI knowledge is assumed\n        else:\n            h_hat, chan_est_var = self._ls_est([y, no])\n        llr_ch = self._detector((y, h_hat, chan_est_var, no))  # detector\n        b_hat = self._decoder((llr_ch))\n        return b, b_hat\n```"
"Next, we implement the IDD model with a non-resetting LDPC decoder, as in [3], i.e., we forward the LLRs and decoder state from one IDD iteration to the following.\n\n\n```python\nclass IddModel(NonIddModel):  # inherited from NonIddModel\n    def __init__(self, num_idd_iter=3, num_bp_iter_per_idd_iter=12, cest_type=\"LS\", interp=\"lin\", perfect_csi_rayleigh=False):\n        super().__init__(num_bp_iter=num_bp_iter_per_idd_iter, detector=\"lmmse\", cest_type=cest_type,\n                         interp=interp, perfect_csi_rayleigh=perfect_csi_rayleigh)\n        # first IDD detector is LMMSE as MMSE-PIC with zero-prior bils down to soft-output LMMSE\n        self._num_idd_iter = num_idd_iter\n        self._siso_detector = MMSEPICDetector(output=\"bit\", resource_grid=rg, stream_management=sm,\n                                              demapping_method='maxlog', constellation=constellation, num_iter=1,\n                                              hard_out=False)\n        self._siso_decoder = LDPC5GDecoder(self._encoder, return_infobits=False,\n                                           num_iter=num_bp_iter_per_idd_iter, stateful=True, hard_out=False, cn_type='minsum')\n        self._decoder = LDPC5GDecoder(self._encoder, return_infobits=True, stateful=True, hard_out=True, num_iter=num_bp_iter_per_idd_iter, cn_type='minsum')\n        # last decoder must also be statefull\n    @tf.function  # We don't use jit_compile=True to ensure better numerical stability\n    def call(self, batch_size, ebno_db):\n        self.new_topology(batch_size)\n        if len(ebno_db.shape) == 0:\n            ebno_db = tf.fill([batch_size], ebno_db)\n        ######################################\n        ## Transmitter\n        no = ebnodb2no(ebno_db=ebno_db, num_bits_per_symbol=num_bits_per_symbol,\n                       coderate=R)  # normalize in OFDM freq. domain\n        b = self._binary_source([batch_size, n_ue, 1, K])\n        c = self._encoder(b)\n        # Modulation\n        x = self._mapper(c)\n        x_rg = self._rg_mapper(x)\n        ######################################\n        ## Channel\n        # A batch of new channel realizations is sampled and applied at every inference\n        no_ = expand_to_rank(no, tf.rank(x_rg))\n        y, h = self._channel([x_rg, no_])\n        ######################################\n        ## Receiver\n        if self._perfect_csi_rayleigh:\n            h_hat = self._removeNulledSc(h)\n            chan_est_var = tf.zeros(tf.shape(h_hat),\n                                    dtype=tf.float32)  # No channel estimation error when perfect CSI knowledge is assumed\n        else:\n            h_hat, chan_est_var = self._ls_est([y, no])\n        llr_ch = self._detector((y, h_hat, chan_est_var, no))  # soft-output LMMSE detection\n        msg_vn = None\n        if self._num_idd_iter >= 2:\n            # perform first iteration outside the while_loop to initialize msg_vn\n            [llr_dec, msg_vn] = self._siso_decoder((llr_ch, msg_vn))\n            # forward a posteriori information from decoder\n            llr_ch = self._siso_detector((y, h_hat, llr_dec, chan_est_var, no))\n            # forward extrinsic information\n            def idd_iter(llr_ch, msg_vn, it):\n                [llr_dec, msg_vn] = self._siso_decoder([llr_ch, msg_vn])\n                # forward a posteriori information from decoder\n                llr_ch = self._siso_detector((y, h_hat, llr_dec, chan_est_var, no))\n                # forward extrinsic information from detector\n                it += 1\n                return llr_ch, msg_vn, it\n            def idd_stop(llr_ch, msg_vn, it):\n                return tf.less(it, self._num_idd_iter - 1)\n            it = tf.constant(1)     # we already performed initial detection and one full iteration\n            llr_ch, msg_vn, it = tf.while_loop(idd_stop, idd_iter, (llr_ch, msg_vn, it), parallel_iterations=1,\n                                               maximum_iterations=self._num_idd_iter - 1)\n        else:\n            # non-idd\n            pass\n        [b_hat, _] = self._decoder((llr_ch, msg_vn))    # final hard-output decoding (only returning information bits)\n        return b, b_hat\n```"
"## Non-IDD versus IDD Benchmarks\n\n\n```python\n# Range of SNR (dB)\nsnr_range_cest = np.linspace(ebno_db_min_cest, ebno_db_max_cest, num_steps)\nsnr_range_perf_csi = np.linspace(ebno_db_min_perf_csi, ebno_db_max_perf_csi, num_steps)\ndef run_idd_sim(snr_range, perfect_csi_rayleigh):\n    lmmse = NonIddModel(detector=\"lmmse\", perfect_csi_rayleigh=perfect_csi_rayleigh)\n    k_best = NonIddModel(detector=\"k-best\", perfect_csi_rayleigh=perfect_csi_rayleigh)\n    ep = NonIddModel(detector=\"ep\", perfect_csi_rayleigh=perfect_csi_rayleigh)\n    idd2 = IddModel(num_idd_iter=2, perfect_csi_rayleigh=perfect_csi_rayleigh)\n    idd3 = IddModel(num_idd_iter=3, perfect_csi_rayleigh=perfect_csi_rayleigh)\n    ber_lmmse, bler_lmmse = sim_ber(lmmse,\n                                    snr_range,\n                                    batch_size=batch_size,\n                                    max_mc_iter=num_iter,\n                                    num_target_block_errors=int(batch_size * num_iter * 0.1))\n    ber_ep, bler_ep = sim_ber(ep,\n                              snr_range,\n                              batch_size=batch_size,\n                              max_mc_iter=num_iter,\n                              num_target_block_errors=int(batch_size * num_iter * 0.1))\n    ber_kbest, bler_kbest = sim_ber(k_best,\n                                    snr_range,\n                                    batch_size=batch_size,\n                                    max_mc_iter=num_iter,\n                                    num_target_block_errors=int(batch_size * num_iter * 0.1))\n    ber_idd2, bler_idd2 = sim_ber(idd2,\n                                  snr_range,\n                                  batch_size=batch_size,\n                                  max_mc_iter=num_iter,\n                                  num_target_block_errors=int(batch_size * num_iter * 0.1))\n    ber_idd3, bler_idd3 = sim_ber(idd3,\n                                  snr_range,\n                                  batch_size=batch_size,\n                                  max_mc_iter=num_iter,\n                                  num_target_block_errors=int(batch_size * num_iter * 0.1))\n    return bler_lmmse, bler_ep, bler_kbest, bler_idd2, bler_idd3\n\nBLER = {}\n# Perfect CSI\nbler_lmmse, bler_ep, bler_kbest, bler_idd2, bler_idd3 = run_idd_sim(snr_range_perf_csi, perfect_csi_rayleigh=True)\nBLER['Perf. CSI / LMMSE'] = bler_lmmse\nBLER['Perf. CSI / EP'] = bler_ep\nBLER['Perf. CSI / K-Best'] = bler_kbest\nBLER['Perf. CSI / IDD2'] = bler_idd2\nBLER['Perf. CSI / IDD3'] = bler_idd3\n# Estimated CSI\nbler_lmmse, bler_ep, bler_kbest, bler_idd2, bler_idd3 = run_idd_sim(snr_range_cest, perfect_csi_rayleigh=False)\nBLER['Ch. Est. / LMMSE'] = bler_lmmse\nBLER['Ch. Est. / EP'] = bler_ep\nBLER['Ch. Est. / K-Best'] = bler_kbest\nBLER['Ch. Est. / IDD2'] = bler_idd2\nBLER['Ch. Est. / IDD3'] = bler_idd3\n```"
"```python\nWARNING:tensorflow:From /usr/local/lib/python3.8/dist-packages/tensorflow/python/autograph/pyct/static_analysis/liveness.py:83: Analyzer.lamba_check (from tensorflow.python.autograph.pyct.static_analysis.liveness) is deprecated and will be removed after 2023-09-23.\nInstructions for updating:\nLambda fuctions will be no more assumed to be used in the statement where they are used, or at least in the same block. https://github.com/tensorflow/tensorflow/issues/56089\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 2.1174e-01 | 1.0000e+00 |      249776 |     1179648 |         1024 |        1024 |         5.7 |reached target block errors\n     -9.0 | 1.8563e-01 | 1.0000e+00 |      218982 |     1179648 |         1024 |        1024 |         0.3 |reached target block errors\n     -8.0 | 1.0665e-01 | 9.5898e-01 |      125808 |     1179648 |          982 |        1024 |         0.3 |reached target block errors\n     -7.0 | 1.6909e-02 | 3.3828e-01 |       49867 |     2949120 |          866 |        2560 |         0.9 |reached target block errors\n     -6.0 | 1.1546e-03 | 3.3143e-02 |       33030 |    28606464 |          823 |       24832 |         8.3 |reached target block errors\n     -5.0 | 6.4903e-05 | 2.3804e-03 |        2450 |    37748736 |           78 |       32768 |        11.0 |reached max iter\n     -4.0 | 2.6491e-07 | 1.2207e-04 |          10 |    37748736 |            4 |       32768 |        10.9 |reached max iter\n     -3.0 | 0.0000e+00 | 0.0000e+00 |           0 |    37748736 |            0 |       32768 |        10.9 |reached max iter\nSimulation stopped as no error occurred @ EbNo = -3.0 dB.\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 2.1091e-01 | 1.0000e+00 |      248794 |     1179648 |         1024 |        1024 |         3.8 |reached target block errors\n     -9.0 | 1.8493e-01 | 1.0000e+00 |      218155 |     1179648 |         1024 |        1024 |         0.4 |reached target block errors\n     -8.0 | 9.8120e-02 | 9.5508e-01 |      115747 |     1179648 |          978 |        1024 |         0.4 |reached target block errors\n     -7.0 | 1.1955e-02 | 2.8027e-01 |       42309 |     3538944 |          861 |        3072 |         1.2 |reached target block errors\n     -6.0 | 4.5117e-04 | 1.6541e-02 |       17031 |    37748736 |          542 |       32768 |        12.7 |reached max iter\n     -5.0 | 1.5471e-05 | 7.6294e-04 |         584 |    37748736 |           25 |       32768 |        12.5 |reached max iter\n     -4.0 | 0.0000e+00 | 0.0000e+00 |           0 |    37748736 |            0 |       32768 |        12.7 |reached max iter\nSimulation stopped as no error occurred @ EbNo = -4.0 dB.\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 2.1164e-01 | 1.0000e+00 |      249660 |     1179648 |         1024 |        1024 |         6.3 |reached target block errors\n     -9.0 | 1.8471e-01 | 1.0000e+00 |      217898 |     1179648 |         1024 |        1024 |         2.1 |reached target block errors\n     -8.0 | 1.1558e-01 | 9.9512e-01 |      136338 |     1179648 |         1019 |        1024 |         2.1 |reached target block errors\n     -7.0 | 1.8488e-02 | 5.6315e-01 |       32714 |     1769472 |          865 |        1536 |         3.2 |reached target block errors\n     -6.0 | 9.5951e-04 | 4.6762e-02 |       19525 |    20348928 |          826 |       17664 |        36.3 |reached target block errors\n     -5.0 | 1.9338e-05 | 1.4343e-03 |         730 |    37748736 |           47 |       32768 |        67.2 |reached max iter\n     -4.0 | 1.5895e-07 | 6.1035e-05 |           6 |    37748736 |            2 |       32768 |        67.2 |reached max iter\n     -3.0 | 0.0000e+00 | 0.0000e+00 |           0 |    37748736 |            0 |       32768 |        67.0 |reached max iter\nSimulation stopped as no error occurred @ EbNo = -3.0 dB.\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 2.1164e-01 | 1.0000e+00 |      249662 |     1179648 |         1024 |        1024 |         8.2 |reached target block errors\n     -9.0 | 1.8639e-01 | 1.0000e+00 |      219878 |     1179648 |         1024 |        1024 |         0.6 |reached target block errors\n     -8.0 | 8.6596e-02 | 6.9844e-01 |      127691 |     1474560 |          894 |        1280 |         0.7 |reached target block errors\n     -7.0 | 3.4296e-03 | 4.6535e-02 |       69788 |    20348928 |          822 |       17664 |        10.3 |reached target block errors\n     -6.0 | 6.1750e-05 | 8.5449e-04 |        2331 |    37748736 |           28 |       32768 |        18.9 |reached max iter\n     -5.0 | 1.0596e-06 | 3.0518e-05 |          40 |    37748736 |            1 |       32768 |        18.9 |reached max iter\n     -4.0 | 0.0000e+00 | 0.0000e+00 |           0 |    37748736 |            0 |       32768 |        18.9 |reached max iter\nSimulation stopped as no error occurred @ EbNo = -4.0 dB.\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 2.1188e-01 | 1.0000e+00 |      249945 |     1179648 |         1024 |        1024 |         7.8 |reached target block errors\n     -9.0 | 1.8657e-01 | 9.9805e-01 |      220084 |     1179648 |         1022 |        1024 |         0.8 |reached target block errors\n     -8.0 | 7.6331e-02 | 5.7943e-01 |      135065 |     1769472 |          890 |        1536 |         1.2 |reached target block errors\n     -7.0 | 1.6263e-03 | 1.7822e-02 |       61390 |    37748736 |          584 |       32768 |        25.7 |reached max iter\n     -6.0 | 1.7325e-05 | 2.4414e-04 |         654 |    37748736 |            8 |       32768 |        25.5 |reached max iter\n     -5.0 | 0.0000e+00 | 0.0000e+00 |           0 |    37748736 |            0 |       32768 |        25.7 |reached max iter\nSimulation stopped as no error occurred @ EbNo = -5.0 dB.\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 2.9984e-01 | 1.0000e+00 |      353711 |     1179648 |         1024 |        1024 |        12.3 |reached target block errors\n     -8.0 | 2.6258e-01 | 1.0000e+00 |      309751 |     1179648 |         1024 |        1024 |         0.4 |reached target block errors\n     -6.0 | 2.2838e-01 | 1.0000e+00 |      269403 |     1179648 |         1024 |        1024 |         0.4 |reached target block errors\n     -4.0 | 1.4912e-01 | 9.0723e-01 |      175910 |     1179648 |          929 |        1024 |         0.4 |reached target block errors\n     -2.0 | 4.0182e-02 | 3.2930e-01 |      118503 |     2949120 |          843 |        2560 |         1.1 |reached target block errors\n      0.0 | 9.7169e-03 | 8.6571e-02 |      106028 |    10911744 |          820 |        9472 |         4.1 |reached target block errors\n      2.0 | 2.8845e-03 | 2.3529e-02 |      108885 |    37748736 |          771 |       32768 |        14.3 |reached max iter\n      4.0 | 1.2734e-03 | 9.0942e-03 |       48069 |    37748736 |          298 |       32768 |        14.1 |reached max iter\n      6.0 | 7.8371e-04 | 5.0354e-03 |       29584 |    37748736 |          165 |       32768 |        14.3 |reached max iter\n      8.0 | 9.9370e-04 | 6.1340e-03 |       37511 |    37748736 |          201 |       32768 |        14.2 |reached max iter\n     10.0 | 7.6546e-04 | 4.9744e-03 |       28895 |    37748736 |          163 |       32768 |        14.4 |reached max iter\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 3.0051e-01 | 1.0000e+00 |      354491 |     1179648 |         1024 |        1024 |         6.8 |reached target block errors\n     -8.0 | 2.6452e-01 | 1.0000e+00 |      312037 |     1179648 |         1024 |        1024 |         0.5 |reached target block errors\n     -6.0 | 2.2600e-01 | 1.0000e+00 |      266602 |     1179648 |         1024 |        1024 |         0.5 |reached target block errors\n     -4.0 | 1.4565e-01 | 9.0625e-01 |      171821 |     1179648 |          928 |        1024 |         0.5 |reached target block errors\n     -2.0 | 4.0697e-02 | 3.4258e-01 |      120021 |     2949120 |          877 |        2560 |         1.3 |reached target block errors\n      0.0 | 7.6236e-03 | 6.9633e-02 |      103421 |    13565952 |          820 |       11776 |         5.8 |reached target block errors\n      2.0 | 1.9709e-03 | 1.5198e-02 |       74400 |    37748736 |          498 |       32768 |        16.0 |reached max iter\n      4.0 | 9.2236e-04 | 6.6528e-03 |       34818 |    37748736 |          218 |       32768 |        16.1 |reached max iter\n      6.0 | 7.6371e-04 | 5.6152e-03 |       28829 |    37748736 |          184 |       32768 |        16.1 |reached max iter\n      8.0 | 1.0540e-03 | 6.3477e-03 |       39788 |    37748736 |          208 |       32768 |        15.9 |reached max iter\n     10.0 | 9.5132e-04 | 6.2866e-03 |       35911 |    37748736 |          206 |       32768 |        16.1 |reached max iter\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 3.0523e-01 | 1.0000e+00 |      360064 |     1179648 |         1024 |        1024 |         8.7 |reached target block errors\n     -8.0 | 2.6928e-01 | 1.0000e+00 |      317651 |     1179648 |         1024 |        1024 |         2.2 |reached target block errors\n     -6.0 | 2.3226e-01 | 1.0000e+00 |      273984 |     1179648 |         1024 |        1024 |         2.2 |reached target block errors\n     -4.0 | 1.6056e-01 | 9.7266e-01 |      189406 |     1179648 |          996 |        1024 |         2.2 |reached target block errors\n     -2.0 | 3.5856e-02 | 3.6936e-01 |       95168 |     2654208 |          851 |        2304 |         5.0 |reached target block errors\n      0.0 | 6.1384e-03 | 5.8168e-02 |       99566 |    16220160 |          819 |       14080 |        30.4 |reached target block errors\n      2.0 | 1.2737e-03 | 1.0498e-02 |       48079 |    37748736 |          344 |       32768 |        70.6 |reached max iter\n      4.0 | 9.2064e-04 | 5.4932e-03 |       34753 |    37748736 |          180 |       32768 |        70.7 |reached max iter\n      6.0 | 9.2936e-04 | 5.0049e-03 |       35082 |    37748736 |          164 |       32768 |        70.9 |reached max iter\n      8.0 | 7.4246e-04 | 4.6082e-03 |       28027 |    37748736 |          151 |       32768 |        70.6 |reached max iter\n     10.0 | 7.8665e-04 | 5.1270e-03 |       29695 |    37748736 |          168 |       32768 |        70.6 |reached max iter\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 3.0156e-01 | 1.0000e+00 |      355731 |     1179648 |         1024 |        1024 |        11.2 |reached target block errors\n     -8.0 | 2.6622e-01 | 1.0000e+00 |      314046 |     1179648 |         1024 |        1024 |         0.7 |reached target block errors\n     -6.0 | 2.3190e-01 | 1.0000e+00 |      273565 |     1179648 |         1024 |        1024 |         0.7 |reached target block errors\n     -4.0 | 1.5164e-01 | 8.2324e-01 |      178884 |     1179648 |          843 |        1024 |         0.7 |reached target block errors\n     -2.0 | 3.0409e-02 | 2.0581e-01 |      143489 |     4718592 |          843 |        4096 |         2.8 |reached target block errors\n      0.0 | 4.0669e-03 | 3.0469e-02 |      125935 |    30965760 |          819 |       26880 |        18.0 |reached target block errors\n      2.0 | 1.4712e-03 | 9.0942e-03 |       55536 |    37748736 |          298 |       32768 |        22.0 |reached max iter\n      4.0 | 6.7668e-04 | 3.9368e-03 |       25544 |    37748736 |          129 |       32768 |        21.9 |reached max iter\n      6.0 | 7.9192e-04 | 4.2725e-03 |       29894 |    37748736 |          140 |       32768 |        21.7 |reached max iter\n      8.0 | 8.3711e-04 | 5.1575e-03 |       31600 |    37748736 |          169 |       32768 |        22.3 |reached max iter\n     10.0 | 7.4954e-04 | 4.7913e-03 |       28294 |    37748736 |          157 |       32768 |        22.0 |reached max iter\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n    -10.0 | 3.0150e-01 | 1.0000e+00 |      355662 |     1179648 |         1024 |        1024 |        11.6 |reached target block errors\n     -8.0 | 2.6787e-01 | 1.0000e+00 |      315993 |     1179648 |         1024 |        1024 |         0.9 |reached target block errors\n     -6.0 | 2.3101e-01 | 1.0000e+00 |      272511 |     1179648 |         1024 |        1024 |         0.9 |reached target block errors\n     -4.0 | 1.4615e-01 | 7.9844e-01 |      215510 |     1474560 |         1022 |        1280 |         1.2 |reached target block errors\n     -2.0 | 2.3105e-02 | 1.4453e-01 |      156722 |     6782976 |          851 |        5888 |         5.3 |reached target block errors\n      0.0 | 3.5593e-03 | 2.1973e-02 |      134358 |    37748736 |          720 |       32768 |        29.4 |reached max iter\n      2.0 | 1.3395e-03 | 7.1411e-03 |       50564 |    37748736 |          234 |       32768 |        29.2 |reached max iter\n      4.0 | 7.4816e-04 | 3.9062e-03 |       28242 |    37748736 |          128 |       32768 |        29.4 |reached max iter\n      6.0 | 7.6657e-04 | 3.9368e-03 |       28937 |    37748736 |          129 |       32768 |        29.4 |reached max iter\n      8.0 | 8.2713e-04 | 4.1504e-03 |       31223 |    37748736 |          136 |       32768 |        29.3 |reached max iter\n     10.0 | 7.2932e-04 | 4.2114e-03 |       27531 |    37748736 |          138 |       32768 |        29.4 |reached max iter\n```"
"Finally, we plot the simulation results and observe that IDD outperforms the non-iterative methods by about 1 dB in the scenario with iid Rayleigh fading channels and perfect CSI. In the scenario with 3GPP UMa channels and estimated CSI, IDD performs slightly better than K-best, at considerably lower runtime.\n\n\n```python\nfig, ax = plt.subplots(1,2, figsize=(16,7))\nfig.suptitle(f\"{n_ue}x{NUM_RX_ANT} MU-MIMO UL | {2**num_bits_per_symbol}-QAM\")\n## Perfect CSI Rayleigh\nax[0].set_title(\"Perfect CSI iid. Rayleigh\")\nax[0].semilogy(snr_range_perf_csi, BLER['Perf. CSI / LMMSE'], 'x-', label='LMMSE', c='C0')\nax[0].semilogy(snr_range_perf_csi, BLER['Perf. CSI / EP'], 'o--', label='EP', c='C0')\nax[0].semilogy(snr_range_perf_csi, BLER['Perf. CSI / K-Best'], 's-.', label='K-Best', c='C0')\nax[0].semilogy(snr_range_perf_csi, BLER['Perf. CSI / IDD2'], 'd:', label=r'IDD $I=2$', c='C1')\nax[0].semilogy(snr_range_perf_csi, BLER['Perf. CSI / IDD3'], 'd:', label=r'IDD $I=3$', c='C2')\nax[0].set_xlabel(r\"$E_b/N0$\")\nax[0].set_ylabel(\"BLER\")\nax[0].set_ylim((1e-4, 1.0))\nax[0].legend()\nax[0].grid(True)\n## Estimated CSI Rayleigh\nax[1].set_title(\"Estimated CSI 3GPP UMa\")\nax[1].semilogy(snr_range_cest, BLER['Ch. Est. / LMMSE'], 'x-', label='LMMSE', c='C0')\nax[1].semilogy(snr_range_cest, BLER['Ch. Est. / EP'], 'o--', label='EP', c='C0')\nax[1].semilogy(snr_range_cest, BLER['Ch. Est. / K-Best'], 's-.', label='K-Best', c='C0')\nax[1].semilogy(snr_range_cest, BLER['Ch. Est. / IDD2'], 'd:', label=r'IDD $I=2$', c='C1')\nax[1].semilogy(snr_range_cest, BLER['Ch. Est. / IDD3'], 'd:', label=r'IDD $I=3$', c='C2')\nax[1].set_xlabel(r\"$E_b/N0$\")\nax[1].set_ylabel(\"BLER\")\nax[1].set_ylim((1e-3, 1.0))\nax[1].legend()\nax[1].grid(True)\nplt.show()\n```"
"## Discussion-Optimizing IDD with Machine Learning\n\nRecent work [4] showed that IDD can be significantly improved by deep-unfolding, which applies machine learning to automatically tune hyperparameters of classical algorithms. The proposed *Deep-Unfolded Interleaved Detection and Decoding* method showed performance gains of up to 1.4 dB at the same computational complexity. A link to the simulation code is available in the <a class=\"reference external\" href=\"https://nvlabs.github.io/sionna/made_with_sionna.html#duidd-deep-unfolded-interleaved-detection-and-decoding-for-mimo-wireless-systems\">Made with\nSionna</a> section."
"## Comments\n\n- As discussed in [3], IDD receivers with a non-resetting decoder converge faster than with resetting decoders. However, a resetting decoder (which does not forward `msg_vn`) might perform slightly better for a large number of message passing decoding iterations. Among other quantities, a scaling of the forwarded decoder state is optimized in the DUIDD receiver [4].\n- With estimated channels, we observed that the MMSE-PIC output LLRs become large, much larger as with non-iterative receive processing."
"## List of References\n\n[1] B. Hochwald and S. Ten Brink, [Achieving near-capacity on a multiple-antenna channel,](https://ieeexplore.ieee.org/abstract/document/1194444) IEEE Trans. Commun., vol.51, no. 3, pp.389399, Mar.2003.\n\n[2] C. Studer, S. Fateh, and D. Seethaler, [ASIC implementation of soft-input soft-output MIMO detection using MMSE parallel interference cancellation,](https://ieeexplore.ieee.org/abstract/document/5779722) IEEE Journal of Solid-State Circuits, vol.46, no. 7, pp.17541765, Jul.2011.\n\n[3] W.-C. Sun, W.-H. Wu, C.-H. Yang, and Y.-L. Ueng, [An iterative detection and decoding receiver for LDPC-coded MIMO systems,](https://ieeexplore.ieee.org/abstract/document/7272776) IEEE Trans. Circuits Syst. I, vol.62, no. 10, pp.25122522, Oct.2015.\n\n[4] R. Wiesmayr, C. Dick, J. Hoydis, and C. Studer, [DUIDD: Deep-unfolded interleaved detection and decoding for MIMO wireless systems,](https://arxiv.org/abs/2212.07816) in Asilomar Conf. Signals, Syst., Comput., Oct.2022.[4] R. Wiesmayr, C. Dick, J. Hoydis, and C. Studer, [DUIDD: Deep-unfolded interleaved detection and decoding for MIMO wireless systems,](https://arxiv.org/abs/2212.07816) in Asilomar Conf. Signals, Syst., Comput., Oct.2022.\n[4] R. Wiesmayr, C. Dick, J. Hoydis, and C. Studer, [DUIDD: Deep-unfolded interleaved detection and decoding for MIMO wireless systems,](https://arxiv.org/abs/2212.07816) in Asilomar Conf. Signals, Syst., Comput., Oct.2022.[4] R. Wiesmayr, C. Dick, J. Hoydis, and C. Studer, [DUIDD: Deep-unfolded interleaved detection and decoding for MIMO wireless systems,](https://arxiv.org/abs/2212.07816) in Asilomar Conf. Signals, Syst., Comput., Oct.2022."

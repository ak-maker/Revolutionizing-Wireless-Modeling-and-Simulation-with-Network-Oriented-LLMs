"# Scrambling\n\nThe [`Scrambler`](https://nvlabs.github.io/sionna/api/fec.scrambling.html#sionna.fec.scrambling.Scrambler) module allows to (pseudo)\nrandomly flip bits in a binary sequence or the signs of a real-valued sequence,\nrespectively. The [`Descrambler`](https://nvlabs.github.io/sionna/api/fec.scrambling.html#sionna.fec.scrambling.Descrambler) implement the corresponding descrambling operation.\n\nTo simplify distributed graph execution (e.g., by running scrambler and\ndescrambler in a different sub-graph/device), the scramblers are implemented\nstateless. Thus, the internal seed cannot be update on runtime and does not\nchange after the initialization.\nHowever, if required an explicit random seed can be passed as additional input\nthe scrambler/descrambler pair when calling the layer.\n\nFurther, the [`TB5GScrambler`](https://nvlabs.github.io/sionna/api/fec.scrambling.html#sionna.fec.scrambling.TB5GScrambler) enables 5G NR compliant\nscrambling as specified in [[3GPPTS38211_scr]](https://nvlabs.github.io/sionna/api/fec.scrambling.html#gppts38211-scr).\n\nThe following code snippet shows how to setup and use an instance of the\nscrambler:\n```python\n# set-up system\nscrambler = Scrambler(seed=1234, # an explicit seed can be provided\n                     binary=True) # indicate if bits shall be flipped\ndescrambler = Descrambler(scrambler=scrambler) # connect scrambler and descrambler\n# --- simplified usage with fixed seed ---\n# c has arbitrary shape and contains 0s and 1s (otherwise set binary=False)\nc_scr = scrambler(c)\n# descramble to reconstruct the original order\nc_descr = descrambler(c_scr)\n# --- advanced usage ---\n# provide explicite seed if a new random seed should be used for each call\ns = tf.random.uniform((), minval=0, maxval=12345678, dtype=tf.int32)\nc_scr = scrambler([c, s])\nc_descr = descrambler([c_scr, s])\n```"
"## Scrambler\n\n`class` `sionna.fec.scrambling.``Scrambler`(*`seed=None`*, *`keep_batch_constant=False`*, *`sequence=None`*, *`binary=True` `keep_state=True`*, *`dtype=tf.float32`*, *`**kwargs`*)[`[source]`](../_modules/sionna/fec/scrambling.html#Scrambler)\n\nRandomly flips the state/sign of a sequence of bits or LLRs, respectively.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **seed** (*int*)  Defaults to None. Defines the initial state of the\npseudo random generator to generate the scrambling sequence.\nIf None, a random integer will be generated. Only used\nwhen called with `keep_state` is True.\n- **keep_batch_constant** (*bool*)  Defaults to False. If True, all samples in the batch are scrambled\nwith the same scrambling sequence. Otherwise, per sample a random\nsequence is generated.\n- **sequence** (*Array of 0s and 1s** or **None*)  If provided, the seed will be ignored and the explicit scrambling\nsequence is used. Shape must be broadcastable to `x`.\n- **binary** (*bool*)  Defaults to True. Indicates whether bit-sequence should be flipped\n(i.e., binary operations are performed) or the signs should be\nflipped (i.e., soft-value/LLR domain-based).\n- **keep_state** (*bool*)  Defaults to True. Indicates whether the scrambling sequence should\nbe kept constant.\n- **dtype** (*tf.DType*)  Defaults to <cite>tf.float32</cite>. Defines the datatype for internal\ncalculations and the output dtype.\n\n\nInput\n\n- **(x, seed, binary)**  Either Tuple `(x,` `seed,` `binary)` or  `(x,` `seed)` or `x` only\n(no tuple) if the internal  seed should be used:\n- **x** (*tf.float*)  1+D tensor of arbitrary shape.\n- **seed** (*int*)  An integer defining the state of the random number\ngenerator. If explicitly given, the global internal seed is\nreplaced by this seed. Can be used to realize random\nscrambler/descrambler pairs (call with same random seed).\n- **binary** (*bool*)  Overrules the init parameter <cite>binary</cite> iff explicitly given.\nIndicates whether bit-sequence should be flipped\n(i.e., binary operations are performed) or the signs should be\nflipped (i.e., soft-value/LLR domain-based).\n\n\nOutput\n\n*tf.float*  1+D tensor of same shape as `x`.\n\n\n**Note**\n\nFor inverse scrambling, the same scrambler can be re-used (as the values\nare flipped again, i.e., result in the original state). However,\n`keep_state` must be set to True as a new sequence would be generated\notherwise.\n\nThe scrambler layer is stateless, i.e., the seed is either random\nduring each call or must be explicitly provided during init/call.\nThis simplifies XLA/graph execution.\nIf the seed is provided in the init() function, this fixed seed is used\nfor all calls. However, an explicit seed can be provided during\nthe call function to realize <cite>true</cite> random states.\n\nScrambling is typically used to ensure equal likely <cite>0</cite>  and <cite>1</cite> for\nsources with unequal bit probabilities. As we have a perfect source in\nthe simulations, this is not required. However, for all-zero codeword\nsimulations and higher-order modulation, so-called channel-adaptation\n[[Pfister03]](https://nvlabs.github.io/sionna/api/fec.scrambling.html#pfister03) is required.\n\nRaises\n\n- **AssertionError**  If `seed` is not int.\n- **AssertionError**  If `keep_batch_constant` is not bool.\n- **AssertionError**  If `binary` is not bool.\n- **AssertionError**  If `keep_state` is not bool.\n- **AssertionError**  If `seed` is provided to list of inputs but not an\n    int.\n- **TypeError**  If <cite>dtype</cite> of `x` is not as expected.\n\n\n`property` `keep_state`\n\nIndicates if new random sequences are used per call.\n\n\n`property` `seed`\n\nSeed used to generate random sequence.\n\n\n`property` `sequence`\n\nExplicit scrambling sequence if provided."
"## TB5GScrambler\n\n`class` `sionna.fec.scrambling.``TB5GScrambler`(*`n_rnti``=``1`*, *`n_id``=``1`*, *`binary``=``True`*, *`channel_type``=``'PUSCH'`*, *`codeword_index``=``0`*, *`dtype``=``tf.float32`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/scrambling.html#TB5GScrambler)\n\nImplements the pseudo-random bit scrambling as defined in\n[[3GPPTS38211_scr]](https://nvlabs.github.io/sionna/api/fec.scrambling.html#gppts38211-scr) Sec. 6.3.1.1 for the PUSCH channel and in Sec. 7.3.1.1\nfor the PDSCH channel.\n\nOnly for the PDSCH channel, the scrambler can be configured for two\ncodeword transmission mode. Hereby, `codeword_index` corresponds to the\nindex of the codeword to be scrambled.\n\nIf `n_rnti` are a list of ints, the scrambler assumes that the second\nlast axis contains <cite>len(</cite> `n_rnti` <cite>)</cite> elements. This allows independent\nscrambling for multiple independent streams.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **n_rnti** (*int** or **list of ints*)  RNTI identifier provided by higher layer. Defaults to 1 and must be\nin range <cite>[0, 65335]</cite>. If a list is provided, every list element\ndefines a scrambling sequence for multiple independent streams.\n- **n_id** (*int** or **list of ints*)  Scrambling ID related to cell id and provided by higher layer.\nDefaults to 1 and must be in range <cite>[0, 1023]</cite>. If a list is\nprovided, every list element defines a scrambling sequence for\nmultiple independent streams.\n- **binary** (*bool*)  Defaults to True. Indicates whether bit-sequence should be flipped\n(i.e., binary operations are performed) or the signs should be\nflipped (i.e., soft-value/LLR domain-based).\n- **channel_type** (*str*)  Can be either PUSCH or PDSCH.\n- **codeword_index** (*int*)  Scrambler can be configured for two codeword transmission.\n`codeword_index` can be either 0 or 1.\n- **dtype** (*tf.DType*)  Defaults to <cite>tf.float32</cite>. Defines the datatype for internal\ncalculations and the output dtype.\n\n\nInput\n\n- **(x, binary)**  Either Tuple `(x,` `binary)` or  `x` only\n- **x** (*tf.float*)  1+D tensor of arbitrary shape. If `n_rnti` and `n_id` are a\nlist, it is assumed that `x` has shape\n<cite>[,num_streams, n]</cite> where <cite>num_streams=len(</cite> `n_rnti` <cite>)</cite>.\n- **binary** (*bool*)  Overrules the init parameter <cite>binary</cite> iff explicitly given.\nIndicates whether bit-sequence should be flipped\n(i.e., binary operations are performed) or the signs should be\nflipped (i.e., soft-value/LLR domain-based).\n\n\nOutput\n\n*tf.float*  1+D tensor of same shape as `x`.\n\n\n**Note**\n\nThe parameters radio network temporary identifier (RNTI) `n_rnti` and\nthe datascrambling ID `n_id` are usually provided be the higher layer protocols.\n\nFor inverse scrambling, the same scrambler can be re-used (as the values\nare flipped again, i.e., result in the original state).\n\n`property` `keep_state`\n\nRequired for descrambler, is always <cite>True</cite> for the TB5GScrambler."
"## Descrambler\n\n`class` `sionna.fec.scrambling.``Descrambler`(*`scrambler`*, *`binary``=``True`*, *`dtype``=``None`*, *`**``kwargs`*)[`[source]`](../_modules/sionna/fec/scrambling.html#Descrambler)\n\nDescrambler for a given scrambler.\n\nThe class inherits from the Keras layer class and can be used as layer in a\nKeras model.\nParameters\n\n- **scrambler** (*, *)  Associated [`Scrambler`](https://nvlabs.github.io/sionna/api/fec.scrambling.html#sionna.fec.scrambling.Scrambler) or\n[`TB5GScrambler`](https://nvlabs.github.io/sionna/api/fec.scrambling.html#sionna.fec.scrambling.TB5GScrambler) instance which\nshould be descrambled.\n- **binary** (*bool*)  Defaults to True. Indicates whether bit-sequence should be flipped\n(i.e., binary operations are performed) or the signs should be\nflipped (i.e., soft-value/LLR domain-based).\n- **dtype** (*None** or **tf.DType*)  Defaults to <cite>None</cite>. Defines the datatype for internal calculations\nand the output dtype. If no explicit dtype is provided the dtype\nfrom the associated interleaver is used.\n\n\nInput\n\n- **(x, seed)**  Either Tuple `(x,` `seed)` or `x` only (no tuple) if the internal\nseed should be used:\n- **x** (*tf.float*)  1+D tensor of arbitrary shape.\n- **seed** (*int*)  An integer defining the state of the random number\ngenerator. If explicitly given, the global internal seed is\nreplaced by this seed. Can be used to realize random\nscrambler/descrambler pairs (call with same random seed).\n\n\nOutput\n\n*tf.float*  1+D tensor of same shape as `x`.\n\nRaises\n\n- **AssertionError**  If `scrambler` is not an instance of <cite>Scrambler</cite>.\n- **AssertionError**  If `seed` is provided to list of inputs but not an\n    int.\n- **TypeError**  If <cite>dtype</cite> of `x` is not as expected.\n\n\n`property` `scrambler`\n\nAssociated scrambler instance.\n\n\nReferences:\n[Pfister03](https://nvlabs.github.io/sionna/api/fec.scrambling.html#id2)\n\nJ. Hou, P.Siegel, L. Milstein, and H. Pfister, Capacity\napproaching bandwidth-efficient coded modulation schemes\nbased on low-density parity-check codes, IEEE Trans. Inf. Theory,\nSep. 2003.\n\n3GPPTS38211_scr([1](https://nvlabs.github.io/sionna/api/fec.scrambling.html#id1),[2](https://nvlabs.github.io/sionna/api/fec.scrambling.html#id3))\n\nETSI 3GPP TS 38.211 Physical channels and modulation,\nv.16.2.0, 2020-07."
